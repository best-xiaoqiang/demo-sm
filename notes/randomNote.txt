1.什么是前端？
2.什么是闭包？
$闭包
百度百科：闭包就是能够读取其他函数内部变量的函数。
这个能够读取某函数内部变量的函数，必定就是某函数的内部函数，或者代理某函数内部函数的函数。
怎样理解只有内部的函数可以读取函数的变量？
全局就相当于一个大广场，
每当有一个函数在大广场建立，就相当于在大广场“自立门户”，盖了一座房子；
如果在这个房子里又有房子建立，就相当于在这个房子中又“自立门户”；
以此类推。
同时呢，住在一个房子内的人，肯定有这把房子的钥匙，
如果这个人不断的在房子里建房子，也就是函数嵌套，
那这个人一定有各个房子的钥匙，也就是它可以一层一层访问外边，
除了这个房子的人，外边的人并不能访问他的房子。

每当有一个函数建立，就好像又雇佣了一个人。

闭包：函数内部的函数可以访问函数内部的变量，将函数内部的函数赋值给函数外部的变量，然后调用这个变量；

函数是干完就走的，对象是被留下来的。
一般情况下，函数是干完就走的，这就是执行环境的生命周期在函数执行完之后销毁。
但是一旦将函数赋值给变量，那么就相当于把它留下来了。

var相当于自己设立了一个职位。
var a=1
就是设置了一个职位a.
var了而没有赋值，就相当于有这个职位而没人。但是执行的时候是按照自己团队有这个职位就不往上层去找了的规则找的，
所以这个职位就会变成undefined并会报一些错。
没var的话，就根本没有这个职位，肯定就是直接管雇佣他们的团队去要人的。他可能会说，我们做这个需要一个前端来干什么什么。。

假如说不管是父函数函数子函数、他们都是需要隐私的，那么子函数实现了，
而父函数却没有实现，
可以说是，父函数没有办法实现。
因为他雇佣一支团队来帮他完成某件事情，总得让别人知道他要完成什么事情吧。

闭包是为了代替对象的？
闭包的作用是保护函数内的变量安全？
函数内的变量本来就是安全的，因为函数外部不能访问函数内部本来就是函数的特性。
function a(){
 var i=0
 function b(){
  alert(++i)
 }
 return b
}
var c=a()
c()

实现私有的“全局变量”，闭包就是比对象更安全些，因为闭包用到了函数作用域。

一个团队被雇佣之后，他是可以不断地往上去要东西的。
他需要的东西，自身没有，就去雇佣他的那里要，再没有就问雇佣他的人是被谁雇佣的的，然后再要。
这就是作用域链。
后面还看到“先找原型链，再找作用域链”？
先问自己的帮会有没有，然后管雇佣者去要？

一个被雇佣者，和他需要的所有的东西（包括他朝上面要到的东西），就是一个闭包。
闭包就是一个“可以正常工作的雇佣者”？
闭包确实是一个可以正常工作的函数。他正常工作的前提就是他需要的东西都在。所以雇佣他的人不能走。
作用域链是函数创建的时候就形成的吗？
如果是的话，就说明函数被创建的时候他的能朝谁要东西的关系就已经定了，基本上都是一个正常工作的被雇佣者。
后续想确保正常工作的时候，必须保持这个雇佣关系。否则很可能需要的东西没处要。

「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。 // 那就是函数和其作用域的总和，是闭包？
但是，「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」
前者是闭包的定义。
后者更多是在解释“如何利用闭包”。

而且在“如何利用闭包”的问题上，主要利用的是闭包的特点。
即内部函数可以访问外部函数的变量。

作用域链相当于留联系方式？

当某个函数被调用时，会创建一个执行环境及相应的作用域链。

变量对象就相当于人事、管家，管自己公司有那些人的。
作用域链就是留下上级以及上上级的人事的联系方式，通过他们可以找到他们公司的人或东西。
（每雇佣一个团队的时候，人事就会留下自己的电话，说，有什么需要就联系我）
每个执行环境都有一个与之关联的“变量对象”，环境中定义的所有变量和函数都保存在这个对象中。作用域链保存相关的“变量对象”。

一个公司把事情干完了，人事就会被通知，把自己管理的这堆垃圾带走，我们这里就不留你们了。
但是作用域链是负责和相关的人事联系的，他得知在自己还没干活的情况下，有人事被通知“将你们这堆垃圾带走”的时候，他就会说不行、
如果你们把他们带走我们有可能干不了活（也可以是说，因为被雇佣的公司一般都会用到雇佣者的人力，所以只要有人还保留某个人事的联系方式，
说明还可能有用，人事就不会被通知走人）。
函数的变量对象一般在函数调用结束后被销毁，被垃圾回收。

闭包1：能够访问另一个函数作用域中变量的函数。（return的、window.xxx的）
闭包2：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
闭包3：函数和函数内部能访问到的变量的总和，就是一个闭包。（经理能通过人事联系到的所有人、资源）


闭包：
每个函数，都有一个本公司的名单，这就是变量对象；
同时，又有他的所有父函数的名单，即其它函数自己的变量对象；
自己的变量对象+其它函数的变量对象=作用域；
作用域也就是属于他的员工名单。
当某个函数执行完成后，他的名单被销毁，名单上的人会被标记并杀害。
这就是垃圾处理。
但是，如果内部函数没有return,或者被保存成一个变量？
由于它拥有一份名单，名单上的人就会免于“被杀害”。

见javascript高级程序设计p179

3.什么是继承？
4.什么是原型链？
原型链是这个过程中物质共享。

new Foo()的时候就相当于加入Foo派，然后他就能得到一把Foo提供的通往其prototype钥匙，然后就可以去Foo的prototype里面拿东西了。

new Bar() instanceof Bar的意思就是“new Bar()能访问到Bar提供的仓库吗？”

//      正常情况下，一个对象的prototype里保存着constructor属性，construcetor里是创建这个对象的函数
//      对于构造函数来说，就是再他为跟随者提供的公共空间prototype中，不但有一把通向Object的钥匙，
//      还有一把可以找到自己这个团队（函数是团队）的钥匙？

也就是说这个函数实际上是一直存在的，不管他存在哪儿。有一个地址可以找到他。

相对于作用域，原型就像是入会、进社团、加入某某势力、参加天地会。

而雇佣关系中，函数干完就走，其中影响的运行内存，相当于管他们吃饭？

5.什么是内存泄漏？
6.什么是this?
this就是“你”的意思。
函数执行的this指的是window，就好比“君”代指的皇帝一样。
构造函数的this指向是新创建的对象，就好像招人的人给被招的人开会，说你一样。
你的什么是什么，你碰到什么问题的时候怎么办。

this就是君，就是老大的意思。
只要不是xxx.xxx()的形式，那么一个函数的运行时的老大都是window。
而xxx.xxx()的形式，就是说现在xxx是老大，然后来运行什么。



2018/6/4
Object、Array、String、Object都是new Function之后出来的。它们都是函数？
String.__proto__ == Function.prototype
true
Date.__proto__ == Function.prototype
true


2018/6/26
为什么要定义变量？
用着方便。
变量赋值：
变量的名字，就好比人的名字。
基本类型的变量赋值：
数字、字符串、布尔类型的赋值，就是直接把一个名字和值联系在一起。
var a = '程序员'、 好比a是程序员；
var b = false、 可以理解成b是一个坏人；
var c = 100、 可以认为c就代表100，他可以是100块，也可以是100斤，这个要看你后边的代码怎么用。
而一个值是undefined，大部分情况下是，你创造了一个人物但是没有给他任何角色，或者说你在使唤一个根本就没有的角色。
引用类型的赋值：
引用类型之所以叫引用类型，就是因为引用。
不是所有的人都知道引用、指针，但是大多数人应该都知道钥匙。
无论是基本类型还是引用类型，赋值的过程都是“给东西”的过程。
基本类型的，就是直接给。
var a='小强真帅'
var b=a
上面就是说，你把‘小强真帅’的消息给了a， 然后a又把这个消息给了b。
所以赋值就是“给”。
而且这是一种“单纯复制、给完就跑”的一次性买卖。
b=a之后，
a虽然将‘小强真帅’这条真理给了b，
但是a自己依然还保存着自己的‘小强真帅’的认知。
这是单纯复制，有啥给啥，相对对象来说的。
b='小强不帅'
并不影响a='小强真帅'
即给完就跑，一次性买卖；
a与b的关系就像是菩提老祖和孙悟空，
从哪里来，回哪里去，讲的就是他们的关系：
虽然a曾经给过b东西，
但是日后b惹出什么祸来都与悟空无关。

对象的赋值，也是“给”。
但是不像基本类型那样，你看见它是什么、它给的就是什么。
基本类型，我var a=100
表示给了a 100元。
给了就到手里了。
引用类型，我var b={
    c: 200,
    d: '下雨要打伞'
}
表示给了b 一个有200元的c和知道‘下雨要打伞’的d吗，
而且给了就到手里了吗。
显然b是拿不了这么多东西的。
同时，这些b确实拥有这些东西，
怎么办到的？
首先是建了一个屋子，
然后再在这个屋子里创建了这些人物，
最后给b一把这个屋子的钥匙，
于是b就拥有了这个东西。
基本类型的赋值，
好比你有一部手机，然后买了相同一部手机交到女朋友手里。
引用类型的赋值，
好比你有一套房，然后你把这套房的钥匙复制了一把交到女朋友手里。
任何我们看到的对象的赋值，其实都是钥匙的传递，只是我们看不到。

function Person(){}
var tom = new Person()
Person.prototype.sayHi = function(){
    console.log('hihihihihihi')
}
tom.sayHi()     // 正常

function Person(){}
var tom = new Person()
Person.prototype = {
    sayHi: function(){
        console.log('ssshihihihihi')
    }
}
tom.sayHi()     // 报错

第一种正常的情况，tom的__proto__和Person.prototype的钥匙是去往相同房间的钥匙，
虽然一开始的时候给tom的__proto__放钥匙的时候，并没有sayHi方法，但是在tom执行sayHi的时候，
我们利用prototype的钥匙，及时进房间把这个放了进去，所以就完美执行了。

第二种明显是一种对prototype的赋值行为，而赋值对象又相当于是给钥匙。
也就是说，Person.ptototype换了另一把钥匙，开了另一个房间，做了一些__proto__不知道的事情，
因为他们已经是两个房间的人。

基本变量的赋值，就好比感冒的传播，你朋友把感冒传给你后，然后他吃药好了，你就会好吗？
赋值是一种分享，基本变量的分享方式是复制，引用变量的分享方式是共享。
引用变量的分享方式为什么是共享呢？因为他拥有的方式是引用。
就是说，基本变量拥有的方式就是普通的拥有，他分享的方式就是复制自己的东西。
而引用类型拥有的东西是钥匙，他分享的方式也是复制，但因为他复制的是钥匙，那这种分享方式就是共享。

new的作用：
（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
（2）属性和方法被加入到 this 引用的对象中。
（3）新创建的对象由 this 所引用，并且最后隐式的返回 this
翻译过来就是：
（1）开辟一个房间，并且给这个房间配一把钥匙，同时还把小区公园的钥匙放在里面。
（2）给这个房子提供必要装修和服务保障。
（3）将钥匙交给户主。
开辟一个房间，按他的方式装修，配钥匙。