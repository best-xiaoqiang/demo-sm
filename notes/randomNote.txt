1.什么是前端？
2.什么是闭包？
$闭包
百度百科：闭包就是能够读取其他函数内部变量的函数。
这个能够读取某函数内部变量的函数，必定就是某函数的内部函数，或者代理某函数内部函数的函数。

闭包：函数内部的函数可以访问函数内部的变量，将函数内部的函数赋值给函数外部的变量，然后调用这个变量；


闭包是为了代替对象的？
闭包的作用是保护函数内的变量安全？
函数内的变量本来就是安全的，因为函数外部不能访问函数内部本来就是函数的特性。
function a(){
 var i=0
 function b(){
  alert(++i)
 }
 return b
}
var c=a()
c()

实现私有的“全局变量”，闭包就是比对象更安全些，因为闭包用到了函数作用域。


「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。 // 那就是函数和其作用域的总和，是闭包？
但是，「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」
前者是闭包的定义。
后者更多是在解释“如何利用闭包”。

而且在“如何利用闭包”的问题上，主要利用的是闭包的特点。
即内部函数可以访问外部函数的变量。

作用域链相当于留联系方式？

当某个函数被调用时，会创建一个执行环境及相应的作用域链。

变量对象就相当于人事、管家，管自己公司有那些人的。
作用域链就是留下上级以及上上级的人事的联系方式，通过他们可以找到他们公司的人或东西。
（每雇佣一个团队的时候，人事就会留下自己的电话，说，有什么需要就联系我）
每个执行环境都有一个与之关联的“变量对象”，环境中定义的所有变量和函数都保存在这个对象中。作用域链保存相关的“变量对象”。

一个公司把事情干完了，人事就会被通知，把自己管理的这堆垃圾带走，我们这里就不留你们了。
但是作用域链是负责和相关的人事联系的，他得知在自己还没干活的情况下，有人事被通知“将你们这堆垃圾带走”的时候，他就会说不行、
如果你们把他们带走我们有可能干不了活（也可以是说，因为被雇佣的公司一般都会用到雇佣者的人力，所以只要有人还保留某个人事的联系方式，
说明还可能有用，人事就不会被通知走人）。
函数的变量对象一般在函数调用结束后被销毁，被垃圾回收。

闭包1：能够访问另一个函数作用域中变量的函数。（return的、window.xxx的）
闭包2：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
闭包3：函数和函数内部能访问到的变量的总和，就是一个闭包。（经理能通过人事联系到的所有人、资源）


见javascript高级程序设计p179

3.什么是继承？

5.什么是内存泄漏？
6.什么是this?
this就是“你”的意思。
函数执行的this指的是window，就好比“君”代指的皇帝一样。
构造函数的this指向是新创建的对象，就好像招人的人给被招的人开会，说你一样。
你的什么是什么，你碰到什么问题的时候怎么办。

this就是君，就是老大的意思。
只要不是xxx.xxx()的形式，那么一个函数的运行时的老大都是window。
而xxx.xxx()的形式，就是说现在xxx是老大，然后来运行什么。


2018/6/26
为什么要定义变量？
用着方便。
变量赋值：
变量的名字，就好比人的名字。
引用类型的赋值：
不是所有的人都知道引用、指针，但是大多数人应该都知道钥匙。
无论是基本类型还是引用类型，赋值的过程都是“给东西”的过程。
基本类型的，就是直接给。
var a='小强真帅'
var b=a
上面就是说，你把‘小强真帅’的消息给了a， 然后a又把这个消息给了b。
所以赋值就是“给”。
而且这是一种“单纯复制、给完就跑”的一次性买卖。
b=a之后，
a虽然将‘小强真帅’这条真理给了b，
但是a自己依然还保存着自己的‘小强真帅’的认知。
这是单纯复制，有啥给啥，相对对象来说的。

对象的赋值，也是“给”。
但是不像基本类型那样，你看见它是什么、它给的就是什么。
怎么办到的？
首先是建了一个屋子，
然后再在这个屋子里创建了这些人物，
最后给b一把这个屋子的钥匙，
于是b就拥有了这个东西。
基本类型的赋值，
好比你有一部手机，然后买了相同一部手机交到女朋友手里。
引用类型的赋值，
好比你有一套房，然后你把这套房的钥匙复制了一把交到女朋友手里。
任何我们看到的对象的赋值，其实都是钥匙的传递，只是我们看不到。

function Person(){}
var tom = new Person()
Person.prototype.sayHi = function(){
    console.log('hihihihihihi')
}
tom.sayHi()     // 正常

function Person(){}
var tom = new Person()
Person.prototype = {
    sayHi: function(){
        console.log('ssshihihihihi')
    }
}
tom.sayHi()     // 报错

第一种正常的情况，tom的__proto__和Person.prototype的钥匙是去往相同房间的钥匙，
虽然一开始的时候给tom的__proto__放钥匙的时候，并没有sayHi方法，但是在tom执行sayHi的时候，
我们利用prototype的钥匙，及时进房间把这个放了进去，所以就完美执行了。

第二种明显是一种对prototype的赋值行为，而赋值对象又相当于是给钥匙。
也就是说，Person.ptototype换了另一把钥匙，开了另一个房间，做了一些__proto__不知道的事情，
因为他们已经是两个房间的人。

基本变量的赋值，就好比感冒的传播，你朋友把感冒传给你后，然后他吃药好了，你就会好吗？
赋值是一种分享，基本变量的分享方式是复制，引用变量的分享方式是共享。
引用变量的分享方式为什么是共享呢？因为他拥有的方式是引用。
就是说，基本变量拥有的方式就是普通的拥有，他分享的方式就是复制自己的东西。
而引用类型拥有的东西是钥匙，他分享的方式也是复制，但因为他复制的是钥匙，那这种分享方式就是共享。
