解决乱码问题：
统一编码和解码字符集为utf-8
<meta charset="utf-8"/>

实体（转义字符）
&lt;    <
&gt;    >
&nbsp;  空格
&copy;  版权符号
&#字符编码
&#x16进制字符编码

列表
无序列表
<ul>
<li></li>
<li></li>
</ul>
有序列表
<ol>
<li></li>
<li></li>
</ol>
定义列表
<dl>
<dt></dt>
<dd></dd>
</dl>


jpg 颜色数量多
gif 支持颜色简单 简单透明 支持动态
png 颜色数量多 支持复杂透明
效果一样选小的，效果不一样选好的。

超链接
<a href="#bottom">去底部</a>
<a href="#" id="bottom">去顶部</a>
<a href="http://www.baidu.com" >在原标签打开</a>
<a href="http://www.baidu.com" target="_blank">在新标签打开
</a>

css
内部样式表
在head里写：
<style type="text/css">
p{
color:red;
font-size:50px;
}
</style>
外部样式表
<link rel="stylesheet" type="text/css" href="style.css"/>

块元素
独占一行
学习过的块元素：
div,h1,h2,p,ul,ol,dl...
内联元素（行内元素）
只会占自身大小
学习过的内联元素：
span,a,img

一般用块元素去包含内联元素，而不用内联元素去包含块元素。
a中可以放任何元素，除了a自己。
p元素中不能放任何块元素。

常用选择器
p{}
#id{}
.p2{}
h1,#p,.p2{}(并集选择器)
p.p2{}(交集选择器)
*{}（通配选择器)

div span{}
.p2 span{}
div>span{}

伪类选择器
：link
：visited
：hover
：active

样式的继承
并不是所有的样式都会被继承，比如背景相关的样式、边框相关的样式、宽度、高度。。。

当不同选择器发生冲突的时候，显示哪个样式由选择器的优先级（权重）来决定。
(-2.min.width)
(-1.max.width)
0.！important  (慎用)
1。内联样式 优先级1000
2.id选择器  100
3。类和伪类选择器  10
4.元素选择器  1
5.通配选择器  0
6.继承的样式  没有优先级
如果我们使用的是复合选择器，则需要将多个选择器的优先级进行相加然后再比较
如果选择器一样将优先显示靠下的。

利用max-width可以实现元素逐渐变宽的效果
当我们不知道元素的具体宽度，可以结合transition来实现动画延迟效果，如下：
div{
  max-width: 0;
  overflow: hidden;
  transition: max-width 0.25s;
}
div.active {
  max-width: 600px; 
}


盒模型
border边框的写法：
	三个都要有：color，width，style
		style有几种：double dashed dotted solid;
	由三个属性写四个边的顺序是：top right bottom left;
	去掉一个边的简单写法：border-right:none;

margin外边距的写法：
margin垂直方向等于auto时，默认值是0；
margin平行方向等于auto时，默认值是最大。

兄弟元素相邻垂直外边距会取最大值。
如果父子元素的垂直外边距相邻，子元素的外边距会传递给父元素。
水平方向的外边距不会重合，而是取和。


文档流:
是整个网页的最底层，在页面中所创建的元素默认情况下都是在文档流中的
			元素在文档流中的特点：
				块元素
					1.块元素在文档流中自上向下垂直排列
					2.块元素在文档流中默认宽度是父元素的全部
					3.块元素在文档流中的默认高度是被内容（子元素）撑开
				
				内联元素
					1.内联元素在文档流中自左向右水平排列，
						如果一行不足以容纳所有的内联元素，则会另起一行继续自左向右水平排列




浮动
float：left;
开启浮动后，元素会脱离文档流。
向页面的左上或右上移动，直到遇到父元素的边框或是其他的浮动元素后停止移动。
如果浮动的元素的上边是一个块元素，则浮动元素不会超过该块元素；如果块元素的上边是一个浮动元素，则该块元素会上升。
浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐。


浮动使元素完全脱离文档流。
块元素：
1.块元素脱离文档流以后，不再独占页面的一行		
2.块元素脱离文档流以后，默认宽度和高度都被内容撑开。
内联元素：
1.内联元素脱离文档流以后，会变成块元素。
高度坍塌
如果不为父元素指定高度，则父元素的高度默认是被子元素撑开，子元素多高父元素多高。当子元素脱离文档流后无法撑起父元素的高度，导致父元素的高度塌陷。
一般情况下我们通过overflow：hidden；来开启元素的bfc，从而解决高度坍塌。


层级：文档流<浮动<定位
两个元素发生重叠时，z-index值越大越优先显示，z-index值相同的优先显示下边的元素
。


相对定位：
position：relative；
left：100px;
top:100px;
相对定位不会使元素脱离文档流，块还是块，内联还是内联。
相对定位会使元素提升一个等级。
如果不设置偏移量元素不会发生任何变化.

绝对定位：
position：absolute；
left：0；
绝对定位会是元素完全脱离文档流；
绝对定位相对于离他最近的开启了定位的祖先元素进行定位，如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位；
所以：一般我们为一个子元素开启绝对定位，同时也会开启其父元素的相对定位。
提升元素的层级。
如果不设置偏移量元素的位置不会发生变化,但是性质会发生变化。
绝对定位会改变元素的性质，块元素的默认宽度和高度被内容撑开，内联元素变成块元素。
固定定位：
固定定位也是一种绝对定位，大部分和绝对定位相同。
不同的是固定定位的元素永远相对于浏览器窗口进行定位（小广告）。
position：fixed；
left：0；
top：0；



透明效果
opacity:0.3;
从0到1.
这个样式ie8及以下版本都不支持。

所以ie8用filter来设置，
filter：alpha（opacity=30）；
从0到100.


导航条：
去处项目符号：
list-style：none；

a{
/*使包含文字的整块成为超链接*/
display:block;
color:white;
/*去除超链接文字的下划线*/
text-decoration:none;
/*文字居中*/
text-align:center;
padding:5px 0;
}


bfc
- BFC是元素的隐含属性，当开启元素的BFC以后，元素将会具有如下一些特性
1.开启BFC以后，子元素的垂直外边距不会传递给父元素
2.开启BFC以后，元素不会被浮动元素所覆盖
3.开启BFC以后，父元素可以包含浮动的子元素 *****
			
- 开启BFC的方式：
1.设置元素浮动
2.设置元素绝对/固定定位
3.设置元素的display为inline-block/flex
4.设置元素的overflow为hidden    √




表格
<table>
 <thead>
  <tr>
   <th>姓名</th>
   <th>电话</th>
  </tr>
 </thead>
 <tfoot>
 。。。。
 </foot>
 <tbody>
   <tr>
    <th>冯巩</th>
    <th>123</th>
   </tr>
   <tr>
    <th>牛群</th>
    <th>456</th>
   </tr>
</tbody>
</table>

纵向合并单元格<td rowspan="2">b4</td>
横向合并单元格<td colspan="2">d3</td>

设置表格中边框间的距离：
border-spacing:100px;

表格中边框的合并：
border-collapse：collapse；






表单

<form action="target.html"></form>
action需要指向一个服务器地址，表单将会提交到这个地址上。

用户名<input type="text" name="username" placeholder="请输入用户名" />
密码<input type="passwoed" name="password" placeholder="请输入密码"/>

单选
性别
<input type="radio" name="gender" value="male" />男 
<input type="radio" name="gender" value="female" />女

多选
爱好
<input type="checkbox" name="hobby" value="zq" />足球
<input type="checkbox" name="hobby" value="lq" />篮球
<input type="checkbox" name="hobby" value="ppq" />乒乓球

下拉菜单
你喜欢的明星
<select name="star">
 <optgroup label="女明星">
  <option value="fbb">范冰冰</option>
  <option value="zw">赵薇</option>
 </optgroup>
 <optgroup label="男明星">
  <option value="pcj">潘长江</option>
  <option value="fg">冯巩</option>
 </optgroup>
</select>n

注册按钮<input type="submit" value="注册" />
重置按钮<input type="reset" value="重置" />
普通按钮<input type="button" value="普通按钮">

button
<button type="submit">提交</button>
<button type="reset">重置</button>
<button type="button">普通按钮</button>


写在head里面 :
<script type="text/javascript"></script>
引用js文件   :
<script type="text/javascript" src="xxx.js"></script>


在浏览器窗口中显示一个内容
document.write("今天天气好晴朗")；

写在body中的形式：
<button onclick="alert('讨厌，点我干嘛')；">点我一下</button>
<a href="javascript：alert('让你点你就点')；">你也点我一下</a>



js语法：
区分大小写；
忽略多个换行和空格，因此可以对代码进行格式化；
语句以；结尾。


标识符
所有自己命名的内容都是可以认为是一个标识符，比如变量名、函数名、属性。
标识符的规范：
1.标志名可以含有字母、数字、_ 、$，但不能以数字开头。
2.标识符不能是js中的关键字和保留字。
3.js中的标识符采用驼峰命名法，首字母小写，每个单词的开头字母大写。
比如，helloWorld
      xxxYyyZzz
js中的标识符底层实际上是以Unicode编码保存的，所以“理论上”Unicode编码中的内容都可以作为标识符用。

JS中一共有6种数据类型：

基本数据类型5种：
String字符串
Number数值
Boolean布尔值
Null空值
Undefined未定义
引用数据类型1种：
Object对象


字符串String中的转义字符：
\"  -->  "
\'  -->  '
\\  -->  \
\n  -->  换行
\t  -->  制表符
\uxxxx  -->  Unicode编码

数值
表示数字的最大值：
a=Number.MAX_VALUE;
表示数字的最小值：
a=Number.MIN_VALUE;
无穷：
a=Infinity;
非法数字：
a=NaN;

注意!Infinity和NaN的类型都是Number
注意！使用typeof检查Null类型的值时会返回object
十进制的10：
a=10;
八进制的10：
a=010;
十六进制的10：
a=0x10;
二进制的10：
a=0b10;

在JS中，涉及到钱的运算都不要做。




类型的转换
类型转换

转换为字符串String

方法1：
var a=true;
a=a.toString(16);
()中可以接受一个整数作为转换指定的进制。
这种方法不适用于Null和Undefined。

方法2:
var a=null;
a=String（a）;


转换为数值Number

方法1：
调用Number()函数
var a="100";
a=Number(a);
对于字符串
  如果字符串是一个合法数字，直接转换；
  如果字符串不是一个合法数字，转换为NaN;
  如果是空串或纯空格的字符串，转换成0；
对于布尔值
  true转换为1
  false转换为0
对于Null
  null转换为0
对于Undefined
  undefined转换为NaN

方法2：
parseInt()和parseFloat()
var a="100px";
a=parseInt(a);
结果是100（自左向右解析字符串，碰到非法字符自动结束）
var a="100.123";
a=parseFloat(a);
结果是100.123


转换为布尔值Boolean

使用Boolean()函数
对于数字
  除了0和NaN,其余都是true
对于字符串
  除了空串，其余都是true（包括纯空格字符串）
对于null和undefined
  都是false
对于对象
  默认情况下都转换为true




算数运算符
+ - * / %(取模运算，取余数)

我们可以为一个任意的数据类型
-0 *1 /1来将其转换为数字，
他的原理和Number()函数一样,所以规则要参照Number()函数的规则。
比如a="123";a=+a;的结果是123
    a="123px";a=+a;的结果是NaN

c=100+NaN;
任何值和NaN做运算结果都是NaN

字符串的加法
c=c+"";
任何值和字符串做加法，都会将其先转换为字符串，然后再进行拼串操作。
注意！c="100"+NaN;
      的结果是100NaN


逻辑运算符
逻辑非
可以通过对一个值取两次反，来将其转换为Boolean
a=!!a;
逻辑与&&
逻辑或||
与是短路的与，或是短路的或
从左到右，读到“关键”的时候，就不读了！
非布尔值的逻辑运算：
输出的量是它所读到的“位置”



字符的比较
当关系运算符的两端都是字符串时，解析器不会将其转化成Number再比较，而是比较的字符串的Unicode编码。比较Unicode编码时是逐位比较，第一位和第一位比，第二位和第二位比。。。
可以用来对英语按照字母顺序排序。

由于undefined衍生自null，所以这两个值做相等比较时，会返回true。相等但是不全等。

NaN不与任何值相等，包括他自己。
检验一个值是否是NaN：isNaN()函数。

三元运算符（三目运算符）：
max=a>b?a:b;

弹出输入框
var a=prompt("请输入小名的成绩");

条件分支语句
switch（num）{
case 1:
 yuju;
 break;
case 2:
 yuju;
 break;
default:
 yuju;
 break;
}


while循环
while(  ){   
}

do{
}while(  )
do...while可以确保循环体至少执行一次。

条件表达式恒为true的循环，是死循环，慎用！

break和continue
break
break可以用来立即结束switch语句或是循环语句；
break会立即跳出离他最近的循环；
如果想跳出更靠外的循环，在想跳出的循环上添加一个label也就是名字，例如，"tom:"就行。
continue
用来跳过当次循环。



计时器
console.time("计时器的名字")；
被计时的内容。
console.timeEnd("计时器的名字");


求一个数的平方根
Math.sqrt();

Object对象

Object是引用数据类型（其余三种为基本数据类型）。
基本数据类型的值与只之间互相独立，互不影响。引用数据类型中，如果两个变量保存的引用相同，则此时两个变量指向的是同一个对象，这时修改一个变量，有可能会影响到另一个。
基本数据类型比较时，比较的是数值的值，只要值一样就会返回true。引用数据类型在比较时，比较的是对象的引用即内存地址，如果对象的内容一致，但是地址不同，也会返回false。
对象是一种复合型数据类型，相当于一个容器。

对象的分类:
 内建对象：由ES标准定义的对象，这些对象在任何ES标准实现中都可以使用，比如String Number Object...
 宿主对象：由JS运行环境所提供的对象，目前我们主要指的是由浏览器提供的对象，比如BOM和DOM.
 自定义对象：由我们开发人员自己创建的对象。


创建对象
  var obj=new Object();
  var obj={};


垃圾：
没有变量或属性对其引用的对象。
清理方式：将不再使用的对象设置null。




删除属性
   delete obj.age;

  
obj.age=18;
    等同于
        obj["age"]=18;


in运算符
    检查一个对象中是否含有某个属性，是就返回true
    console.log("age" in obj);


列举对象中的属性
   for...in语句
   语法:
   for(var n in obj){
     console.log(n+"="+obj[n]);
   };


function函数

（函数也是一个对象，普通对象能做的函数也能做。
但是用typeof检查一个函数对象会返回function。）

var fun=new Function("alert('我是函数中封装的js代码')；")；


var fun=function(){
 console.log("我是fun中的代码");
};

function fun(){
 console.log("我还是fun中的代码");
}



形参
声明函数（）里面的变量就是形参
调用函数时，可以传递任意数量的实参，
实参个数大于形参，多余实参不会使用；
实参个数小于形参，多余形参会是undefined。



返回值reture
函数里面加上“return(空格)+要返回的值或变量”
如果不加，则会返回undefined。
函数的返回值可以是任意的数据类型。
函数中，return一旦执行，函数立刻结束！
continue是跳过当次的循环。
break是跳出当前的循环。



立即执行函数
函数定义了会立即执行，并且只会执行一次。
(function（）{alert"hello";}))();


方法method
当一个对象的属性是一个函数时，我们就称这个函数是这个对象的方法，调用函数就称为是调用了一个对象的方法。
函数和方法只是称呼上的不同，没有本质的区别。


作用域（scope）

在js中一共有两种作用域：
1，全局作用域；
所有直接写在script标签中的内容都在全局作用域中；
全局作用域在页面加载时创建，在页面关闭时销毁；
全局作用域中有一个全局对象window，在全局作用域中创建的变量都会作为window的属性保存；在全局作用域中创建的函数都会作为window的方法保存。
全局作用域中创建的全局变量可以在页面任何位置访问。
2，函数作用域。
每调用一次函数就会创建一个新的函数作用域；
在全局作用域中无法访问函数作用域；
在函数作用域中如果不使用var关键字，则变量会变成全局变量；
当我们在函数中使用一个变量的时候，他会先在自身的作用域中被找到；
如果没有就会去上一级作用域中寻找，知道找到全局作用域为止。如果还没有，就会报错。
变量函数的提升，在函数作用域中同样适用。



变量的提升

在js中所有使用var关键字声明的变量，都会在所有代码执行之前被“声明”但是不会赋值，但是赋值会等到赋值语句执行时才进行。如果不使用var就不会具有声明提前的特性。

函数的提升

使用函数声明创建的函数会在所有的代码执行之前被“创建”，无论他写在程序的哪个位置。
例如，function fun(){}
使用函数表达式创建的函数，不会被声明提前。
例如，var fun=function(){};


关于this的一则小笑话：
小红对老公抱怨：
“你看人家小丽的老公，每天见面都亲她一口。你能不能像小丽的老公学习一下？”
小红的老公说：
“不行啊，我亲小丽的话她老公肯定会打我的”
这里，“每天见面都亲她一口”中的“她”就相当于是this。
this就是为了让你接受这个故事的时候，能够将故事中的这个角色代替成你自己的角色。
this的存在，又比如说明书中的“你”，谁在看说明书，这个“你”代指的就是谁。

1.this
	- this是函数的上下文对象，函数在调用时，由浏览器传递进来
	- 根据函数调用的方式，this的值也不同
		1.以函数形式的调用，this是window
		2.以方法的形式调用，this是调用方法的对象
		3.以构造函数的形式调用，this是新建的那个对象（将this指向这个对象）
		
2.构造函数（constructor）
	- 构造函数就是专门用来创建对象的函数，构造函数其实就是一个普通的函数
	- 如果使用new关键字调用，则它就是一个构造函数，否则就是一个普通函数
	- 构造函数的执行流程：
		1.创建一个新的对象
    2.将对象的__proto__指向函数的prototype
		3.将这个新的对象设置为函数的this，按顺序执行函数中的代码
		4.将新建的对象返回
	- 构造函数一般都是首字母大写，一个构造函数也称为一个类，
		通过一个构造函数创建的对象，我们称这个对象是这个类的实例
		由同一个构造函数创建的对象，我们称为一类对象。
	- instanceof运算符
		- 用来检查一个对象是否是一个类的实例
		- 语法：对象 instanceof 构造函数
		
3.原型（prototype）
	- 在每一个函数中都有一个属性prototype，该属性指向的是一个对象，
		这个对象就是所谓的原型对象。
	- 如果函数作为普通的函数调用，则该对象没有任何作用。
	- 如果函数作为构造函数调用时，那么通过该构造函数所创建的对象中将会有一个隐含的属性（__proto__）,
		该属性将会指向构造函数的prototype对应的对象。而且所有的由该构造函数创建的对象，都会有这么一个属性，并且都会指向原型对象。
		
	- 原型对象就相当于一个公共的区域，所有的同类对象都可以访问到该区域，我们可以将对象中共有的属性和方法统一保存到原型对象中，
		这样我们只需要添加一次属性或方法，所有对象都可以使用。
		
	- 当读取一个对象的属性或方法时，它会先在自身中寻找，如果找到了则直接使用，
		如果没有找到，则去对象的原型中寻找，找到了则使用
		如果没有找到，则去原型的原型中寻找，依次类推
		直到找到Object的原型（Object.prototype）,Object的原型没有原型（原型是null）
			如果依然没有找到，则返回undefined
			
	- 向原型中添加属性：
		语法：
			构造函数.prototype.属性名 = 属性值；
			
	- hasOwnProperty()
		- 检查对象自身中是否含有指定属性
		- 语法：对象.hasOwnProperty("属性名");
		
	- toString()
		- 当直接打印一个对象时，默认情况下是打印的对象的toString()方法的返回值
			如果不希望打印[object Object], 可以修改对象的toString();
		



数组

创建数组：
var arr=new Array();
var arr=[];


在数组的最后一位添加元素：
arr[arr.length]=66;


arr.push();       
在末尾添加一或多个元素，返回新的长度。
arr.pop();
删除并返回最后一个元素。
arr.unshift();
在数据开头添加一或多个元素，返回新的长度。
arr.shift();
删除并返回第一个元素。


slice()和splice()

slice()
不会影响原数组。
var result=arr.slice(1,3);
//截取arr[1]、arr[2]。
截取时，包括起始位置，不包括结束位置。
返回截取的结果。

splice()
会影响原数组。
arr.splice(1,2，“牛魔王”)；
前者是开始删除的位置，后者是删除的个数，再后面是插入的值。（可以被用来在指定位置插队）
返回被删除的元素。

forEach()

concat()
连接数组
不会影响原数组。
var result=arr.concat(arr2,[1,2,3]);

join()

sort()
另一个回调函数。
排序
会影响原数组值。
默认情况下，都是按照Unicode编码进行排序。
数字排序：
arr.sort(
function(a,b){
return a-b;
//升序排列
}
)；
原理：这个回调函数sort中，在输入a,b后，假如return的结果为正数的话，则a,b互换位置。



arguments
function sum(){
  var result=0;
  for(var i=0;i<arguments.length;i++){
    result+=arguments[i];
  }
  return result;
}
这样，
利用arguments
在sum中可以输入任意个数的参数。


call()和apply()


this到底是谁？
1，以函数形式调用，this是window
2，以方法形式调用，this是调用方法的对象
3，以构建函数调用，this是新建的对象
4，使用call和apply调用，this是call和apply第一个参数

fun();                  //window
fun.call(obj);          //obj


fun.call(obj,123,456);
fun.apply(obj,[123,456]);
//apply需要将实参封装到一个数组中传递。



Date

//当前时间：
var d=new Date();

//自定义时间：
var d=new Date(“7/18/1994 13:45:33”);
(//加引号！)


d.getDate();     //几号
d.getDay();      //星期几
d.getMonth();
d.getFullYear(); //年份


时间戳
getTime()

//获得目标对象对应的时间戳
var t1=d1.getTime();

//获得当前日期的时间戳
var t2=Date.now();
Date.now() === new Date().getTime() // true

测试执行时间
var begin=Date.now();
alert("hello");
var end=Date.now();
console.log(end-begin);



Math


Math不是一个构造函数，不能直接创建对象。
像Math这种对象我们也称他是一个工具类。

常量：PI

绝对值：
var a=Math.abs(-10);

向上取整：
var a=Math.ceil(1.1);

向下取整：
var a=Math.floor(1.9);

四舍五入取整：
var a=Math.round(1.5);

生成0-1随机数：
（不会出现0和1）
var a=Math.random();

生成0-5随机数：
var a=Math.round(Math.random()*5);

生成4-7随机数：
var a=Math.round(Math.random()*3+4);

获取最大值：
var a=Math.max(2,40,30,20,20);

最小值：
var a=Math.min(20,10,60,40,50);

几次幂：
var a=Math.pow(2,5);

开平方：
var a=Math.sqrt(PI);





包装类

通过包装类可以将基本数据类型转换为对象。
三个包装类：String Number Boolean
注意：在开发过程中绝对不要使用包装类来创建对象。

当我们对一个基本数据类型String Number Boolean调用方法或属性时，浏览器会临时将基本数据类型包装成对象（装箱），
转换为对象再去调用这个对象的方法，
调用完毕，浏览器会将对象转换为基本数据类型（拆箱）。



=
字符串

字符串在JS的底层实际上是以字符数组的形式保存的。

字符串的所有方法都不会影响原字符串。
所以要想得到使用方法后的结果必须要赋值。

str.length

var a=str.charAt(6);
//相当于str[6]

根据索引获得字符串中指定位置的字符的字符编码：
var a=str.charCodeAt(6);

将字符编码转换成字符：
var a=String.fromCharCode(0x4dc0);

连接字符串：
str=str1.concat(str2);
//相当于str=str1+str2;

indexOf()
lastIndexOf()
检查一个字符串是否含有指定内容。
如果字符串含有指定内容，则会返回内容第一次出现的索引。
如果字符串中没有指定内容，则会返回-1.
indexOf()是从前往后找；lastIndexOf()是从后往前找。
var a=str.indexOf("1",4);
参数：“1”：要查找的内容；(不支持正则表达式，search支持但是只能返回第一个)
        4  ：指定开始查找的位置

slice（）
截取字符串中的指定内容
截取开始的位置（包含），截取结束的位置（不包含）。
第二个如果不写就会一直截到最后。
参数如果是负值，则从后往前计算。

substring()
同slice。
不同：substring（）不支持负数作为参数，如果写负数相当于写0。
该方法会自动调整参数的位置，如果第一个参数大于第二个参数则会自动交换位置。

substr()
也是截取字符串中的指定内容。
参数：
1，截取开始位置的索引（包含开始位置）；
2，截取的数量。

split
将字符串拆分成一个数组:
str="a@b@c@d@e@f";
result=str.split("@");
可以接受一个正则表达式作为参数，而且默认会全局去拆字符串。

str=str.toUpperCase();
str=str.toLowerCase();



正则表达式

var reg=new RegExp("a");

console.log（reg.test("a")）;

不区分大小写：
var reg=new RegExp("a","i");

字面量：
var reg=/a/i;

 |     表示或；
[]     []中的内容都是表示或的关系；
[a-z]  任意的小写字母；
[A-Z]  任意的大写字母；
[A-z]  任意字母，不分大小写；
[0-9]  任意数字；
[^ ]   表示除了[]中的内容，其余都可以。

量词：
{m}     正好出现m次；
{m,n}   m-n次；
{m,}    至少出现m次；
+       至少出现一次，相当于{1,};
*       任意次，相当于{0，}；
?       0-1次，相当于{0，1}。


^表示以。。。开头
$表示以。。。结尾
var reg=/^a/;
var reg=/a$/;

要求字符串必须和正则表达式完全匹配：
var reg=/^a$/;



字符串和正则表达式的相关方法：

split()
将一个字符串拆分成一个字符串的数组@@@。

search()
//请去对比indexOf()
用来搜索字符串中是否含有指定内容。
如果找到指定内容，则返回该内容第一次出现的索引,
如果没有找到就返回-1
在search中可以传入正则表达式
search（）不能使用全局通配。
就是只返回该内容第一次出现的索引。

match()
将符合正则表达式的内容提取出来。
该方法会将符合条件的条件的内容封装到一个数组中返回，
即使符合条件的元素只有一个，也会返回数组。
g全局匹配模式
i忽略大小写
var reg=/a[bde]c/ig;
var result=str.match(reg);

replace()
将指定内容替换成新的内容。
str=str.replace(reg,"新的内容")；
str=str.replace(reg,"");//删除指定内容。

用到的转义字符：
\w 任意字母、数字、_ 相当于[A-z0-9_]
\W 除了字母、数字、_ 相当于[^A-z0-9_]
\d 任意数字
\D 非数字
\s 空格
\S 非空格
\b 单词边界
\B 非单词边界


在众多单词中，找到child：
var reg=/\bchild\b/;
console.log(reg.test(str));


去除两边的空格：
var um="   ad   min     ";
var reg=/^\s*|\s$/g;
console.log(um.replace(reg,""));
结果：ad   min





DOM

文档对象模型。

DOM是一个独立于任何语言和平台的接口，允许任何语言或脚本动态地访问和更新HTML文档的内容、结构和样式。该HTML页面可以进一步处理，并且该处理结果可以被合并到所呈现的HTML页面中。

DOM共四代。现在使用的是DOM3.

在DOM树结构中，属性节点比较特殊，它并不是所在元素节点的子节点。


script写在哪里？
当我们在script中运行按钮点击时，按钮点击事件并没有绑定成功。因为HTML页面的加载是自上向下的顺序，所以在执行JavaScript代码时，浏览器并没有加载<body>标签中的内容。所以，最终的结果就是报错。
解决方法：
window.onload=function(){
	//JavaScript代码
}
window对象是浏览器窗口，onload事件表示加载。
所以，window.onload就表示浏览器窗口加载完毕时发生。
window.onload=function(){
	var btn=document.getElementById("btn");
	btn.onclick=function(){
	   console.log("你点中了我");
	}
}


案例：点击按钮改变另一侧文字的状态！
var btn1=document.getElementById("bnt1");
btn1.onclick=function(){
	var one=document.getElementById("one");
	one.style.backgroundColor="lightskyblue";
}


getElementById()
getElementsByName()
getElementsByTagName()  //通过标签名选择指定标签。
getElementsByClassName()
通过CSS选择器方式选择：
querySelector(selector)      //返回第一个选择器匹配的HTML页面元素；
querySelectorAll(selector)   //返回全部选择器匹配的HTML页面元素。
//后面三个方法在兼容性方面有问题。
//前四个在速度上要比后两个快

通过 getElementsByName()、getElementsByTagName() 和 getElementsByClassName() 方法获取的 NodeList 就是动态的 NodeList。

创建节点
document.createElement('li');


属性节点
// 1. 获取 <div> 标签
var node = document.getElementById("div");
// 2. 创建属性节点
var a = document.createAttribute("my_attrib");
// 3. 设置属性节点的 nodeValue
a.nodeValue = "属性值";
// 4. 将属性节点添加到 <div> 标签中
node.setAttributeNode(a);

（element.setAttribute(attributename,attributevalue)）

文本节点
document.createTextNode(文本内容);


parentNode和parentElement的区别：
parentNode:
获取指定节点的父节点，父节点可以是元素节点，也可以是文档节点。
parentElement:
获取指定节点的父元素，父元素只能是元素节点（标签）。

问题：
除了ie8以外的其他浏览器，加载HTML页面时会自动添加空白节点。
解决：
通过getElementsByTagName()方法来解决。


childNodes   所有子节点的集合（数组）；
firstChild   第一个子节点
lastChild    最后一个子节点
getElementsByTagName()[length-1]    获取最后一个子节点；
previousSibling   上一个兄弟节点
nextSibling       下一个兄弟节点


插入节点
parent.appendChild(child);
会被插入到指定父节点的最后面。

parent.insertBefore(newChild,currentChild)

删除节点
parent.removeChild(two);

替换节点
parentNode.replaceChild(newChild,oldChild);

复制节点
node.cloneNode(boolean);


获取子元素
firstElementChild  获取指定标签的第一个子元素
lastElementChild   获取指定标签的最后一个子元素
children     获取指定标签所有的子元素


兄弟元素
previousElementSibling
nextElementSibling


设置属性
element.setAttribute(属性名，属性值)；

删除属性
element.removeAttribute（属性名）；

判断是否含有属性
element.hasAttribute(属性名)；

获取文本内容
textNode.nodeValue

innerText
不能获取被CSS样式隐藏的文本内容
firefox不支持

textContent
可以获取全部文本内容
ie8及以前的版本不会支持

innerHTML
存在安全隐患，不应该用它添加来自于用户输入的内容。

设置内联样式
element.style.attrName=attrValue

获取当前的样式
window.getComputedStyle(element,null)

获取当前样式的兼容方案
function getStyle(elem,attrName){
 if(window.getComputedStyle){
  return getComputedStyle(elem,null);
 }else{
  return elem.currentStyle[attrName];
 }
}


获取可见高度和宽度
clientWidth
clientHeight

获取实际高度和宽度
offsetWidth
offsetHeight



获取定位父元素
element.offsetParent:
var btn3=document.getelementbyid('btn3');
btn3.onclick=function(){
  var div3=document.getelementbyid('div3');
  var show3=document.getelementbyid('show3');
  show3.innerHTML='div 标签的定位元素是：'+div3.offsetParent;
}
上述代码运行的结果是：
当前div标签开启了position属性的定位父元素。



获取滚动的相关属性：
scrollWidth    获取指定标签滚动区的宽度。
scrollHeight   获取指定标签滚动区的高度。
scrollLeft     获取水平滚动条滚动的距离。
scrollTop      获取垂直滚动条滚动的距离。



DOM事件

Event对象
事件：用户和页面之间实现交互的一瞬间。

绑定事件
1，事件属性。缺点：结构和行为耦合。
2，Javascript方式。缺点：只能为同一个标签绑定同一个事件一次。
3，事件监听器。
element.addeventlistener(event,callback,boolean);



事件监听器
兼容方案：
function bind(elem,event,callback){
 if(elem.addEventListener){
  elem.addEventListener(event,callback,false);
 }else{
  elem.attachEvent('on'+event,function(){
   callback.call(elem);
  });
 }
}




event.target属性
用于获取绑定当前事件的目标元素。
event不需要我们自己创建，直接使用就行。

event的兼容方案：
event=event||window.event;

target的兼容方案：
var target=event.target||event.srcElement;


注意：this 和 event.target 的区别。
通过this关键字来指定绑定该事件的标签。
this指触发事件的元素，无论你鼠标点击在什么位置，触发事件的元素都是ul，所以this指ul，但是e.target指鼠标的焦点元素，如果你点击到了ul内部的li，则e.target指的就是li，但是如果你点击的是ul其他的非li部分，则this和e.target是一样的。
如果不是通过冒泡产生的事件，则this和e.target没有区别




阻止默认行为
event.preventDefault()方法
兼容方案：
if(event.preventDefault){
 event.preventdefault();
}else{
 event.returnValue=false;
}




获取鼠标坐标

pageX和pageY
鼠标在整个页面中的位置。如果页面过大，部分页面可能在可视范围之外。

clientX和clientY
鼠标在可视区域中的位置。

screenX和screenY
鼠标在整个屏幕中的位置。

offsetX和offsetY
鼠标相对于定位父元素的位置


事件周期
捕获阶段，触发阶段，冒泡阶段

阻止事件冒泡的兼容方案：
if(event.stopPropagation){
 event.stopPropagation();
}else{
 event.cancelBubble=true;
}



事件委托
我们会发现，新添加的<a>标签并没有onclick事件。如果我们想为新添加的<a>标签同样绑定事件onclick，需要在添加之前完成事件绑定。
除此之外，我们还可以将事件绑定到所有的<a>标签共有的祖先元素上，即事件的委托。
ul.onclick=function(event){
 if(event.target.nodeName==='A'){
  alert('我是一个超链接');
 }
}




BOM
browser object model
浏览器对象模型

BOM是javasc中唯一一个没有标准的。

DOM树结构中的入口 Document 对象也是属于BOM内容的一部分。
Window对象是BOM结构中的最顶层的对象，其他对象都是以Window对象的属性形式出现。

访问全局变量v和全局函数sayMe（），可以通过window对象进行访问。



滚动窗口操作
scrollBy()
根据指定像素值来滚动浏览器窗口。
scrollTo()
将浏览器窗口滚动到指定坐标值。

Navigator对象
表示当前浏览器，该对象包含了浏览器的信息。
值得注意的是：Navigator对象没有相应的标准，不过各个浏览器都支持。

Navigator对象的userAgent属性，
可以实现识别浏览器的功能。

history.length
可以获取浏览器中访问的网站的数量。

前进和后退
forward()  下一个页面
back()     跳到上一个页面
go()  	   跳转到指定页面。负数表示后退。

reload()
刷新页面



复习：
整型（整数）中是否含有0？ 包含。

javascrip中无论什么进制，计算之后得到的结果都是十进制。

报错的undefined与提示的undefined的区别？
报错的：变量根本不存在。
提示的：变量存在，但没值。

变量什么情况下值是undefined？
只定义但不赋值；
变量的声明提前；
直接赋值为undefined。

undefined类型仅仅只有一个值，就是undefined。

浅复制：内存地址的复制，而不是数据的地址。
深复制：数据的复制，而不是内存地址的复制。



JSON

JSON是一种轻量级的数据交换格式。

一种结构在javascript中被称为对象。
另一个结构在javascript中被叫做数组。

在JSON文件中，要求所有的字符串必须使用双引号，而不能是单引号。

JSON对象转换成JSON字符串
json字符串=JSON.stringify(JSON对象)

JSON字符串转换成JSON对象
json对象=JSON.parse(JSON字符串)


构造函数的作用，就是创建一个对象的模板。

 * 原型
   * 定义 - 原型是构造函数的一个特殊属性
   * 作用
     * 对当前对象添加属性或方法
     * 为内置对象(Array)添加属性或方法 - 不推荐
     * 原型属性与构造函数本身的属性同名
       * 构造函数本身的优先级别更高
       * 通过原型定义属性的默认值
   * 关于底层内容
     * Object 是所有 JavaScript 对象的父级
     * Function 是所有 JavaScript (构造)函数的父级
 * 继承(ECMA 5.1)
   * 概念 - (子承父业)
   * 应用 - 继承是原型的最后一个应用场景
   * 实际开发
     * 作为 A - 项目经理 - 通用的对象属性和方法
     * 作为 B - 组长 - 每组模块的通用的对象属性和方法
     * 作为 C - 我们 - 每个功能的对象属性和方法



包含块

元素相对定位或者相对大小计算的参照。

正常文档流元素：
包含块是父元素的content-box。

绝对定位的元素：
初始包含块，或者距离最近的开启了定位的祖先元素的padding-box.

固定定位的元素：
视口（viewport）,布局视口。

position:absolute;的包含块是
1.初始包含块；
2.距离其最近的开启了定位的祖先元素。

父外边距
document.documentElement.clientWidth   视口宽度

window.onresize  监控视口改变

padding
相当于把页面拉长。

margin（负的）
相当于裁剪页面。

等高就是先用padding将大家一起拉长，
然后用margin裁剪。



字体

默认字体大小：16px。

间隙
解决inline-block元素由于换行导致的间隙：
<img src='img/1.jpg'><!--
--><img src='img/2.jpg'>
终极必杀：给父元素 设置font-size：0 ；letter-spacing：-3px ，子元素重新设置font-size
ul{
  list-style: none;
  font-size: 0;
  letter-spacing: -3px;
}

斜体
font-style:italic;
font-style:oblique;
italic和oblique都是向右倾斜的文字，
区别：
italic是指斜体字，oblique是倾斜的文字。
对于没有斜体的字体，应该使用的是
oblique。

衬线字体：
serif 浏览器自主选择使用哪个衬线字体
font-family:"华文中宋"，"华文仿宋"，serif;

非衬线字体：
sans-serif 自主选择使用哪个非衬线字体
font-family:Microsoft YaHei,tahoma,sans-serif;

让小写的字母
个头小，但是大写：
font-variant:small-caps;

简写

是有固定顺序的：
{粗细，斜体，小型大写字母} 字体大小 字体族
font:bold italic small-caps 72px "华文仿宋"；

简写的后遗症
font:bold 36px '微软雅黑'；
以上写法会改变行高line-height
因为有默认的数据，以上代码实质上是：
font:bold 36px/1.2 '微软雅黑'；
解决方法：
自己把行高写上，
font:bold 36px/300px '微软雅黑';

大小写转换
text-transform:uppercase;
text-transform:lowercase;
单词首字母大写：
text-transform:capitalize;

行高
默认值是1.2
（基于元素的字的大小计算）
line-height:1.2;


垂直居中
vertical-align:middle;
让行内块元素，沿着一行中文本小写字母的1/2处对齐
！！必须设置在行内块元素（img input）
设置vertical-align:middle;之前要在父元素中将line-heignt设置为块元素的高度。

首行缩进
text-indent:2em;

书写方向
左到右：
direction:ltr;
右到左：
direction:rtl;

字符间距
letter-spacing:20px;

空格之间的间距
word-spacing:2em;

display:table-cell;
仅适用于局部布局。

两种居中方式的比较：
1.在inline-block中设置vertical-align:middle;
  在行中小写字母的1/2居中。
  在要居中显示的元素中设置vertical-align:middle;之前要在父元素中将line-heignt设置为块元素的高度。
2.直接对容纳要居中的元素的父元素设置
display:table-cell;
  让table-cell的内容在垂直方向水平居中。
  在父元素中设置display:table-cell;中后，还要设置vertical-align:middle;,这次是设置在父元素中，就能实现图片的垂直居中。如果想要
让父元素里的文字居中，就也要在这个子元素中写入vertical-align:middle.


背景图

背景图的固定定位：
background-attachment:fixed;

简写：
background: [background-color] 
  [background-image] 
  [background-repeat] 
  [background-attachment] 
  [background-position] / [ background-size] 
  [background-origin] 
  [background-clip];
background: red 
  url(img.png) 
  no-repeat 
  fixed 
  center center / 50%
  content-box
  content-box;



background图片和img引入的图片
的区别：
  性能
  background引入的图片是异步加载，性能高；
  img同步加载图片，性能不好。
  使用场景
  background用于不重要的图片内容，例如显示用的图标；
  img因为拥有alt属性，用于重要的网站内容，例如商品图片，网站的LOGO。


目标状态伪类
（当元素通过锚链接点击时）
#page1:target{
 background-color:red;
 font-size:72px;
 color:red;
}

<a href='#page1'>page1</a>
<div id='page1'>1</div>

结构化伪类选择器
选中第一个li
ul li:first-child{
 background-color:red;
}
选中最后一个li
ul li:last-child{
 background-color:red;
}
选中偶数位置的li
ul li:nth-child(even){
 background-color:red;
}
选中奇数位置的li
ul li:nth-child(odd){
 background-color:red;
}
选中5的倍数的li
ul li:nth-child(5n){
 background-color:red;
}
另一种根据元素类型进行排序的方法：
ul li:nth-of-type(even){
 background-color:red;
}
ul li:nth-of-type(5n){
 background-color:red;
}


伪元素

伪元素 与 元素的区别：
1.无法通过JS获取其DOM
2.无法通过浏览器选中其文本内容

伪元素特点：
1.默认是display:inline
2.必须包含content属性，其值是字符串，通过空格连接两个字符串。
3.规范要求伪元素使用::，为了支持IE8使用；

首个字母：
.box::first-letter{

}

选中文本的样式：
.box::selection{
  background-color:orangered;
  color:blue;
}

伪元素的应用：

避免父元素box塌陷：
.box:after{
  content:'';
  clear:both;
  display:table;
}

商品价格符号统一管理：
li:before{
  content:'$';
}

计数函数：
ol li{
  counter-increment:num;
}
ol li:before{
  content:counter(num) "-->";
}

使子列表重新计数：
ol{
  counter-reset:num;
}


属性选择器

元素中包含class属性名：
div[class]{}
元素属性id='div01'的元素：
div[id='div01']{}
属性值以div开头
div[id^='div']{}
属性值以02结尾
div[id$='02']{}
test属性中包含world
div[test*='world']{}


如果content使用url函数，必须给伪元素设置
display:inline-block;
width:宽度;
height:高度;

显示属性内容的应用
@media print{
  content:attr(href);
  margin-left:8px;
}

classList
所有DOM中都包含该属性对象，只针对class属性操作
新增一个class属性值
box1Dom.classList.add('box2');
删除一个class属性值
box1Dom.classList.remove('box');
样式切换
如果存在就删除，如果不存在就添加
box1Dom.classList.toggle('box');
判断是否有指定属性值
document.title=box1Dom.classList.contains('box');
返回类选择器的个数
document.title=box1Dom.classList.length;


checked

input[type='checkbox']{
 ...
 /*清空表单项的默认样式*/
 -webkit-appearance:none;
 -moz-appearance:none;
 appearance:none;
 /*取消外边框*/
 outline:none;
}

input[type='checkbox']:checked{
 xxx
}

兼容问题

IE6中给浮动元素设置外边距，会导致产生双倍空间。
解决方法：
为浮动元素设置
*display:inline;


高度塌陷
防止IE6浮动元素造成父元素高度塌陷
*zoom:1;


在IE6中设置一像素的高度，会显示比实际高，
解决方法：
*overflow:hidden;


快速生成条件表达式
<!--[if gte IE 6]-->
  hello
<![endif]-->


:before
:after
特点：
1.默认是inline元素
2.必须包含content属性
3.content属性的值：字符串或者CSS的函数（url(),attr(),counter()）,多个字符串使用空格连接。





过渡

暴力写法
（过渡所有属性，及它们的过渡时间）：
transition:3s;

选择写法：
指定需要过渡效果的属性名：
transition-property:width,height;
指定需要过渡效果的持续时间：
transition-duration:3s;

触发过渡的三个条件：
1.触发的时机；
 body:hover .box{
   width:200px;
   height:200px;
 }
2.指定所需要的要过渡效果的CSS样式名称；
3.必须制定过渡持续的时间。


仅CSS属性值是
中间值（CSS值使用数值表示）
的CSS样式才有过渡的效果。


过渡的延迟执行
transition-delay:1s;

transition-delay:-1s;
当delay的值为负值时，表示过渡触发时，已经执行完成的过渡有多少。

控制过渡的效果：
缓慢开始，缓慢结束--
transition-timing-function:ease;
匀速--
transition-timing-function:linear;
更灵活的写法：
transition-timing-function:cubic-bezier(.49,1.3,.76,1.38)

http://cubic-bezier.com


过渡简写
transition:width 2s,height 2s -1s cubic-bezier(.49,1.3,.76,1.38);
transition:CSS属性名 过渡时间 延迟时间 过渡效果；
transition:CSS属性名 过渡时间 过渡效果 延迟时间；


问题
过渡效果的覆盖：
触发：多个简写包含同一个CSS样式名
规则：
后面简写的过度样式的 延迟时间+过渡时间 如果大于0 则后面的过渡覆盖前边的过渡；
后面接卸的过度样式的 延迟时间+过渡时间 如果小于等于0 则执行前面的过渡效果。


隐式过渡
使用相对单位，在IE，火狐浏览器会发生隐式过渡。




变形

所有变形函数必须设置在非inline元素上。

缩放：
transform:scale(2);
transform:scale(.5);

transform:scaleX(2);
transform:scaleY(.5);

transform:scale(2,.5)

缩放函数特点：
1.文本内容会随之放大，后代元素也会随之缩放。
2.不会导致兄弟元素位置发生改变。
3.不会导致父元素大小发生改变。



倾斜：
transform:skewX(45deg);
transform:skewY(-45deg);
transform:skew(45deg,15deg);

若想使子元素不变形，可以设置子元素向相反的方向过渡。


位移：
变形中心点不会影响位移函数。
transform:translateX(15px);
transform:translateY(-15px);
transform:translate(15px,-15px);


旋转：
transform:rotate(-360deg);


变形中心点：
transform-origin:left;
transform-origin:0 50%;
transform-origin:0 50px;


/*两个函数综合使用:前一个函数的坐标系，会影响后续函数的坐标系*/
.wrapper:hover .box1{
       transform: translateX(200px) scale(2);
        }
.wrapper:hover .box2{
       transform: scale(2) translateX(200px);
        }






3d

开启
transform-style:preserve-3d;

景深：
perspective:800px;
在3D元素中设置，所有的子元素统一生效。

transform:perspective(200px);
给3D元素的子元素单独设置景深。

景深中心点
perspective-origin:left;

元素
transform:translateZ(-200px);
Z轴，正数，朝向你；负数，屏幕里。

背面是否可见
backface-visibility：hidden;
元素背面朝向观察者不可见。
在火狐中，必须配合
transform:translateZ(0);




制造三角形

.box{
width:0px;
height:0px;
border-top:120px solid blue;
border-right:120px solid transparent;
border-bottom:120px solid transparent;
border-left:120px solid transparent;
}


圆角
border-radius:15px 40px 80px;

border-radius:75px 5px 20px 0/75px 5px 20px 0;













3d
（简单总结，前面还有完整的）

开启
transform-style:preserve-3d;
Z轴，正数，朝向你；负数，屏幕里。

景深
perspective：length；必须大于零。
在3D元素中设置，所有的子元素统一生效。

transform:perspective(200px);
给3D元素的子元素单独设置景深。

景深中心点
perspective-origin:x y;

背面是否可见
backface-visibility：hidden;
元素背面朝向观察者不可见。
在火狐中，必须配合
transform:translateZ(0);


动画
animation-name:关键帧名，关键帧名2
animation-duration:动画一个播放周期持续时间
animation-delay：延迟时间
animation-timing-function:设置动画效果（三次贝塞尔曲线）

播放顺序
animation-direction
  -alternate交替执行
  -reverse  反向执行
  -alternate-reverse  反向交替执行

播放次数
animation-iteration-count:
number
infinite 无限次

暂停
animation-play-state
 running
 paused 暂停（一般配合状态伪类使用）

填充：动画开始或者结束后使用第一帧或者最后一帧填充
animation-fill-mode:
backwards:动画开始前，显示第一帧.
必须有第一帧。
（这个地方出过错，backwards预示着从前往后播放，而不是倒序播放！）
forwards:动画结束后，显示最后一帧。
必须有最后一帧。
（这个才是倒序）
both:
动画开始前显示第一帧，需要设置延迟执行时间，动画开始后显示最后一帧。

简写：
animation:
无顺序要求
如果出现两个时间，第二个是延迟时间。
存在覆盖。


定义动画变化的规则
@keyframes 关键帧名{
 0%-100%{
  css样式，有部分样式不支持。
 }
 第一帧：0%{}，from{}
 最后一帧：100%{}，to{}
 (每一帧的变化自动有补间动画，无需设置过渡效果)
}


查看某一CSS样式在浏览器中的支持情况
http://www.caniuse.com


圆角
border-radius：左上，右上，右下，左下
border-radius：左上，右上，右下，左下（x轴半径）/左上，右上，右下，左下（y轴半径）






图片边框
1.设置边框样式
border：20px solid;
2.引入一张图片
border-image-source:url('img/border.png');
3.切四刀
border-image-slice:fill;
border-image-slice:26;
border-image-slice:52 52 26 26;


/*拉伸：默认值*/
border-image-repeat:stretch;
border-image-repeat;
/*round：平铺保证图片的完整性*/
border-image-repeat:round;


/*图片变宽显示效果，不影响盒子的大小，向里显示*/
border-image-width:20px;
/*边框的扩展范围：大于零*/
border-image-outset:50px;


透明色
transparent





阴影

box-shadow:xOffset yOffset 模糊半径 扩展半径 阴影的颜色 是否为内阴影（默认：外阴影）

内阴影
box-shadow:-50px -50px 150px 0 inset;

水彩效果
需要设阴影的元素中，
高度或宽度为0，
box-shadow:0 0 10px 1px red;
(用扩展半径撑起水印)

外轮廓
默认 outline:none;
outline:30px solid fgba(255,0,0,.3);
outline-offset:40px;


文本阴影
text-shadow:200px -20px 20px red;




背景裁剪

裁剪者
background-clip:content-box;
background-clip:padding-box;
background-clip:border-box;

对齐方式(原点)
background-origin:border-box;
...


文本裁剪

background-image:url('img/bg.jpg');
-webkit-background-clip:text;
-webkit-text-fill-color:transparent;


背景大小
background-size:100% 100%;
background-size:200px 300px;
/*基于元素最长的边计算，其他等比计算*/
background-size:cover;
/*基于元素最短的边计算，其他等比计算*/
background-size:contain;


多背景设置
background-image:url('img/bg.jpg'),url('img/border.jpg');
background-repeat:no-repeat,repeat;
background-position:100px 0,0 0;


线性渐变
本质：绘制一张有规则颜色变化的图形。
background-image:linear-gradient(to bottom/top/right/left,red,yellow,blue);

background-image:linear-gradient(45deg,red,yellow,blue);

加入数值
background-image:linear-gradient(to right,red 300px,yellow,blue);
表示：
从左往右，
在300px后，开始执行红到黄到蓝的转换，
之前的颜色是红色。


重复线性渐变

background-image:repeating-linear-gradient(
to right,
#000 0,
#000 20px,
#fff 20px,
#fff 40px,
blue 40px,
blue 60px),
repeating-linear-gradient(
45deg,
#000 0,
#000 20px,
#fff 20px,
#fff 40px,
blue 40px,
blue 60px);


径向渐变
background-image:radial-gradient(circle at 0 0,red,blue)

加上半径
background-image:radial-gradient(circle 100px at bottom,red,blue);

重复径向渐变
background-image:repeating-radial-gradient(circle 200px at center,
greenyellow 0,
greenyellow 20px,
#999 20px,
#999 40px);



圆角效果能在inline元素中使用，在他的背景上生效。


背景定位的原点默认是padding-box
background-origin:padding-box;

从5月9号开始

<pre></pre>
里面写的文字会保存其格式，
即空格和换行会保留。


white-space:nowrap;
文本不换行，直到遇到<br>
使用场景：
广告标语，
网站的导航内容。


自适应

自适应网站的特点：
页面随着“布局视口”而改变，但是页面的布局不变。

box-sizing:border-box;

设置padding的时候，box的大小不变,而是挤压box-content。
设置margin有可能导致换行。

标准盒模型，宽高是元素content-box的宽高；
border-box元素宽高是边框盒子的宽高。

计算函数：
calc(算数表达式)；
注意：运算符两侧必须有空格。
width:calc(33.333% - 1px);




伸缩盒模型

开启
(display:inline-flex;)
display:flex;

伸缩项目：伸缩容器的子元素。

控制伸缩项目在主轴中的位置：
justify-content:flex-start; 
justify-content:flex-end;
justify-content:center;

剩余空间包裹伸缩项目:
justify-content:space-around;
伸缩项目包裹剩余空间：
justify-content:space-between;


侧轴对齐：
align-items:stretch;(默认值，拉伸。实现伸缩项目等高的关键)
align-items:flex-start;
align-items:flex-end;
align-items:center;

align-items:baseline;
一行中，基线最大的伸缩项目的基线作为整行对齐的基准。


换行：
默认值：不换行。
flex-wrap:nowrap;
换行
1.必须指定伸缩容器的高度
2.设置flex-wrap:wrap;
3.设置伸缩项目的宽度，导致主轴方向空间不足。

侧轴对齐：
stretch (默认) 沿着侧轴拉伸缩项目
align-items:flex-start;
align-items:flex-end;
align-items:center;（侧轴居中）

沿着伸缩容器侧轴对齐伸缩项目
align-content:flex-start;
align-content:flex-end;
align-content:center;

align-content:space-around;
align-content:space-between;


align-content: 多行在容器侧轴的对齐
           flex-start
           flex-end
           center

           stretch (默认)

           前提：伸缩容器侧轴方向有剩余空间
           space-between
           space-around


           生效前提：(必须产生多行)
                1.设置容器的宽度
                2.设置伸缩项目的宽度，导致主轴空间不足
                3.设置容器的 flew-wrap: wrap/wrap-reverse




主侧轴设置
flex-direction:row;
(默认，主轴是横向)

flex-direction:column;
(主轴变为纵向，侧轴变成横向)

start和end位置对调
flex-direction:row-reverse;
flex-direction:column-reverse;



伸缩项目换行：
1.设置伸缩容器的宽度
2.设置flex-wrap:wrap;/flex-wrap:wrap-reverse;
3.设置伸缩项目沿主轴的长度，导致主轴空间不足。


align-self
放在伸缩项里,
单独为某个伸缩项设置对齐方式。
align-self：flex-start;
align-self:flex-end;
align-self:center;
align-self:stretch;


优先生效的顺序：
1、align-content:xxx
2.align-self:xxx
3.align-items:xxx




  /*分配剩余空间*/
  flex-grow:xx;
  平均分5份，然后按数字分摊。
.box1{
     background-color: rebeccapurple;     
     flex-grow: 2;
}
.box2{ background-color: red;
     flex-grow: 1;
}
.box3{ background-color: blue;
     flex-grow: 1;
}
.box4{ background-color: yellow;
      flex-grow: 1;
}


    如果不设置的时候，
    就默认是平分。	


flex-basis:100px;
沿着主轴方向初始化的空间，当与宽度“重叠”时，
flex-basis优先生效。


压缩率
flex-shrink:1;
1默认值，
0不压缩。

关于压缩率的计算，详见某个ppt.
压缩计算规则
            1.计算处需要压缩的空间（300px）
            2.压缩的基数

                 flex-shrink*flex-basis (当没有设置flex-basis使用宽度 width,　height ) + n...
            3.每个伸缩项目压缩率
                flex-shrink*flex-basis / 压缩的基数

            4.每个项目实际需要压缩的空间
                需要压缩的空间 * 每个伸缩项目压缩率

            5.压缩后的大小
                元素实际的宽（高）- 每个项目实际需要压缩的空间





排序

在主轴方向排序：
（设置在伸缩项目中）
order:1
order:2
...
在设置了order之后，
伸缩项目会从原有的排列中走出来，
然后原有队列后面重新自立门户般排序，
设置了order的伸缩项目中：
假设order值一样，
按之前队列中先后顺序排序；
假设order值不一样，
按order值重新在后面排序。


inline-flex在行内对齐的特点：
1.当伸缩容器第一个节点有文本。一行中的其他行内元素与该文本基线对齐。
2.当伸缩容器第一个节点没有文本，但是第一个伸缩项目有文本节点。一行中的其他行内元素与该伸缩项目文本基线对齐。
3.不符合以上两种情况，伸缩容器底部与一行中其他内容基线对齐。


伸缩项目和伸缩容器，可以通过z-index设置层级。

2D变换和3D变换会导致元素层级提升一层。（但是可能不能用z-index降级）



响应式布局
  同一个页面，在不同宽度浏览器显示的内容不同。


布局视口
1.布局视口是可以缩放的，使用的CSS像素
2.布局视口缩放的本质是改变了物理像素与CSS像素的比例
        放大：一个CSS像素会对应多个物理像素，网页的内容会变大，但是布局视口缩小。
        缩小：一个物理像素会对应多个CSS像素，网页的内容会变小，但是布局视口放大。
3.物理视口不可以缩放，出厂时已经设置完毕。使用的物理像素


多媒体选择器控制的样式会存在样式覆盖问题
1. 写在控制变换样式的下方
2. 使用 !important; 强制生效（推荐）
@media screen and (min-width: 768px) and (max-width: 1024px){
            .box {
                background-color: red !important;
            }
}



注意事项：
     1. and 前后必须有空格
     2. 存在样式覆盖的问题，建议 @media screen  样式使用 !important
     3. 手机端默认视口一般是 980px,设置完美视口


移动端视口
手机端默认的布局视口宽度时 980px(css像素)
目的：能够显示PC端的页面。
设备视口的目的是让手机浏览器网页内容大小与PC一致。

完美视口（理想视口）：
width=device-width 
布局视口=设备视口宽度
<meta name="viewport" content="width=device-width">


监控横屏
@media screen and (orientation:landscape){
 .box{
   background-color:red;
 }}


在多层嵌套中，用em会出现问题，
应该用rem，
因为rem是基于html本身的字体大小计算的。


报纸
设置每列的宽度
column-width:200px;
规定列之间间隔
column-gap:20px;
设置列之间的样式
column-rule:5px solid red;
每列高度相同
column-fill:balance;

标题
元素横跨所有列
column-span:all;
text-align:center;



语义化元素
<header>
</header>

<nav>
</nav>

<footer>
</footer>

<!--低版本浏览器不支持HTML5语义元素-->
<script type="text/javascript" src="js/html5shiv.js"></script>


语义化的意义：
    1.程序员：降低维护成本
    2.浏览器：即便没有加载CSS样式，文档结构仍然清晰
    3.搜索引擎：更快收录网站



表单

<form action='server.html' method='post'></form>
action：
指内处理表单请求的服务器地址（URL）
method:
get默认值，用户输入信息会显示在地址栏；
post用户输入信息提交后，不会显示在地址栏。

数字选择
<input type='number' name='number' placeholder='number' min='10' max='20' step='5'>

range
<input type='range' name='range' placeholder='range' max='1000' min='100' step='50'>

颜色
<input type='color' name='color'>

日期
支持度不高，就不写了。
有那么一个插件。


普通的select
<select>
 <option value='0'>美女</option>
 <option value='1'>帅哥</option>
 <option value='2'>老腊肉</option>
 <option value='3'>小鲜肉</option>
</select>


高级的数据列表元素
<input type='text' name='test' list='ls'>
<datalist id='ls'>
 <option value='0'>美女</option>
 <option value='1'>帅哥</option>
 <option value='2'>老腊肉</option>
 <option value='3'>小鲜肉</option> 
</datalist>

!!!!!
在输入框中输入时，如果列表中有其文字，会有提示功能。
！！！！


点击‘用户名’照样出光标的方法
<label for='user'>用户名：</label>
<input type='text' name='user' id='user'>




清除历史记录
autocomplete:
on  默认值 浏览器显示用户提交后的数据；
off 浏览器不显示用户提交后的数据 。

autofocus=''autofocus;
自动获取输入焦点。

required=‘required’;
表单提交时，表单控件值不能空。

pattern='正则表达式'；
通过正则表达式检查输入的内容是否符合要求，但是该方式不安全！！！

设置表单暂存按钮
formaction='server_save.html';
formnovalidate='formnovalidate';
提交到formation指向的服务器地址时，不需要验证输入内容的合法性。



基于JS监控布局视口的变换
视口宽度：document.documentElement.clientWidth;
视口高度：document.documentElement.clientHeight;
实时监控视口的变换：
window.onresize();





bootstrap

详见今天的代码。

列偏移
<div class='col-lg-4 col-lg-offset-8'>
 会影响其他布局元素。
 会拱别人。
</div>

<div class='col-lg-4 col-lg-push-4'>
  实质上是相对定位。
  不会拱别人。
</div>

form.class:form-inline
使表单项在同一栏中。



（最近几乎是没有笔记的）
（没什么记的）



离线存储
window.sessionStorage和window.localStorage

它们的方法完全一致
新增和修改：setItem(key,value) 都是字符串的数据（数字，布尔，JSON需要转字符串）
删除：removeItem(key)
清空：clear();
根据索引获取key名：key(number)索引从0开始。
根据key名获取value:getItem(key);

它们的属性完全一致
length存储了多少条键值对

同域：
协议+域名+端口必须一致！
（不显示数字的端口都默认是80）

sessionStorage和localStorage的区别
生命周期：
sessionStorage:数据创建 到 浏览器页签关闭；
localStorage:数据创建 到 用户显示删除（清空历史记录，clear(),removeItem(key)）；
数据共享范围：
sessionStorage:在同一个页签，同域。
localStorage:同域。

所有离线数据是在浏览器端创建，每次请求不会发送到服务器。


历史记录（虚拟的）

    pushState(JSON格式，字符串，网页的标题（null），同域的URL);
        --新增一条历史记录
    replaceState(JSON格式，字符串，网页的标题（null），同域的URL);
        -- 替换当前视口的虚拟URL

    onpopstate

        触发的时机：点击浏览器的回退和前进按钮（等同JS , back() 或者 forward() ）

        数据副本存储在 event.state 中。

    使用场景：单页离线应用。（即便后续没有网络，也可以访问）



canvas
画布
（好像不太重要）

设置画布大小
（在js中设置）
myCanvasDom.width=200;
myCanvasDom.height=200;
(不加px)

获取画笔
var painting=myCanvasDom.getContext('2d');

绘制矩形
painting.fillRect(50,50,100,100);
参数（x,y，width,height）

修改填充色
painting.fillStyle='blue';

线宽
painting.lineWidth=10;

清除指定的绘制区域
painting.clearRect(0,0,1000,300);

开始绘制图形
painting.beginPath();

画笔移动到的位置
painting.moveTo(100,100);

画笔结束的位置
painting.lineTo(200,200);

描边
   painting.lineWidth = 20;
    painting.strokeStyle = "blue";
    painting.stroke();

首尾相连
painting.closePath();
必须写在描边前（painting.stroke();）

填充
painting.fill();

线段结束处
painting.lineCap='round/square';

线段连接处
painting.lineJoin='round/bevel';

绘制圆形
painting.arc(200,200,100,0,360/180*Math.PI,false);
参数：x,y,width,height,弧度，顺时针。

填充色
var linearGradient=painting.createLinearGradient(200,200,500,200);
(从（200,200）到（500,200）画一条渐变线)
linearGradient.addColorStop(0,'red');
linearGradient.addColorStop(1,'blue');
painting.fillStyle=linearGradient;
painting.fillRect(0,0,1000,900);


设置阴影
painting.shadowColor='red';
painting.shadowOffsetX=0;
painting.shadowOffsetY=0;
painting.shadowBlur=50;

文本
painting.font='bold 38px Microsoft YaHei';
painting.textAlign='start/center/end';
painting.fillText('hello',0,100);
//painting.fillRect(100,100,300,1);

图片
var img=new Image();
img.src='img/bg.jpg';
//确保图片加载完成后，再绘制图片
img.onload=function(){
painting.drawImage(img,200,200,100,100);
//参数：img,x,y,realWidth,realHeight.



图片合成
（不写了，自己去找吧）

保存和恢复样式
。。。
painting.save();
//save了上面的样式

、、、（一通新的自定义样式后）
painting.restore();
恢复/调用之前save的样式。


}







颜老师

屏幕尺寸：
屏幕的对角线长度，单位是英寸。
屏幕分辨率：
（iPhone6  750*1334）
横纵向的像素点数，
这里的1像素指的是物理设备的一个像素点。
（可能就是指的物理像素。）
屏幕像素密度/像素密度/屏幕密度：
屏幕上每英寸可以显示的像素点的数量。


像素

设备像素/物理像素（即分辨率）：
最小的发光点。
数量是固定的。

CSS像素：
是一个抽象的层。
一个width为200px的元素，它占据了200个CSS像素。
但是它占据多少个物理像素取决于像素比和用户缩放行为。
设备独立像素：
设备独立像素，也叫密度无关像素。
就是一个在计算机的一个点（你所认为的默认像素），
每个点对应一个程序使用的虚拟像素。
对于WEB开发者而言：
我们用css和js中的像素本质上都是CSS像素，
在开发过程中并不在意一个css像素到底跨越了多少个设备像素。
像素比：
设备物理像素和设备独立像素的比例，
devicePixelRatio=物理像素/独立像素
window.devicePixelRatio


PC端到移动端
要么，挤一挤，缩小网站使用户看到网站全貌。
要么，舍弃一些布局。


理想视口：
因为布局视口默认不等于移动设备宽度，
只有专门为移动设备开发的网站，才有理想视口这一说。
而且只有当在页面中加入viewport的meta标签，理想视口才生效。
<meta name="viewport" content="width=device-width" />
这一行代码告诉我们，布局视口的宽度应该与理想视口的宽度一致。


在移动设备上,视口被分为了两个:布局视口限制了你的css布局,视觉视口会决定用户能看到什么。
在移动设备上,还有一个理想视口,它是对于特定设备上特定浏览器的布局视口的一个理想尺寸。


	
放大
会使一个css像素的面积变大
一个css像素所包含的物理像素变多
视觉视口所包含的css像素的个数变少
		
缩小（默认情况下（没有meta标签）其实已经有了一个缩小操作了）
会使一个css像素的面积变小
一个css像素所包含的物理像素变少
视觉视口所包含的css像素的个数变多
		

布局视口：
默认情况下		980个css像素	
加meta标签后		设备独立像素所代表的值
	    
视觉视口：
默认情况下	        设备独立像素所代表的值		
用户放大或者系统放大时   视觉视口所包含的css像素的个数变少
用户缩小或者系统缩小时   视觉视口所包含的css像素的个数变多


pc端：
缩放会改变视口（视口变小）
		
移动端：
缩放会改变视觉视口的尺寸，不会改变布局视口的尺寸	


移动端的缩没有改变布局视口的任何东西！！！！！！！！！！！！！！！！！


语句
//DOM 0,在模拟器里 不支持
//ontouchstart手指触摸屏幕那一刻触发
box.ontouchstart = function(){
	alert('ontouchstart');
};
//ontouchmove手指触摸屏幕并滑动，
box.ontouchmove = function(){
	alert('ontouchmove');
};
//ontouchend手指触摸离开屏幕
box.ontouchend = function(){
	alert('ontouchend');
}

//DOM 2
box.addEventListener('touchstart',function(){
	console.log('touchstart');
});
box.addEventListener('touchmove',function(){
	console.log('touchmove');
});
box.addEventListener('touchend',function(){
	console.log('touchend');
})


触摸事件
//changedTouches:目标元素目标事件上的手指列表(常用)
//targetTouches:目标元素上的手指列表
//touches :屏幕上的手指列表
box.addEventListener('touchstart',function(ev){			console.log(ev.changedTouches[0].clientY);
	console.log(ev.changedTouches[0].clientX);
});


meta(苹果发明的，桌面浏览器不支持)

<meta name="viewport" content="width=device-width,height=device-height,user-scalable=no（用户能否进行缩放）,
initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0（最小和最大缩放倍数）,target-densitydpi=device-dpi"（设置默认像素密度为2） /> 

width=device-width：
会使布局视口的大小变成理想视口的大小
95%的浏览器都支持。
当用户旋转设备时，布局视口的宽度通常会发生改变。因为横竖屏时的理想视口尺寸不一样，
但ios的safari很例外，基于性能的考虑它的布局视口不会做出改变。

initial-scale:
缩放是根据理想视口来计算的，这个缩放不同于我们用户的缩放，它会使
!!布局视口
跟随着我们的视觉视口一起转变
所以只设置inital-scale=1其实等同于,
只设置width=device-width .

完美视口！！：
<meta name='viewport' content='width=device-width,initial-scale=1.0,user-scalable=no'/>

width和initial-scale之间的冲突：
布局视口在width和initial-scale产生分歧时会选择它们中比较大的那一个。


initial-scale缩放：
缩放是根据理想视口来计算的，
理想视口375生效以后。缩放是根据375来计算的（无论前面的width写多少它都是375）。
不同于用户的缩放，而是系统的缩放。
它会使布局视口随着我们视觉视口一起转变。

我感觉，视口的大小用的是CSS像素。

我们设width=xx,
就是把xx个CSS像素平铺到独立物理像素为375的视口上，
视口大小就是xx。
xx越大，
视口的大小就越大。

我们设initial-scale=x倍，
因为x倍是相对于width=375来计算的，
就是把布局视口的每个CSS像素的大小放大xx倍，
那么就相当于把(375/xx)个的CSS像素平铺到独立物理像素为375的视口上，
视口大小就是（375/xx）,
xx越大，
视口的大小就越小。

width相当于，
市长让多少人来租房，
当然是批准的人愈多，
视口就越大。
initial-scale相当于，
市长安排每个人租房的面积有多大，
当然是每个人要的面积越大，
视口就越小。
视口相当于总共住进来多少人。


案例：
width设置成100px,
initial-scale=2.0
那么视口的大小就是187。






屏幕尺寸：
屏幕的对角线长度，单位是英寸。
屏幕分辨率：
（iPhone6  750*1334）
横纵向的像素点数，
这里的1像素指的是物理设备的一个像素点。
（可能就是指的物理像素。）
屏幕像素密度/像素密度/屏幕密度：
屏幕上每英寸可以显示的像素点的数量。


像素

设备像素/物理像素（即分辨率）：
最小的发光点。
数量是固定的。

CSS像素：
是一个抽象的层。
一个width为200px的元素，它占据了200个CSS像素。
但是它占据多少个物理像素取决于像素比和用户缩放行为。
设备独立像素：
设备独立像素，也叫密度无关像素。
就是一个在计算机的一个点（你所认为的默认像素），
每个点对应一个程序使用的虚拟像素。
对于WEB开发者而言：
我们用css和js中的像素本质上都是CSS像素，
在开发过程中并不在意一个css像素到底跨越了多少个设备像素。
像素比：
设备物理像素和设备独立像素的比例，
devicePixelRatio=物理像素/独立像素
window.devicePixelRatio


PC端到移动端
要么，挤一挤，缩小网站使用户看到网站全貌。
要么，舍弃一些布局。


理想视口：
因为布局视口默认不等于移动设备宽度，
只有专门为移动设备开发的网站，才有理想视口这一说。
而且只有当在页面中加入viewport的meta标签，理想视口才生效。
<meta name="viewport" content="width=device-width" />
这一行代码告诉我们，布局视口的宽度应该与理想视口的宽度一致。


在移动设备上,视口被分为了两个:布局视口限制了你的css布局,视觉视口会决定用户能看到什么。
在移动设备上,还有一个理想视口,它是对于特定设备上特定浏览器的布局视口的一个理想尺寸。


	
放大
会使一个css像素的面积变大
一个css像素所包含的物理像素变多
视觉视口所包含的css像素的个数变少
		
缩小（默认情况下（没有meta标签）其实已经有了一个缩小操作了）
会使一个css像素的面积变小
一个css像素所包含的物理像素变少
视觉视口所包含的css像素的个数变多
		

布局视口：
默认情况下		980个css像素	
加meta标签后		设备独立像素所代表的值
	    
视觉视口：
默认情况下	        设备独立像素所代表的值		
用户放大或者系统放大时   视觉视口所包含的css像素的个数变少
用户缩小或者系统缩小时   视觉视口所包含的css像素的个数变多


pc端：
缩放会改变视口（视口变小）
		
移动端：
缩放会改变视觉视口的尺寸，不会改变布局视口的尺寸	


移动端的缩没有改变布局视口的任何东西！！！！！！！！！！！！！！！！！


语句
//DOM 0,在模拟器里 不支持
//ontouchstart手指触摸屏幕那一刻触发
box.ontouchstart = function(){
	alert('ontouchstart');
};
//ontouchmove手指触摸屏幕并滑动，
box.ontouchmove = function(){
	alert('ontouchmove');
};
//ontouchend手指触摸离开屏幕
box.ontouchend = function(){
	alert('ontouchend');
}

//DOM 2
box.addEventListener('touchstart',function(){
	console.log('touchstart');
});
box.addEventListener('touchmove',function(){
	console.log('touchmove');
});
box.addEventListener('touchend',function(){
	console.log('touchend');
})


触摸事件
//changedTouches:目标元素目标事件上的手指列表(常用)
//targetTouches:目标元素上的手指列表
//touches :屏幕上的手指列表
box.addEventListener('touchstart',function(ev){			console.log(ev.changedTouches[0].clientY);
	console.log(ev.changedTouches[0].clientX);
});


meta(苹果发明的，桌面浏览器不支持)

<meta name="viewport" content="width=device-width,height=device-height,user-scalable=no（用户能否进行缩放）,
initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0（最小和最大缩放倍数）,target-densitydpi=device-dpi"（设置默认像素密度为2） /> 

width=device-width：
会使布局视口的大小变成理想视口的大小
95%的浏览器都支持。
当用户旋转设备时，布局视口的宽度通常会发生改变。因为横竖屏时的理想视口尺寸不一样，
但ios的safari很例外，基于性能的考虑它的布局视口不会做出改变。

initial-scale:
缩放是根据理想视口来计算的，这个缩放不同于我们用户的缩放，它会使
!!布局视口
跟随着我们的视觉视口一起转变
所以只设置inital-scale=1其实等同于,
只设置width=device-width .

完美视口！！：
<meta name='viewport' content='width=device-width,initial-scale=1.0,user-scalable=no'/>

width和initial-scale之间的冲突：
布局视口在width和initial-scale产生分歧时会选择它们中比较大的那一个。


initial-scale缩放：
缩放是根据理想视口来计算的，
理想视口375生效以后。缩放是根据375来计算的（无论前面的width写多少它都是375）。
不同于用户的缩放，而是系统的缩放。
它会使布局视口随着我们视觉视口一起转变。

我感觉，视口的大小用的是CSS像素。

我们设width=xx,
就是把xx个CSS像素平铺到独立物理像素为375的视口上，
视口大小就是xx。
xx越大，
视口的大小就越大。

我们设initial-scale=x倍，
因为x倍是相对于width=375来计算的，
就是把布局视口的每个CSS像素的大小放大xx倍，
那么就相当于把(375/xx)个的CSS像素平铺到独立物理像素为375的视口上，
视口大小就是（375/xx）,
xx越大，
视口的大小就越小。

width相当于，
市长让多少人来租房，
当然是批准的人愈多，
视口就越大。
initial-scale相当于，
市长安排每个人租房的面积有多大，
当然是每个人要的面积越大，
视口就越小。
视口相当于总共住进来多少人。


案例：
width设置成100px,
initial-scale=2.0
那么视口的大小就是187。





node



0710-js复习

情景一
var obj=new Object();
obj.name='孙悟空';
var obj2=obj;
obj2.name='猪八戒';//obj.name会变
obj2=null;//obj2中的地址消失，不会影响另一个对象obj

情景二
function fn(obj){
  obj.name='猪八戒';//原obj中的name相应改变,都输出猪八戒
  obj={name:'猪八戒'};//obj被赋值，被传入对象之后，原本的地址被覆盖，和之前的obj所指向的对象失去联系；此时这里输出猪八戒，而外边输出孙悟空。
  console.log(obj.name);
}
var obj={name:'孙悟空'}；
fn(obj);
console.log(obj.name);


原型
（老师的一大段文字）
（/*
			原型：
				- 在每一个函数中都有一个属性叫做prototype，
					该属性对应一个对象，这个对象就是所谓的原型对象
				- 如果函数作为普通函数调用（没有使用new），则原型对象没有任何作用
				- 当函数以构造函数的形式调用时，则通过该构造函数创建的对象中，
					都会有一个隐式的属性指向该构造函数的prototype对应的对象，可以通过__proto__来访问
					实例对象的隐式原型（__proto__）指向构造函数的显示原型（prototype）

				- 原型链
				- 当我们调用对象的方法或属性时，对象会先在自身中寻找,如果找到了则直接使用，
					如果没有找到则去对象的原型中寻找，如果找到了则使用，
					如果没有找到则去对象的原型的原型中寻找，如果找到了则使用
					依此类推~~
					直到找到Object的原型，Object的原型是所有对象的原型，而Object原型的原型是null
						如果找到它还没有找到，则返回undefined

				- 在开发中我们可以将对象中共有的属性和方法统一保存到原型对象中，
					这样我们只需要创建一个属性或方法即可被所有的对象访问使用，
					既简化了开发，还提升了程序运行效率
		 */）	

函数对象中既有显示原型prototy，又有隐式原型__proto__				
函数的显示原型是给他的实例使用的；
函数的隐式原型才是给自己用的，同时又是他上一级的显示原型。

变量的提升
var关键字声明的变量，会提前声明但不会提前赋值；
var关键字创建的函数/用函数表达式创建的函数，不能在声明前调用，var的变量显示undefined;
使用函数声明的形式创建的函数，会在所有代码执行前被创建。

执行环境
执行环境就是函数的执行区域，要执行函数或是js中其它代码就必须创建执行环境。
每当代码执行时，都需要创建执行环境。
全局执行环境：
全局执行环境用来执行直接写在script标签中的代码。
全局执行环境在页面加载时创建，页面关闭时销毁。
函数执行环境：
函数执行环境在函数调用时创建，在调用完成时销毁。
每调用一次函数就会创建一个新的执行环境。

函数执行流程
1.创建一个新的执行环境，并且将其放入到执行环境栈的栈顶。
执行环境是放到一个栈结构中保存的，栈顶保存的总是当前执行环境，栈底总是全局环境。
2.创建一个新的变量对象，并且将变量对象放到作用域栈的栈顶。
变量对象是用来保存变量的对象，函数执行时所有的局部变量和函数都会保存到变量对象中，变量对象无法访问。除了全局变量对象window。
3.预解析，将使用var声明的变量添加到变量对象中，将函数声明创建函数创建好并添加到变量对象中。
4.逐行执行函数中的代码。
5.函数执行完毕将变量对象从作用域栈中弹出并销毁，将环境从环境栈中弹出并销毁。

作用域（作用域链）
作用域实际上和变量对象是紧密联系
当在一个函数中寻找一个变量时，实际上就是去作用域栈的变量对象中搜索属性的过程，函数会先在自身变量对象中查找属性或方法，如果找到了则使用，没有找到则会去上一层的变量对象中寻找，如果找到则使用，没有找到则继续去上一层，依次类推。直到找到全局的变量对象（window），如果依然没有找到，就会报错。
如果沿着原型链寻找属性没有找到不会报错而是返回undefined；
如果沿着作用域链寻找变量没有找到就会报错。

函数的作用域在其创建的时候就已经确定了，无论在何处调用都不会改变他的作用域。所以在判断他用到的变量时，也是不管他在哪里调用，都在他创建的位置入手。

闭包
闭包简单来说可以将一些不希望外部被外部看到的东西隐藏起来。
闭包是可以访问到外层函数变量的函数。
闭包构成的条件：
1.要有函数的嵌套
2.内层函数需要也能用外层函数中变量
3.调用外层函数

如何写一个闭包：
1.函数嵌套
2.内部函数访问外部函数的变量
3.使用各种手段将内部函数传递出来
4.调用外部函数
闭包的生命周期：
创建：闭包是外部函数调用时创建的。
销毁：闭包是内部函数销毁时销毁的。
闭包的根本作用：
延长变量的作用域。
缺点：
创建闭包会导致变量长期在内存中存在，如果大量使用闭包会对内存有较大的消耗，所以在开发中不要大量使用闭包；在闭包使用完毕后，必须要将内层函数销毁。

练习
为四个超链接绑定单机响应函数
var links=document.getElementByTagName('a');
for(var i=0;i<links.length;i++){
  (function(i){
    links[i].onclick=function(){
      alert(i);
    };
  })(i);
}
//如果没有外边的function包裹里面的function，由于里面的function比较慢，所以开始执行的时候，i已经达到一个最后的值；而有了外面的function，就可以先迅速代领内部函数理应用到的i，然后在内部函数执行时，根据闭包的特点，即延长变量的作用域，外部函数就把这个i传给了内部函数。例子2如下。
for(var i=1;i<=10;i++){
  (function(i){
    setTimeout(function(){
      console.log(i);
    },i*1000);
  })(i);
}

function(event){
  event=event||window.event;
}
等同于
function(ev){
  ev=ev||event;
}
//因为即使不写window，也会向上自动搜索到window


'1'==true //true
'2'==true //false
'hello'==true //false
null==undefined //true
以上两种情况说明，这种情况下似乎是将两侧转换成数字进行比较的,但是：
null==0 //false




nodeJs（抄的学武同学的笔记）

命令
命令行窗口（小黑屏、终端、shell（壳）），打开开始菜单运行输入CMD回车。在命令行需要通过命令来操作计算机。

dir	列出当前目录的文件
cd	进入到指定的文件夹
md文件夹名：创建一个文件夹
rd文件夹名：删除文件夹
rd文件夹名 /s:删除非空文件夹
del文件名：删除文件
.	当前目录
..	返回上一级目录
cd/	返回根目录
cls	清屏

环境变量
当我们的命令行窗口使用一个命令时，或访问一个文件时，它会优先在当前目录下寻找，如果找到了则直接使用，如果没有找到则去环境变量path对应的路径中寻找。

node.js定义
Node.js是一个基于chrome v8引擎的JavaScript运行环境。Node.js的包管理器npm(模块管理工具)，是全球最大的开源库生态系统。Node的底层是由C++编写的。Node是可以让JavaScript代码执行运行在系统中，和系统的底层进行交互。
node就是一个不同于浏览器中js的引擎，它将js代码直接在系统中运行。它也是一个对ECMAScript标准的实现，在node中可以使用全部的ES内建对象，包括String、Number、Boolean、Function、Object、Math、Date、RegExp。。。
注意：
不能在node中使用DOM和BOM对象，
但是可以使用console和定时器。

Node特点
非阻塞异步I/O;
事件、回调函数机制、单线程；
跨平台，Node可以在各种不同的操作系统中使用（windows、linux、unix）。



ES6（ES2015）

新的变量声明方式：
let:
let声明的变量会生成一个块级作用域，只能在当前作用域中访问；
let声明的变量不会提升，在声明之前无法访问；
let无法声明一个变量两次；
在node中，使用let来代替var。

举例
for(var i=0;i<5;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
//输出5个5

for(let i=0;i<5;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
//输出1,2,3,4  ???


const
const主要用来在ES定义常量，所谓常量就是不可修改的值，一旦尝试修改使用const声明的变量，会报错。
const声明的变量，可以修改对象的属性，但不能修改对象本身，否则也报错。


箭头函数
箭头函数是除了let和const之外使用最多的ES6的特性。
箭头函数，故名思议就是使用箭头（=>）进行定义的函数，
属于匿名函数的一类。

箭头函数定义的四种方式”
单一参数：	参数=>返回值
多参数单行箭头函数：(参数1，参数2,..参数n)=>返回值
多行箭头函数：	(参数1，参数2，..参数n)=>{函数体}
无参数箭头函数：	()=>{}

let sum=(a,b)=>a+b;
console.log(sum(1,2));//3

箭头函数可以方便快捷地定义出一个函数，一般传回调函数时，最好使用箭头函数。
之前的排序是：
let arr=[2,5,4,6,3,1];
arr.sort(function(a,b){
  //升序
  //return a-b;
  //降序
  return b-a;
});
console.log(arr);

箭头函数排序（多参数单行）：
arr.sort((a,b)=>a-b);

单一参数：
let fn=a=>a+1;

多行箭头参数：
let fn=(a,b,c)=>{
  console.log(a,b,c);
  return a+b+c;
}

无参数箭头函数（此时对象要用（）括起来）：
let fn=()=>({name:'宋江'});
console.log(fn());//宋江


箭头函数的this
node中的全局对象是global。箭头函数对上下文对象的绑定是强制性的，无法通过apply和call方法改变。
注意事项：
单行箭头函数不要换行；
参数列表的右括号、箭头要保持在同一行内；
单行箭头函数只能包含一条语句；
单行箭头函数返回对象字面量（？）时需要使用括号包裹。

function fn1(){
  console.log(this==global);
}
fn1();//true

箭头函数的this永远都是图外层函数的this，并且无法修改；？？？
箭头函数中不能使用arguments对象。


模板字符串
以往我们做字符串与变量拼接时，需要连续使用若干个‘+’，这样做事十分麻烦的。并且我们不能使用多行字符串，因为引号是不能跨行使用的。为了解决这个问题，在ES6中引入模板字符串。
使用语法：
模板字符串使用`反单引号而不使用”引号（let str=`hello`）;
在模板字符串中使用${}来引用变量；
模板字符串可以跨行使用。

let name='宋江';
let gender='男';
let age=18;
let str=`我是${name}性别${gender}年龄${age}`;
console.log(str);
//我是宋江性别男年龄18



CommonJS规范

ECMAScript标准的缺陷：
没有模块系统；
标准库较少；
没有标准接口；
缺乏管理系统。

模块化
模块化就是将js代码分成一个一个小的模块，然后我们可以根据需要去引入我们要使用的模块，可以使代码方便复用。模块化主要就是简化开发，降低代码之间的耦合。模块化的常见规范有：CommonJS、AMD、CMD。
如果程序设计的规模达到了一定程度，则必须对其进行模块化。模块化可以有多种形式，但至少应该提供能够将代码分割成多个源文件的机制。CommonJS的模块功能可以帮我们解决该问题。在Node中已经为我们内置了很多可以直接使用的模块，所以并不是所有的模块都需要下载。
CommonJS对模块的定义十分简单，主要分为：
模块引用，
模块定义，
模块标识。

模块引用
在规范中，定义了require()方法，这个方法接手模块标识，以此将一个模块引入到当前运行环境中。使用require()来引入模块。
引入自定义模块，需要通过文件路径进行引入。
const hm=require('./helloModule');
hm.sum(1,2);

模块定义
在运行环境中，提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。在模块中还存在一个module对象，它代表模块自身，每一个模块（js文件）就是一个module，而exports是module的属性。在Node中一个文件就是一个模块。module.exports是模块对象的属性，标识模块中暴露给外部的方法或属性。
我们可以通过module和exports来向外暴露方法和属性：
方式1：
exports.fn=function(){};
exports.name='';
方式2：
module.exports.fn=function(){};
module.exports.name='';
方式3：
module.exports={
  fn:function(){},
  name:''
};

例：
exports.sum=function(a,b){
  return a+b;
};
module.exports={
  sum:function(a,b){
    return a+b;
  },
  sub:function(a,b){
    return a-b;
  }
};


模块标识
模块标识其实就是模块的名字，也就是传递给require()方法的参数，它必须是符合驼峰命名法的字符串，或者以.、..开头的相对路径或者绝对路径。模块的定义十分简单，接口也十分简洁。每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落。
global是node中的全局对象，作用相当于浏览器中window。在node中，js文件中的代码都是封闭的函数中执行，不是在全局中执行的，所以在文件中使用let、var或const声明的变量都是局部变量，而不是全局变量。如果声明变量时不使用关键字，则变量会变成全局变量。
let a=10;
b=20;
console.log(global.a);//undefined
console.log(global.b);//20

为了证明js文件是在封闭函数中进行，我们可以通过arguments来检查：
console.log(arguments.callee+'');
//function(exports,require,module,__filename__dirname){/**

js文件中的代码在执行时，node.js会对代码进行修改，它会在代码头部添加function(exports,require,__filename,__dirname){,在代码尾部添加}。也就是node将js文件中的代码使用了一个匿名函数进行了包装，而我们的代码实际是在函数中执行的，所以js中的代码在其他文件中是无法访问的，必须通过exports导出，才能使其他文件访问。所以函数调用时还传递了实参。

exports：用于导出方法的对象
require：用于引入其他模块的对象
module:模块对象，用来表示当前模块，exports就是它的属性
__filename:当前执行文件的完整路径
__dirname：当前执行的文件所在目录

模块的实现
Node中虽然使用的是CommonJS规范，但是其自身也对规范做了一些取舍。
在Node中引入模块，需要经历如下3个步骤：
路径分析，
文件定位，
编译执行。

在Node中，模块分为三类：
一类是底层由C++编写的内建模块，
一类是Node提供的核心模块，
一类是用户编写的模块，成为文件模块。


包
CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。CommonJS的包规范由包结构和包描述文件两个部分组成。

包结构：用于组织包中的各种文件
包描述文件：描述包的相关信息，以供外部读取分析

包结构
包实际上就是一个压缩文件，解压后还原为目录。符合规范的目录，应该包含如下文件：
package.json:描述文件
bin:可执行二进制文件
lib:js代码
doc:文档
test:单元测试

包描述文件package.json
包描述文件用于表达非代码相关信息，它是一个JSON格式的文件-package.json,位于包的根目录下，是包的重要组成部分。它相当于你本地项目的一个文档说明，允许你指定你项目中所使用的node包的版本，构建你的项目更加容易，便于给其他人分享。

package.json中的字段
name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies。

注意：json中不能有注释。

{
  "name":"npm_command",//包名
  "version":"1.0.0",//版本
  "scripts":{//配置npm运行命令
    "start":"node bin/www"
  }，
  "dependencies":{//运行依赖的包
    "jquery":"^3.2.1"
  },
  "devDependencies":{//开发依赖的包
    "babel":"^6.23.0"
  }
}

"jquery":"^3.2.1"	向上的尖括号可以管理二级，三级版本
"jquery":"～3.2.1"	波浪线可以管理三级版本



NPM
Node包管理器（npm）是一个由Node.js官方提供的第三方包管理工具，npm是一个完全由JavaScript实现的命令行工具，通过Node.js执行，因此严格来说它不属于Node.js的一部分，在最初的版本中，我们需要在安装完Node.js以后手动安装npm。但从Node.js0.6开始，npm已经包含在发行包中了，安装Node.js时会自动安装npm。现在的版本大多使用6.0以上。
CommonJS包规范是理论，NPM是其中一种实践。对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM,Node与第三方模块之间形成了很好的一个生态系统。
在Node.js语言中，包和模块并没有本质的不同。包是在模块，包将某个独立的功能封装起来，用于发布、更新、依赖管理和进行版本控制，Node.js根据CommonJS规范实现了包机制，开发了npm来解决包的发布和获取需求。

NPM命令
npm -v:	查看版本
npm:	帮助说明
npm search 包名:	搜索模块包
npm install:	安装当前项目的依赖
npm install 包名:在当前目录安装包
npm install 包名 -save:	在当前目录下载包，并将包设置为项目的依赖（运行依赖）
 	



damu

damu


右查询：
对等号非左边变量的查询。
在整条作用域链中，如果没有找到变量的声明，直接抛ReferenceError错误。

左查询：
对等号左边变量的查询。
在整条作用域链中，如果没有找到变量的声明，js引擎会自动在全局声明一个同名变量。


function test(){
	foo=5;
	function foo(){
		console.log(1);
	}
}
var foo=2;
test()
console.log(foo);//2

/*
 
 * 浏览器解析时的代码的样式：
 
  	function test(){
  		//可以看到，在开始的时候已经对foo进行了函数的声明，所以test()函数里的foo就不会对外界函数有影响。
		function foo(){
			console.log(1);
		}
		foo=5;
	}
	var foo;
	foo=1;
	test();
	console.log(foo);//2
 
 */



伪数组
具有length属性的对象都可以叫伪数组。

区别函数声明与函数表达式：
函数声明：
以functionkit偶的具有函数的代码片段。
函数表达式：
不以function开头的具有函数的代码片段。

console.log(typeof typeof 42);//string
//typeof返回的‘number’属于是字符串

//typeof的安全机制
cconsole.log(typeof a);//undefined

严格模式
"use strict"
放在函数执行体中会生效，即报错；
因为在严格模式下，函数中没有var的不会被提升。
放在函数调用时不会生效。

提升

变量提升不会搭理if条件的暗示。
console.log(a);//undefined
console.log(b);//undefined
if(true){
 var a=2;
}else{
 var b=4;
}

但是如果在if else语句中定义函数，就会出现问题（它会被处理成函数表达式的形式，报错为。。。is not a function）。
结论：在块内部不要去定义函数。

老师的svn笔记：：
###前端开发常用的IDE
	Visual Studio
	Atom
	webstrom
	HBuilder
	

###HBuilder下svn插件的使用
	HBuilder底层产品其实就是java开发最常用的IDE：eclipse
	所以基本上eclipse能使用的所有插件，HBuilder也可以使用。
	
	在不安装svn插件的情况下右键导入中是没有svn选项的
	插件使用技巧：
		找到HBuilder的安装目录，将下载的svn插件解压后丢入到dropins目录下；
		注意解压后的svn插件中的features和plugins目录与dropins目录间只能有一层文件！！

###创建版本库
	svnadmin create D:\damu\Repository\Subversion\test

###svn
	①没有修改，现行版本
		本档案在工作目录中没有被修改，而且自当前版本之后，其他终端也没有任何该文件的修改被提交到服务器，
		即当前工作副本的版本和服务器端最新版本是一致的。对它执行svn commit和svn update都不会发生任何事。
	②本地修改, 现行版本(去做更新 svn不会做任何事情)
		这个文件被修改过，但这个修改还没有提交到服务器，而且自当前版本之后，其他终端也没有任何该文件的修改被提交到服务器，
		所以当前工作副本的版本和服务器端最新版本仍然是一致的。由于有尚未送交回去的本地修改，所以对它的 svncommit会成功提交你的修改，
		而 svn update 则不会作任何事。
	③没有修改，过时版本(去做提交 svn不会做任何事情)
		这个文件没有修改，但是版本库中有其他终端提交的修改。此时当前工作副本的版本比服务器端的版本落后了，我们称之为“过时”。
		对当前文件的 svn commit 不会发生任何事，而 svnupdate 会让工作目录中的文件更新至最新版本。
	④本地修改，过时版本
		服务器端存在没有更新到本地的修改，导致当前版本过时。如果这个文件在本地有未提交的修改，则无法提交，
		对它执行svn commit 会产生“out-of-date”错误。
		此时应该先尝试更新本地文件。更新时SVN会尝试将服务器端的更新与本地文件进行合并，合并的结果有两种可能：
		一个是服务器端和本地修改位于文件的不同位置，合并成功；另一个是服务器端的修改正好和本地修改位于同一个位置，发生冲突。
	⑤.
	文件重命名
	文件移动位置



引用
基本数据类型总是通过值的复制方式来赋值/传递
引用数据类型总是通过引用复制来完成赋值/传递
包装类的基本数据类型值是不可以修改的。
注意引用指向的是值而非变量，所以一个引用无法更改另一个引用的指向，
但是可以改变不同变量共同指向的值。

function foo(arr){
	arr.push(4);
	console.log(arr);
	//对所引用内容的修改，[1,2,3,4]	
	arr=["a","b","c"];
	//这步是形参中的引用在赋值过程中被覆盖，引用所指向的内容同时会从形参丢失
	//（主人公因为嫌钥匙重，扔了，换了250块钱；同时，也失去了钥匙所指向的果园）
	console.log(arr);//["a","b","c"]
}
var arr=[1,2,3];
foo(arr);
//这步是将实参的引用传给形参，引用所指向的内容同时会被形参拥有（传钥匙）
console.log(arr);//[1,2,3,4]
/*
 * 对外部的arr来说，能影响它的只有两种情况：
 * 1.有人和它拥有相同的引用，并通过引用影响引用所指向的内容。
 * 2.给arr赋值，从而使它包含的引用被新内容覆盖，内容也就随之改变。
 */


包装类的基本数据类型值是不可以修改的。
function foo(b){
	b=b+1;// 拆包
	console.log(typeof b);//number 
	console.log(b);//2
}
var a=1;
var b=new Number(a);//装包
console.log(typeof b);//object
foo(b);
console.log(b);//Number -- 1


独立函数调用。可以把这条规则看作是无法应用到其他规则时的默认规则。
独立函数调用。如果使用了非严格模式，this会绑定到全局对象（window）。
独立函数调用。如果使用严格模式（strict mode），this会绑定到undefine。
虽然 this 的绑定规则完全取决于调用位置，
但是只有 foo()运行在非 strict mode 下时，默认绑定才能绑定到全局对象；
严格模式下调用foo()不会影响默认绑定规则。
无论函数是在哪个作用域中被调用，只要是独立调用则就会默认绑定规则绑定到全局对象或者undefined上。

function foo() {
	"use strict"
	console.log( this.a );
}
var a = 2;
foo();
//Uncaught TypeError: Cannot read property 'a' of undefined
//独立函数调用，如果使用了严格模式，就会报错
//规定this就指向undefined

function foo() {
	console.log( this.a );
}
var a = 2;
foo();//2
//独立函数调用，如果使用了非严格模式，this会绑定到全局对象（window）。


情况1：
function foo(){
	console.log(this.a)
};
var b={
	a:1,
	foo:foo
}
var a=100;
b.foo();//1;this指向的是b

情况2：
function foo(){
	console.log(this.a)
};
var b={
	a:1,
	foo:foo
}
var a=100;
var c=b.foo;
c();//100;this指向的是window
//this的调用就是隐式丢失
//虽然在外型上看，情况1和情况2是相同的，但是情况1是b调用自己的一个方法；而情况2是将b的函数复制给c，然后在window中运行c函数。

this主要取决于调用的位置和调用形式，调用的形式主要是独立形式和隐式调用。


function foo() {
	console.log( this.a );//2。相当于以函数方式运行。
}
var a = 2;
(function(){
	//严格模式下'调用'foo()不会影响默认绑定规则
	"use strict";
	foo(); 
})();

//隐式绑定的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含
//当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象


//	对象属性引用链中只有最顶层或者说最后一层会影响调用位置
function foo() {
	console.log( this.a );//42
}
var obj2 = {
	a: 42,
	foo: foo
};
var obj1 = {
	a: 2,
	obj2: obj2
};
obj1.obj2.foo(); 


一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，
从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。
参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。
如果把函数传入语言内置的函数而不是传入你自己声明的函数，结果是一样的，没有区别
JavaScript环境中内置的 setTimeout() 函数实现和下面的伪代码类似：
function setTimeout(fn,delay) {
	// 等待delay毫秒
	fn(); // <-- 调用位置！
	}


//参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。
//其实就是在传参过程中，只能传递所需函数，而不能传递该函数被调用的方式，即原本是作为某个对象的方法调用，当成函数被传递之后将很可能破坏这种调用的方式。
function foo(){
	console.log(this.a);
}
function doFoo(fn){
	fn(); 
}		
var a = "oops, global"; 
var obj = {
	a:2,
	foo:foo
};		
doFoo(obj.foo); 

//有一些很隐蔽的调用，也就是函数的传递，总是能够悄悄破坏原有的调用方式，从而造成隐式丢失。
function foo() {
	console.log(this.a);
}		
var a = "oops, global"; 
var obj = {
	a:2,
	foo:foo
};
setTimeout(obj.foo,1000); 
//在很多情况下，虽然传递的是某个对象的方法，但是之后的调用方式根本不能确定，this的指向也是不能保证的。因此，需要有方法对隐式丢失进行避免。

显示绑定
//普通对象的属性查找 
function foo(a,b) {
	console.log( this.a,a,b );
}
var obj = {
	a:2
};
foo.call( obj,"a","b"); //2 a b
foo.apply(obj,["a","b"]);//2 a b


apply
//正常数组(推荐)
var a=Array.apply(null,{length:3});
console.log(a);
//稀疏数组
var b=Array(3);
console.log(b);


硬绑定

//我们来看看这个显式绑定变种到底是怎样工作的。我们创建了函数 bar() ，
//并在它的内部手动调用了 foo.call(obj) ，
//因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会手动
//在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。

		
function foo() {
	console.log( this.a );
}
var a =1;
var obj = {
	a:2
};
var obj_test = {
	a:"test"
};
var bar = function() {
	console.log( this.a );
	foo.call( obj );//很强势，只要通过bar调用的foo的this都是obj
};
bar(); // 1 2
setTimeout( bar, 1000 ); // 1 2
bar.call( obj_test ); //test  2   硬绑定的bar不可能再修改它的this(指的是foo中的this)


类bind函数的实现？
（01_硬绑定>02_draft_03.html）		
...


面试题：
document.write("test");
/*var altwrite = document.write;
altwrite("hello");*/
document.write("hello");
//考的是this的指向问题，altwrite()函数改变了write中的this的指向，原本它是指向document，现在让他指向了global或window对象，导致执行时提示非法调用异常。

三种方法解决：
document.write('test');
var altwrite=document.write;
altwrite.bind(document)('hello');
altwrite.call(document,'call');
altwrite.apply(document,['apply']);





(代码参见上面部分)
普通传递：
var test = obj.foo;
test();//"oops,global"
硬绑定传递：
var bar = foo.bind(obj); //硬绑定
bar(); //"2"




function foo() {
	console.log( this.a );
}
function doFoo(fn) {
	// fn其实引用的是foo
	fn(); // <-- 调用位置！
}	
var a = "oops, global";
var obj = {
	a: 2,
	foo: foo
};
//doFoo(obj.foo);//<--普通的传递方式，造成隐式丢失，返回oops,global。
doFoo(foo.bind(obj));//"2"。硬绑定后的传递方式。




硬绑定后的settimeout
function foo() {
	console.log( this.a );
}	
var a = "oops, global"; // a是全局对象的属性
var obj = {
	a: 2,
	foo: foo
};		
//setTimeout(obj.foo,1000);	
setTimeout( foo.bind(obj), 1000 ); // "2"


new绑定
我们重新定义一下javascript中的‘构造函数’。javascript，构造函数只是一些使用new操作符时被调用的函数。
它们并不会属于某个类，也不会实例化一个类。
实际上，它们甚至不能说是一种特殊的函数造型，它们只是被new操作符调用的普通函数。
实际上并不存在所谓的‘构造函数’，只有对于函数的‘构造调用’。
使用new来调用函数，或者说是发生构造函数调用时，对于我们的this来说，
这个新对象会绑定到函数调用的this。
function foo(a) {
	this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
使用new来调用foo(..)时，我们会构造一个新对象把它绑定到foo(..)调用的this上。new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。


绑定规则优先级：
new绑定，
显示绑定，
隐式绑定，
默认绑定。



作用域
定义：
从侠义上来说，作用域是一个对象，也可以说是一个集合。
从广义上说，作用域就是一个规则，比如左查询和右查询。
作用域其实是js的执行环境，是由浏览器和node提供的，所以说作用域就是一个对象，其实就是一个c或c++的对象。

上下文环境：
上下文环境其实就是函数作用域，在函数调用时创建，函数执行完销毁。
上下文环境就是执行环境，执行环境可以分为两大类，一类是全局作用域，一类是函数作用域，全局作用域在script标签创建时创建，在script标签结束时销毁。

左右查询：
左查询：是指变量在等号的左侧。左查询在上下文执行环境中，找不到对变量的声明，js引擎会自动的加上var。
右查询：非左查询的就是右查询。右查询在上下文环境中找不到对变量的声明，就会报错。

typeof的安全机制
typeof得到的是object
typeof得到的是undefined
所以在进行插件编写时，不能在if()中只写变量，万一没有声明就会报错；
但是typeof变量时就不会报错，这是typeof的一个安全机制。
作者在编写js时，希望var obj=null
利用Null来对引用类型进行声明，
var a=undefined来声明基本数据类型。



less+动画

可以这样写：
#wrap{
    xxx:xxx//wrap的css样式
    #inner{
        xxx:xxx//wrap的子元素inner的css样式
    }
}

对比（后两个是特殊的，很不常用）：
@c:red	    --> @c
@wrap:#wrap --> @{wrap}{}
@w:width 	--> @{w}:100px;

画三角形：
//向上的...
width:0;
height:0;
overflow:hidden;
border-width:100px;
border-color:transparent transparent pink transparent;
border-style:dashed dashed solid dashed;//为了兼容IE6，因为它没有transparent属性（具体原理不知道）

用less来画三角形：
//首先设置的是.triangle的共有css样式
.triangle(@_,@w:10px){
	width:100px;
	height:100px;
	overflow:hidden;
}
.triangle(top,@w:10px){//不传参数默认就是10px
	border-width:@w;
	border-color:transparent transparent pink transparent;
	border-style:dashed dashed solid dashed;
}
...(left right bottom的样式写法和top同理)
#sjx1{
	.triangle(top);
}
...(用哪个样式调哪个样式)

这是啥：
.border(@w:20px,@c:black,@style:solid){
	width:100px;
	height:100px;
	background:pink;
	border:@arguments;
}
#wrap{
	.border(30px,deeppink,solid);
}

延迟加载：
.wrap{
	@test:1;
	.inner{
		@test:2;
		width:@test;//3
		@test:3;
	}
	width:@test;//1
}

less里的注释：
//这是见不得人的注释
/*这是可以见人的注释*/

less运算：
@w:100rem;
.wrap{
	width:100/@w;
}

###less
	less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，
	增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展
 
	less的中文官网：http://lesscss.cn/
	bootstrap中关于less的介绍：
 
###Less编译工具
	koala 官网:www.koala-app.com 


用less做一物理像素边框：
.onePx(@_,@c:black){
     position: relative;
     &:before{
        position: absolute;
        content: "";
        display: block;
        width: 100%;
        height: 1px;
        @media only screen and (-webkit-min-device-pixel-ratio:2 ){
             transform: scaleY(.5);
        }
        @media only screen and (-webkit-min-device-pixel-ratio:3 ){
             transform: scaleY(.33333333333);
        }
    }
}
.onePx(top,@c:black){
    &:before{
        top: 0;
        background: @c;
    }
}
.onePx(bottom,@c:black){
    &:before{
        bottom: 0;
        background: @c;
    }
}
#wrap{
    .onePx(top);
    width: 100px;
    height: 100px;
    background: pink;
    margin: 50px;
}


flex

flex的应用
（做个淘宝）
.row{
	display:-webkit-box;
	display:-webkit-flex;
	display:flex;
}
.row .item{
	width:0;//做兼容
	-webkit-box-flex:1;
	flex:1;//最新的，一句顶三句
}


关于DOM的一堆总结
（达姆总结的，直接搬过来的）
###interface description language
	c++：
		class 派生类名 : 继承方式  基类名
		{
			派生类的成员
		};
		继承方式：public、private和protected，默认是public。

###DOM IDL

DOM规范：
###Welcome to use MarkDown
	正如W3C所定义的，DOM是独立于平台和语言的接口，该接口为程序和脚本提供了对文档的内容、
	结构和样式的动态获取和更新的功能。

	DOM的出现来自对动态页面的需求，先有DOM的实现（Netscape DOM0），再有各个厂商对DOM实现规范的需求，
	再有了W3C Activity Statement对于DOM发展的规范，然后才有了我们所说的“DOM”。

	DOM0：不是W3C规范。
	DOM1：开始是W3C规范。专注于HTML文档和XML文档。
	DOM2：对DOM1增加了样式表对象模型(DOM2)
	DOM3：对DOM2增加了内容模型 (DTD 、Schemas) 和文档验证。

	DOM0指的是Necscape3.0和IE3.0提供对于HTML文档功能，实现了包括元素(HTML Element)、表单(Form)、
	图像(Image)等的接口和方法。DOM0虽然年代久远，某些实现并不符合新的DOM理念，但为了向后兼容，
	很多现代浏览器仍然支持DOM0的某些方法和属性。即便某些方法的实现原理有所不同，但提供了可用性。
	DOM0出现后，各厂商意识到DOM的前景，纷纷向W3C建议DOM的规范化。
		于是出现了W3C DOM Activity Statement（DOM的活动清单）以及DOM1、DOM2、DOM3规范(Specification)
	
	DOM1 1.0版本发布于1998年10月1日，是第一个DOM规范。DOM1包含两部分:
		DOM1 Core：定义了DOM最基本的接口，包括Document，Node，NodeList等等。
		DOM1 THML：HTML文档是DOM的一种实现，该规范定义了基于DOM1 Core的HTML文档实现。
	
	DOM2规范在2000年11月13日发布，主要包含6个模块，相比于DOM1，DOM2更加丰富，更加完善，
		目前主流浏览器对DOM2有着良好的支持。
		DOM2 Core: 相比于DOM1 Core，DOM2丰富了Document，Node等接口的功能，
		DOM2 View：View提供的是DOM的表现形式，同一个文档源(document source)，可能有不同的表现形式，
					DOM2 View引入了Abstract View和Document View接口。
		DOM2 Event：DOM 事件处理系统规范，DOM1中并未对DOM的事件模型进行定义，
					在DOM2中规范事件模型(Event Model)主要有两个目的：
						1)设计一套通用的事件系统，实现事件处理程序的注册和注销，描述事件的流动(Event Flow)，
							事件的上下文信息(Contextual Information )等；
						2)提供一套规范子集兼容老版本浏览器DOM0的事件实现。
		DOM2 Style：程序和脚本动态地获取和更新DOM的样式，提供包括Style Sheet, 
					Cascading Style Sheet, CSSRule, CSSStyleDeclaration, getComputedStyle接口。
					DOM2 Style的实现基于DOM2 Core和DOM2 View。
		DOM2 Traverse and Range：DOM2 Traverse是关于文档节点遍历的规范，
					包括Treewalker，NodeIterator和NodeFilter等；
					DOM2 Range是关于DOM片段(Document Fragment)操作的规范，譬如DocumentFragment。
		DOM2 HTML：在DOM1 HTML的基础上结合DOM2 Core推出了一些新的接口和属性

	DOM3首次发布于2004年4月，主要包括Core、Load and Save、Validation、XPath、View and Formatting、
		Events和Abstract Schemas7个模块。目前主流浏览器对DOM3的支持比较有限

DOM事件：
### 两种绑定方式
	(DOM0)1.obj.onclick = fn;	
		
	(DOM2)2.
	  ie:obj.attachEvent(事件名称，事件函数);
		1.没有捕获(非标准的ie 标准的ie底下有  ie6到10)
		2.事件名称有on
		3.事件函数执行的顺序：标准ie-》正序   非标准ie-》倒序
		4.this指向window
	      标准:obj.addEventListener(事件名称，事件函数，是否捕获);
		1.有捕获
		2.事件名称没有on
		3.事件执行的顺序是正序
		4.this触发该事件的对象
		
		
		document.attachEvent('onclick', fn2);
		document.attachEvent('onclick', function() {
			fn1.call(document);
		});
		
		是否捕获 : 默认是false    false:冒泡 true：捕获
		
		document.addEventListener('click', fn1, false);
		document.addEventListener('click', fn2, false);
			
	注意
		ie代表了:非标准ie 和 标准ie
		标准代表了:标准ie 和 chrome Firefox等....

### 同步this
	function bind(obj, evname, fn) {
		if (obj.addEventListener) {//除ie低版本外都可以进入
			obj.addEventListener(evname, fn, false);
		} else {
			obj.attachEvent('on' + evname, function() {
				fn.call(obj);
			});
		}
	}

	bind(document, 'click', fn1);
	

### 两种绑定方式的区别
	取消冒泡的手段:event.cancelBubble = true;
		   	    event.stopPropagation();

	第一种:默认冒泡,
	第一种:一个元素上只能绑定一个同类事件,如果继续绑定的话,第二个事件函数会覆盖第一个
	
	
	第二种: 
		  attachEvent
		  			       默认冒泡
		  addEventListener    
					      是否捕获 : 默认是false    
					      第三个参数: false:冒泡
							    true：捕获
	第二种:一个元素上可以绑定多个同类事件,它们都会被执行


### 事件解绑
	DOM0:想解除事件就相当简单了，只需要再注册一次事件，把值设成null
			原理就是最后注册的事件要覆盖之前的，最后一次注册事件设置成null，
				也就解除了事件绑定。
				
	DOM0事件模型还涉及到直接写在html中的事件:
			因此不会传入event对象，同时，this指向的是window，不再是触发事件的dom对象。
			
	DOM2:removeEventListener
		 	解除事件语法：btn.removeEventListener("事件名称", "事件回调", "捕获/冒泡");
		 detachEvent(ie)
		 	
### 事件流
	单击蓝色框后，开始事件捕获阶段：
		从最外层的document对象（浏览器其实是从window对象开始的）向内捕获事件，路过红色框时，查看到红色框有事件，
		但是红色框说：“我是在冒泡阶段执行，现在是捕获阶段，等你回来再说吧。”
		接下来是黄色框：“我在捕获阶段执行，就是现在执行！在控制台输“黄色框”吧~~”
	接下来到达目标阶段：
		“DOM2级事件”规范要求捕获阶段不会涉及事件目标即我们点击的那个最具体的元素，
		但IE9、Chrome等浏览器都会在捕获阶段触发事件对象上的事件。执行目标对象的事件函数，控制台输出“蓝色框”。
	最后是冒泡阶段：
		由目标对象向外传递，到达黄色框，黄色框说：“我在捕获阶段执行过了，你走吧...”
		然后到达红色框，红色框说：“你终于回来了，现在就执行我的事件！”控制台输出“红色框”。
		然后继续向外传播，直到到达document对象后停止。
	其他：更改了元素绑定事件代码的顺序，执行顺序也和上面表现的一致。

### 总结
	onclick形式:冒泡
	attachEvent:冒泡
	addEventListener:第三个参数(false:冒泡;true:捕获)
	
DOM细节：
###DOM
	1. 节点及其类型:
		1). 元素节点
		2). 属性节点: 元素的属性, 可以直接通过属性的方式来操作. 
		3). 文本节点: 是元素节点的子节点, 其内容为文本. 
		4).	根节点
		
	2. 在 html 文档的什么位置编写 js 代码?
		
		0). 直接在 html 页面中书写代码.
			<button id="button" onclick="alert('hello world');">Click Me!</button>
			缺点: 
				①. js 和 html 强耦合, 不利用代码的维护
				②. 若 click 相应函数是比较复杂的, 则需要先定义一个函数, 然后再在 onclick 属性中完成对函数的引用, 比较麻烦
	
		1). 一般地, 不能在 body 节点之前来直接获取 body 内的节点, 因为此时 html 文档树还没有加载完成, 
		    获取不到指定的节点:
		
		<head>
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
			<title>Untitled Document</title>
			<script type="text/javascript">
				var cityNode = document.getElementById("city");
				//打印结果为 null.
				alert(cityNode);
			</script>
		</head>
		<body>
		......
		
		2). 可以在整个 html 文档的最后编写类似代码, 但这不符合习惯
		
		3). 一般地, 在 body 节点之前编写 js 代码, 但需要利用 window.onload 事件,　
		    该事件在当前文档完全加载之后被触发, 所以其中的代码可以获取到当前文档的任何节点.
		    
		    <head>
				<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
				<title>Untitled Document</title>
				<script type="text/javascript">
					window.onload = function(){
						var cityNode = document.getElementById("city");
						alert(cityNode);
					};
				</script>
			</head>
			<body>
			......
	
	3. 如何来获取元素节点:
	
		1). **document.getElementById: 根据 id 属性获取对应的单个节点
	
		2). **document.getElementsByTagName: 
				根据标签名获取指定节点名字的数组, 数组对象 length 属性可以获取数组的长度
	
		3). document.getElementsByName: 
			根据节点的 name 属性获取符合条件的节点数组, 
			但 ie 的实现方式和 W3C 标准有差别: 
			在 html 文档中若某节点(li)没有 name 属性,　
			则 ie 使用 getElementsByName 不能获取到节点数组, 但火狐可以. 
	
		4). 其它的两个方法,　ie 根本就不支持, 所以不建议使用  
			document.getElementsByClassName();
			document.getElementsByTagNameNS();
		
	4. 获取属性节点:
		1). **可以直接通过 cityNode.id 这样的方式来获取和设置属性节点的值
		
		2). **可以直接通过getAttribute/setAttribute/removeAttribute
					 这样的方式来获取和设置属性节点的值
	
		3). 通过元素节点的 getAttributeNode 方法来获取属性节点,
		         然后在通过 nodeValue 来读写属性值 
		
	5. 获取元素节点的子节点(**只有元素节点才有子节点!!):
		1). childNodes 属性获取全部的子节点, 但该方法不实用. 因为如果要获取指定的节点
		的指定子节点的集合, 可以直接调用元素节点的 getElementsByTagName() 方法来获取. 
		2). firstChild 属性获取第一个子节点
		3). lastChild  属性获取最后一个子节点	
		
		
			获取指定节点的所有子节点.一共有三种方式:
					childNodes属性:
							不实用,会取到文本节点
						children属性: 
							实用,会剔除文本节点
					用该指定节点的getElementsByTagName方法(注意不是document):	
							不实用,虽然会剔除文本节点,但只能取一组相同tagNaem的子节点,无法取全
													
				使用firstChild,lastChild来取一个指定元素节点的第一个和最后一个子节点时
							1.会受到文本子节点的影响
							2.我们通常可以使用firstChild的nodeValue属性来获取文本值(当子节点只有文本节点时)
				
		
	6. 获取文本节点:
		1). 步骤: 元素节点 --> 获取元素节点的子节点
		2). 若元素节点只有文本节点一个子节点, 
		例如 <li id="bj" name="BeiJing">北京</li>, <p>你喜欢哪个城市?</p>, 
		可以先获取到指定的元素节点 eleNode, 
		然后利用 eleNode.firstChild.nodeValue 的方法来读写其文本节点的值		
	
	
	
	7. 节点的属性:
		1). nodeName: 代表当前节点的名字. 只读属性. 
		**如果给定节点是一个文本节点, nodeName 属性将返回内容为 #text 的字符串
		2). nodeType：返回一个整数, 这个数值代表着给定节点的类型. 
		只读属性. 1 -- 元素节点, 2 -- 属性节点, 3 -- 文本节点
	  **3). nodeValue：返回给定节点的当前值(字符串). 可读写的属性
			①. 元素节点, 返回值是 null.
			②. 属性节点: 返回值是这个属性的值
			③. 文本节点: 返回值是这个文本节点的内容	
			
		    
	8. 创建一个元素节点:
		1). createElement(): 按照给定的标签名创建一个新的元素节点. 方法只有一个参数：被创建的元素节点的名字, 是一个字符串.
		                     方法的返回值：是一个指向新建节点的引用指针. 返回值是一个元素节点, 所以它的 nodeType 属性值等于 1.
	                           **新元素节点不会自动添加到文档里, 它只是一个存在于 JavaScript 上下文的对象.
	                         
	9. 创建一个文本节点:
		1). createTextNode(): 创建一个包含着给定文本的新文本节点. 这个方法的返回值是一个指向新建文本节点引用指针. 它是一个文本节点, 所以它的 nodeType 属性等于 3.
		                         方法只有一个参数：新建文本节点所包含的文本字符串. 新元素节点不会自动添加到文档里
		                         
	10. 为元素节点添加子节点:
		1). appendChild(): var reference = element.appendChild(newChild): 给定子节点 newChild 将成为给定元素节点 element 的最后一个子节点.
		                      方法的返回值是一个指向新增子节点的引用指针.		    
		                      
	11. 节点的替换:
		1). replaceChild(): 把一个给定父元素里的一个子节点替换为另外一个子节点
				var reference = element.replaceChild(newChild,oldChild);
				返回值是一个指向已被替换的那个子节点的引用指针
		2). 该节点除了替换功能以外还有移动的功能.  
		3). 该方法只能完成单向替换, 若需要使用双向替换, 需要自定义函数:
		/**
		 * 互换 aNode 和 bNode
		 * @param {Object} aNode
		 * @param {Object} bNode
		 */
		function replaceEach(aNode, bNode){
			
			if(aNode == bNode){
				return;
			}
			
			var aParentNode = aNode.parentNode;
			//若 aNode 有父节点
			if(aParentNode){
				var bParentNode = bNode.parentNode;
				
				//若 bNode 有父节点	
				if(bParentNode){
					var tempNode = aNode.cloneNode(true);
					bParentNode.replaceChild(tempNode, bNode);
					aParentNode.replaceChild(bNode, aNode);	
				}
			}
	
		}   
		
	12. 插入节点:
		1). insertBefore(): 把一个给定节点插入到一个给定元素节点的给定子节点的前面
	  			var reference =  element.insertBefore(newNode,targetNode);
	         节点 newNode 将被插入到元素节点 element 中并出现在节点 targetNode 的前面. 节点 targetNode 必须是 element 元素的一个子节点。	 
	
	    2). 自定义 insertAfter() 方法     
	       /**
		 * 将 newChild 插入到 refChild 的后边
		 * @param {Object} newChild
		 * @param {Object} refChild
		 */
		function insertAfter(newChild, refChild){
			var refParentNode = refChild.parentNode;
			
			//判断 refChild 是否存在父节点
			if(refParentNode){
				//判断 refChild 节点是否为其父节点的最后一个子节点
				if(refChild == refParentNode.lastChild){
					refParentNode.appendChild(newChild);
				}else{
					refParentNode.insertBefore(newChild, refChild.nextSibling);
				}	
			}
		}
	    
	    
	13. 删除节点:
		1). removeChild(): 从一个给定元素里删除一个子节点
	   			var reference = element.removeChild(node);
			返回值是一个指向已被删除的子节点的引用指针. 某个节点被 removeChild() 方法删除时, 这个节点所包含的所有子节点将同时被删除. 
			如果想删除某个节点, 但不知道它的父节点是哪一个, parentNode 属性可以帮忙。    
			
	14. innerHTML属性:
		1). 浏览器几乎都支持该属性, 但不是 DOM 标准的组成部分. innerHTML 属性可以用来读, 写某给定元素里的 HTML 内容	
			
	15. 其它属性, 参看 API: nsextSibling, 	previousSibling 等	           


动画
@keyframes move{
	from{
		transform:rotate(0deg);
	}
	to{
		transform:rotate(360deg);
	}
}
//关键帧：在@keyframe中用百分数来表示
#wrap{
	animation-name:move;
	animation-duration:3s;
	animation-timing-function:ease;
	animation-timing-function:step(3,start);
	animation-delay:2s;
	animation-iteration-count: infinite;//执行无限次
	animation-direction: alternate-reverse;//动画执行的方向
	animation-fill-mode: both;//使元素的起点和终点正好都和动画设置的起点和终点一致
	animation-play-state:running;	
}
#wrap:hover{
	cursor: pointer;
	animation-play-state:paused;
}

兔斯基
animation: move .5s steps(12) infinite;

开机动画（2d）
spanNodes[i].style.animation='move .3s infinite '+(i*0.1)+'s alternate';
//注意其中的空格要写上

开机动画（3d）
document.addEventListener("touchstart",function(ev){
	ev=ev||event;
	ev.preventDefault();
});		
window.onload=function(){
	var textNode = document.querySelector("#text");
	var flag=0;			
	var arr=[];
	for(item in imgData){
		arr=arr.concat(imgData[item]);
	}			
	for(var i=0;i<arr.length;i++){
		var imgNode = new Image();
		imgNode.src=arr[i];
		imgNode.onload=function(){
			flag++;
			textNode.innerHTML="已加载"+Math.round((flag/arr.length)*100)+"%";
		}
	}
}



flex

old-flex:
#wrap{
	//开启
	display:-webkit-box;
	//主轴是谁(横竖转换)
	-webkit-box-orient:horizontal;
	-webkit-box-orient:vertical;
	//项目方向(只是项目的顺序发生改变,在old-flex中轴的方向根本不会发生对调)
	-webkit-box-direction: reverse;
	//主轴的富裕空间
	-webkit-box-pack:start;//对old-flex来说，start就是说，项目在start位置，而空白空间在end位置。
	-webkit-box-pack:end;
	-webkit-box-pack:center;
	-webkit-box-pack:justify;//相当于new-flex中justify-content:space-between;
	//侧轴的富裕空间
	-webkit-box-align:start;
	-webkit-box-align:end;
	-webkit-box-align:center;
}

new-flex:
#wrap{
	//开启
	display:flex;
	//主轴是谁(横竖转换)
	flex-direction:row;
	flex-direction:column;
	//主轴方向(包括项目、富裕空间在内的整个行或列的方向发生改变，即轴发生对调)
	flex-direction:row-reverse;
	flex-direction:column-reverse;
	//主轴的富裕空间(注意flex-start中的start都是相对主轴正方向而言的，所以在主轴方向发生改变之后要注意)
	justify-content:flex-start;
	justify-content:flex-end;
	justity-content:center;
	justify-content:space-between;
	justify-content:space-around;
	//侧轴的富裕空间(主轴调换与否不影响侧轴方向，和flex-old中的没有区别)
	align-items:flex-start;
	align-items:flex-end;
	align-items:center;
	align-items:baseline;
	align-items:stretch;//需要在此方向上不设置长度
	
	//新增属性：
	
	//flex-wrap和align-content会使侧轴像主轴一样布局更灵活，因为align-items中的功能和justify-content中的相比是不够的。
	//控制换行及侧轴方向
	flex-wrap: nowrap;//不换行，挤到一行
	flex-wrap: wrap;//换行，但是形状很奇怪	，从上到下均分整个空间
	flex-wrap: wrap-reverse;//换行，均分，颠倒
	
	//文字排列方向(会使上面flex-wrap换行之后的内容乖乖排到一起)
	align-content:flex-start;
	align-content:flex-end;
	align-content:center;
	align-content:space-around;
	align-content:space-between;
	...
	
	//这是啥
	//这是flex-direction与flex-wrap的结合体
	flex-flow:row wrap;	
}


//order(顺序):
#wrap .item:nth-child(1){
	order: 4;//占第四个位置
}
#wrap .item:nth-child(2){
	order: 5;
}
#wrap .item:nth-child(3){
	order: 3;
}
#wrap .item:nth-child(4){
	order: 2;
}
#wrap .item:nth-child(5){
	order: 1;
}
//order可以为负值，越小越靠前


//align-self:
#wrap{
	align-items:flex-end;
}
#wrap .item:nth-child(1){
	align-self: flex-start;
	//其它都在下面，就这个在上面
	order: 4;
}


flex-old:
#wrap .item{
	-webkit-box-flex: 1;
}
#wrap .item:nth-child(1){
	/*弹性的空间的管理会把富裕空间按比例分配到项目上*/
	-webkit-box-flex: 6;
}


flex-new:
#wrap .item{
	flex-grow:1;
}
#wrap .item:nth-child(1){
	/*弹性的空间的管理会把富裕空间按比例分配到项目上*/
	flex-grow:6;
}


//?
flex-basis: 100px;
flex-shrink: 2;


//等分布局
#wrap{
	display:-webkit-box;
	display:flex;
}
#wrap .item{
	-webkit-box-flex:1;
	flex-grow:1;
	flex-basis:0;
	width:0;
}


色子布局
http://flexboxfroggy.com/

//*****等分布局使用(淘宝)
.wrap{
	display:-webkit-box;
	display:-webkit-flex;
	display:flex;
}
.wrap .item{
	width:0;//做兼容
	-webkit-box-flex:1;
	flex:1;//最新的，一句顶三句
}



angular

单页面应用
SPA
single page application
1.所有的活动都局限于一个页面中；
2.当页面数据发生变化时不会刷新整个页面（局部刷新）；
3.ajax技术进行数据的收发。


ng-app(指令)：告诉angular核心它管理当前标签所包含的整个区域，并且会自动创建$rootScope根作用域对象。
ng-model:将当前输入框的值与谁关联（属性名：属性值），并作为当前作用域对象（$rootScope）的属性。
{{}}（表达式）：显示数据，从作用域对象的指定属性名上取。

  1、表达式：通常有一个返回值，可以放在任何需要值得地方，比如函数调用的参数，一个变量名，一个运算，
  2、语句：通常表示一个完整的执行单位，一段完整的js可执行的代码，有的语句也可以用表达式来执行，叫做表达式语句。
  3、区别：语句用封号结尾，有些语句我们没有加封号，比如console.log虽然我们没有加封号，但也是语句，因为js引擎会自动解析并且加上封号。
  js引擎在解析的时候会自动的加上封号
  4、特例：if语句，就不用加封号  可也是完整的语句

1.AngularJS是什么？
Google开源的 前端JS 结构化 框架；
动态展示页面数据，并与用户进行交互。

2.AngularJS特性和优点：
双向数据绑定；
声明式依赖注入；
解耦应用逻辑，数据模型和视图；
完善的页面指令；
定制表单验证；
Ajax封装。

3.Hello World
导入angular.js,并在页面引入
在<html><body>中ng-app指令
定义ng-model='xxx'/{{xxx}}


<!--
1. 使用Angular表达式:
  * 语法: {{expression}}
  * 作用: 显示表达式的结果数据
  * 注意: 表达式中引用的变量必须是当前域对象有的属性(包括其原型属性)
2. 操作的数据
  * 基本类型数据: number/string/boolean
  * undefined, Infinity, NaN, null解析为空串: "", 不显示任何效果
  * 对象的属性或方法
  * 数组
-->


<!--
1. Angular指令
	* Angular为HTML页面扩展的: 自定义标签属性或标签
	* 与Angular的作用域对象(scope)交互,扩展页面的动态表现力
2. 常用指令(一)
  * ng-app: 指定模块名，angular管理的区域
  * ng-model： 双向绑定，输入相关标签
  * ng-init： 初始化数据
  * ng-click： 调用作用域对象的方法（点击时）
  * ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）
  * ng-bind： 解决使用{{}}显示数据闪屏（在很短时间内显示{{}}）
  * ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域
    * $index, $first, $last, $middle, $odd, $even
  * ng-show: 布尔类型， 如果为true才显示
  * ng-hide: 布尔类型， 如果为true就隐藏
-->


1. **双向数据绑定**
	* View（视图）： 页面（标签、指令，表达式）
	* Model(模型) ：作用域对象（属性、方法）
	* 数据绑定： 数据从一个位置自动流向另一个位置
		* View-->Model
		* Model-->View
	* 单向数据绑定： 只支持一个方向
		* View-->Model  ： ng-init
		（ng-init是设置输入框内默认值的，有点像place-holder，虽然我们可以改变输入框内的文字，但是并没有影响所设置的默认值，即ng-init的内容是受影响的。）
		* Model-->View  : {{name}}
		（{{name}}是直接将表达式name体现在桌面上，不能修改它，所以他也是单向的）
	* 双向数据绑定
		* Model<-->View  : ng-model
		（ng-model相当于一个中介。一方面，从view输入进来的数据，它可以存入到model这个仓库中；另一个方面，它又可以将model中的内容，输出到view上显示）
	* angular是支持双向数据绑定的
2. **依赖注入**
	* 依赖的对象被别人(调用者)自动注入进入
	* 注入的方式;
		* 内部自建：不动态
		* 全局变量：污染全局环境
		* 形参：这种最好
	* angular就是通过声明式依赖注入， 来得到作用域对象
	-命令式：侧重的是过程。就是一行一行写的js代码。
	-声明式：侧重的是结果。像map()这种，类似被封装的js的一种可以在看不到繁杂的js代码的情况下完成指定功能的方法或属性。
	* 形参名不能随便定义（只是针对当前这种写法）
	angular.module('myApp',[])
	  .controller('MyController',['$scope',function($scope){

	  }])
3. ** MVC模式**
  页面与数据完全分离。
  * **M: Model, 即模型**, 在angular中:
    * 为scope
    * 储存数据的容器
    * 提供操作数据的方法
  * **V: View, 即视图**, 在angular中:
    * 为页面
    * 包括: html/css/directive/expression
    * 显示Model的数据
    * 将数据同步到Model
    * 与用户交互
  * **C: Controller, 即控制器**, 在angular中:
    * 为angular的Controller
    * 初始化Model数据
    * 为Model添加行为方法
4. **MVVM模式**
  * M: Model, 即数据模型, 在angular中:
    * 为scope中的各个数据对象
  * V: View, 即视图, 在angular中:
    * 为页面
  * VM: ViewModel, 即视图模型, 在angular中:
    * 为scope对象
  * 在angular中controller不再是架构的核心，在MVVM中只是起辅助作用，用来辅助$scope对象，即VM层

1. **作用域**
	* 是一个js实例对象
	* 这个对象的属性、方法， 页面都可以直接引用、操作
	* ng-app指令： 内部创建一个根作用域（$rootScope）, 是所有其它作用域的父对象
2. **控制器**
	* 也是一个对象，是我们View与Model之间的桥梁
	* 当我们使用了ng-controller指令， 内部就会创建控制器对象
	* 但我们同时得提供控制器的构造函数（必须定义一个$scope的形参）
	* 每定义一个ng-controller指令， 内部就会创建一个新的作用域对象（$scope）, 并自动注入构造函数中,在函数内部可以直接使用
$scope对象。
3. **模块**
	* 也是一个对象
	* 创建模块对象： angular.module('模块名', [依赖的模块])
	* 通过模块添加控制器：
	    * module.controller('MyController', function($scope){//操作$scope的语句})
	* angular的整体设计也是多模块的
		* 核心模块： angular.js
		* 扩展模块： angular-router.js, angular-message.js, angular-animate.js
4. 服务
	* 是什么？ 具有特定功能的对象（object对象、函数，数组，基本类型）
	* 内置服务
		* 都以$开头
		* 引入内置服务： 声明式依赖注入（定义形参）, 你不使用它就存在了
		* 常用的几个：
			* $rootScope
			* $scope
			* $timeout
			* $interval
			* 脏数据检查:
			    * 当angular定义的函数执行完后, 会对scope内的属性进行检查, 如果发现有改变更新界面
			    * 在非angular定义的回调函数执行完后, 不会进行脏数据检查 --->即使更新了scope页面不会同步更新
		* 页面如何能自动更新的？
			* 在内置的一些函数执行完后， angular会进行脏数据检查的操作
			* controller, $timeout()中的回调函数,  $interval()中的回调函数
			* 如果我们在setTimeout()的回调函数中更新scope，是不会进行脏数据检查的，页面不会更新
			

			






ES

ECMA
<!--
1. 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范
2. 而我们学的 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思
3. JS包含三个部分：
	1). ECMAScript（核心）
	2). 扩展==>浏览器端
		* BOM（浏览器对象模型）
		* DOM（文档对象模型）
	3). 扩展==>服务器端
		* Node
4. ES的几个重要版本
	* ES5 : 09年发布
	* ES6(ES2015) : 15年发布, 也称为ECMA2015
	* ES7(ES2016) : 16年发布, 也称为ECMA2016  (变化不大)
-->


## **理解ES**
1. 全称: ECMAScript
2. js语言的规范
3. 我们用的js是它的实现
4. js的组成
  * ECMAScript(js基础)
  * 扩展-->浏览器端
    * BOM
    * DOM
  * 扩展-->服务器端
    * Node.js

## ES5
1. **严格模式**
  * 运行模式: 正常(混杂)模式与严格模式
  * 应用上严格式: 'strict mode';
  * 作用:
    * 使得Javascript在更严格的条件下运行
    * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
    * 消除代码运行的一些不安全之处，保证代码运行的安全
    * 需要记住的几个变化
      * 声明定义变量必须用var
      * 禁止自定义的函数中的this关键字指向全局对象
      * 创建eval作用域, 更安全

2. **JSON对象**
  * 作用: 用于在json对象/数组与js对象/数组相互转换
  * JSON.stringify(obj/arr)
      js对象(数组)转换为json对象(数组)
  * JSON.parse(json)
      json对象(数组)转换为js对象(数组)

3. Object扩展
  * Object.create(prototype[, descriptors]) : 创建一个新的对象
    * 以指定对象为原型创建新的对象
    * 指定新的属性, 并对属性进行描述
      * value : 指定值
      * writable : 标识当前属性值是否是可修改的, 默认为true
      * **get方法** : 用来得到当前属性值的回调函数
      * **set方法** : 用来监视当前属性值变化的回调函数
  * Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性

4. Array扩展
  * Array.prototype.indexOf(value) : 得到值在数组中的第一个下标
  * Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标
  * **Array.prototype.forEach(function(item, index){}) : 遍历数组**
  * **Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组**
  * **Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组**

5. **Function扩展**
  * Function.prototype.bind(obj)
      * 将函数内的this绑定为obj, 并将函数返回
  * 面试题: 区别bind()与call()和apply()?
      * fn.bind(obj) : 指定函数中的this, 并返回函数
      * fn.call(obj) : 指定函数中的this,并调用函数

6. Date扩展
  * Date.now() : 得到当前时间值

## ES6
1. **2个新的关键字**
  * let/const
  * 块作用域
  * 没有变量提升
  * 不能重复定义
  * 值不可变

2. **变量的解构赋值**
  * 将包含多个数据的对象(数组)一次赋值给多个变量
  * 数据源: 对象/数组
  * 目标: {a, b}/[a, b]

3. 各种数据类型的扩展
  * 字符串
    * **模板字符串**
      * 作用: 简化字符串的拼接
      * 模板字符串必须用``
      * 变化的部分使用${xxx}定义
    * contains(str) : 判断是否包含指定的字符串
    * startsWith(str) : 判断是否以指定字符串开头
    * endsWith(str) : 判断是否以指定字符串结尾
    * repeat(count) : 重复指定次数

  * 对象
    * **简化的对象写法**
      ```
      let name = 'Tom';
      let age = 12;
      let person = {
          name,
          age,
          setName (name) {
              this.name = name;
          }
      };
      ```
    * Object.assign(target, source1, source2..) : 将源对象的属性复制到目标对象上
    * Object.is(v1, v2) : 判断2个数据是否完全相等
    * __proto__属性 : 隐式原型属性

  * 数组
    * Array.from(v) : 将伪数组对象或可遍历对象转换为真数组
    * Array.of(v1, v2, v3) : 将一系列值转换成数组
    * find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素
    * findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标
  * 函数
    * **箭头函数**
      * 用来定义匿名函数
      * 基本语法:
        * 没有参数: () => console.log('xxxx')
        * 一个参数: i => i+2
        * 大于一个参数: (i,j) => i+j
        * 函数体不用大括号: 默认返回结果
        * 函数体如果有多个语句, 需要用{}包围
      * 使用场景: 多用来定义回调函数
    * **形参的默认值**
      * 定义形参时指定其默认的值
    * **rest(可变)参数**
      * 通过形参左侧的...来表达, 取代arguments的使用
    * **扩展运算符(...)**
      * 可以分解出数组或对象中的数据

4. set/Map容器结构
  * 容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法
  * 任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)
  * **Set的特点**: 保存多个value, value是不重复 ====>数组元素去重
  * **Map的特点**: 保存多个key--value, key是不重复, value是可以重复的
  * API
    * Set()/Set(arr) //arr是一维数组
    * add(value)
    * delete(value)
    * clear();
    * has(value)
    * size
    *
    * Map()/Map(arr) //arr是二维数组
    * set(key, value)
    * delete(key)
    * clear()
    * has(key)
    * size

5. **for--of循环**
  * 可以遍历任何容器
  * 数组
  * 对象
  * 伪/类对象
  * 字符串
  * 可迭代的对象

6. **Promise**
  * 解决`回调地狱`(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差)
  * 能以同步编码的方式实现异步调用
  * 在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise
  * ES6中定义实现API:
    ```
    // 1. 创建promise对象
    var promise = new Promise(function(resolve, reject){
      // 做异步的操作
      if(成功) { // 调用成功的回调
        resolve(result);
      } else { // 调用失败的回调
        reject(errorMsg);
      }
    })
    // 2. 调用promise对象的then()
    promise.then(function(
      result => console.log(result),
      errorMsg => alert(errorMsg)
    ))
    ```
7. **class类**
  * 用 class 定义一类
  * 用 constructor() 定义构造方法(相当于构造函数)
  * 一般方法: xxx () {}
  * 用extends来定义子类
  * 用super()来父类的构造方法
  * 子类方法自定义: 将从父类中继承来的方法重新实现一遍
  * js中没有方法重载(方法名相同, 但参数不同)的语法

8. **模块化(后面讲)**

## ES7
* 指数运算符: **
* Array.prototype.includes(value) : 判断数组中是否包含指定value


* **区别方法的2种称谓**
  * 静态(工具)方法
    * Fun.xxx = function(){}
  * 实例方法
    * 所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象
    * 某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象

严格模式：
<!--
1. 理解:
  * 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式："严格模式"（strict mode）。
  * 顾名思义，这种模式使得Javascript在更严格的语法条件下运行
2.  目的/作用
	* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
	* 消除代码运行的一些不安全之处，为代码的安全运行保驾护航
	* 为未来新版本的Javascript做好铺垫
3. 使用
  * 在全局或函数的第一条语句定义为: 'use strict';
  * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用
4. 语法和行为改变
	* 必须用var声明变量(否则会报错)
	* 禁止自定义的函数中的this指向window,显示undefined
	  (但是像setTimeout()这种因为不是自定义函数，所以this的指向可以是window)
	* 创建eval作用域
	* 对象不能有重名的属性(报错)
-->

创建eval作用域：
'use strict'
var name='outEval';
eval('var name="inEval";alert(name)');//inEval
console.log(name);//outEval


<!--
1. JSON.stringify(obj/arr)
  * js对象(数组)转换为json对象(数组)
2. JSON.parse(json)
  * json对象(数组)转换为js对象(数组)
-->
obj=JSON.stringify(obj);
console.log(typeof obj);//string
obj=JSON.parse(obj);
console.log(typeof obj);//object


Object扩展：
<!--
ES5给Object扩展了好一些静态方法, 常用的2个:
1. Object.create(prototype, [descriptors])
  * 作用: 以指定对象为原型创建新的对象
  * 为新的对象指定新的属性, 并对属性进行描述
    value : 指定值
    writable : 标识当前属性值是否是可修改的, 默认为true
    get : 用来得到当前属性值的回调函数
    set : 用来监视当前属性值变化的回调函数
2. Object.defineProperties(object, descriptors)
  * 作用: 为指定对象定义扩展多个属性
   * 存取器属性：setter,getter一个用来存值，一个用来取值
-->

1. Object.create(prototype, [descriptors])
var obj={name:'huoShiQiang',age:16};
var obj1={};
obj1=Object.create(obj,{
  gender:{
    value:'male',
    writable:true
  }
});
obj1.gender='very man';
console.log(obj1.gender);

2. Object.defineProperties(object, descriptors)
var obj2={
  firstName:'huo',
  lastName:'shiqiang'
};
Object.defineProperties(obj2,{
  fullName:{//配置对象
    //getter取值。get()在取值的时候才调用
    get:function () {
      return this.firstName+'-'+this.lastName;
    },
    //setter存值。set()在存值的时候才调用
    set:function (data) {
      var names=data.split('-');
      this.firstName=names[0];
      this.lastName=names[1];
    }
  }
});
obj2.fullName='chen-jinyu';
console.log(obj2.fullName);


Array扩展：
var arr=[1,4,6,2,5,6];
console.log(arr.indexOf(6));//2
console.log(arr.lastIndexOf(6));//5
arr.forEach(function (item,index) {
  console.log(item,index);
});
var arr1=arr.map(function (item, index) {
  return item+10;//将arr的每个元素加10，然后赋给arr1
});
var arr2=arr.filter(function (item,index) {
  return item>4;
});


bind()和call()、apply()的区别：
var obj={
  name:'Tom',
  age:18
};
function fun(gender) {
  console.log(this,gender);
}
fun();//window
fun.call(obj,'girl');//obj
fun.apply(obj,['boy']);//obj
//.call()和.apply()的区别在于后者需要用数组的方式引入变量
fun.bind(obj,'man')();//obj
//.bind()和之前两个的最大区别在于：前两个指定this之后就立即执行了，不能用来当回调函数；而bind()则可以。


<!-- ES6 -->

<!--
***let
1. 作用:
  * 与var类似, 用于声明一个变量
2. 特点:
  * 在块作用域内有效
  * 不能重复声明
  * 不会预处理, 不存在提升
3. 应用:
  * 循环遍历加监听
  * 使用let取代var是趋势
-->

常规的：
var btns=document.getElementsByTagName('button');
for(var i=0;i<btns.length;i++){
  btns[i].onclick=function () {
    alert(i);  //3,3,3
  }
}

加个自调函数：
var btns=document.getElementsByTagName('button');
for(var i=0;i<btns.length;i++){
  (function (i) {
    btns[i].onclick=function () {
      alert(i);
    }
  })(i);
}

用个变量保存i:
var btns=document.getElementsByTagName('button');
for(var i=0;i<btns.length;i++){
  btns[i].index=i;
  console.log(typeof btns[i]);
  btns[i].onclick=function () {
    alert(this.index);
  }
}

用let:
let btns=document.getElementsByTagName('button');
for(let i=0;i<btns.length;i++){
  btns[i].onclick=function () {
    alert(i);  //0,1,2
  }
}

const常量关键字：
const sex='男';
//不能改


变量的解构赋值：
<!--
1. 理解:
  * 从对象或数组中提取数据, 并赋值给变量(多个)
2. 对象的解构赋值
  let {n, a} = {n:'tom', a:12}
3. 数组的解构赋值
  let [a,b] = [1, 'atguigu'];
4. 用途
  * 给多个形参赋值
-->

  let obj={name:'huo',age:18};
//  let name=obj.name;
//  let age=obj.age;
  let {name,age}=obj;
  console.log(name,age);//huo 18

  let arr=[1,2,3,'abc','def'];
  let [,,,a,b]=arr;
  console.log(a,b);//abc def

  //没有用解构赋值:
  function person(p) {
    console.log(p.name,p.age);
  }
  person(obj);//huo 18

  //给多个形参赋值:
  function person1({name,age}) {
    console.log(name,age);
  }
  person1(obj);//huo 18



模板字符串：
<!--
1. 模板字符串 : 简化字符串的拼接
  * 模板字符串必须用 `` 包含
  * 变化的部分使用${xxx}定义
-->
let obj={
  name:'shuaiQiang',
  age:18
};
console.log('我叫'+obj.name+'，今年'+obj.age+'岁了');
console.log(`我叫${obj.name}，今年${obj.age}岁了`);



简化的对象写法：

let x=3;
let y=5;
//普通的写法
let obj={
  x:x,
  y:y,
  getPoint:function () {
    return this.x+this.y;
  }
};
//简化的写法
let obj={
  x,
  y,
  getPoint (){
    return this.x+this.y;
  }
};


箭头函数：
<!--
* 作用: 定义匿名函数
* 基本语法:
  * 没有参数: () => console.log('xxxx')
  * 一个参数: i => i+2
  * 大于一个参数: (i,j) => i+j
  * 函数体不用大括号: 默认返回结果
  * 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回
* 使用场景: 多用来定义回调函数

**** 箭头函数的特点：
    1、简洁
    2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this
    3、扩展理解： 箭头函数的this看外层的是否有函数，
        如果有，外层函数的this就是内部箭头函数的this，
        如果没有，则this是window。
-->

let fun = function () {
   console.log('fun()');
};
fun();
//没有形参，并且函数体只有一条语句
let fun1 = () => console.log('fun1()');
//相当于：
//  let fun1 = () => {return console.log('fun1()')};
fun1(); //fun1()  undefined
console.log(fun1());
//一个形参，并且函数体只有一条语句
let fun2 = x => x;
console.log(fun2(5));
//形参是一个以上
let fun3 = (x, y) => x + y;
console.log(fun3(25, 39));//64

//函数体有多条语句
let fun4 = (x, y) => {
    console.log(x, y);
    return x + y;
};
console.log(fun4(34, 48));//82

setTimeout(() => {
    console.log(this);
},1000)

let btn = document.getElementById('btn');
//没有箭头函数
btn.onclick = function () {
   console.log(this);//btn
};

//箭头函数
let btn2 = document.getElementById('btn2');
let obj = {
    name : 'kobe',
    age : 39,
    getName : () => {
        btn2.onclick = ()=> {
            console.log(this);//window
        };
    }
};
obj.getName();

//箭头函数
let btn2 = document.getElementById('btn2');
let obj = {
    name : 'kobe',
    age : 39,
    getName : function(){
        btn2.onclick = ()=> {
            console.log(this);//obj
        };
    }
};
obj.getName();

function Person() {
 this.obj = {
     showThis : () => {
         console.log(this);
     }
 }
}
let fun5 = new Person();
fun5.obj.showThis();



点运算符：
<!--
* 用途
1. rest(可变)参数
    * 用来取代arguments 但比arguments灵活,只能是最后部分形参参数
  function add(...values) {
    let sum = 0;
    for(value of values) {
      sum += value;
    }
    return sum;
  }
2. 扩展运算符
  let arr1 = [1,3,5];
  let arr2 = [2,...arr1,6];
  arr2.push(...arr1);
-->

function fun(...values) {
  console.log(arguments);
  //[1, 2, 3, callee: (...), Symbol(Symbol.iterator): function]
  console.log(values);//比arguments好在：forEach()方法。
  //[1, 2, 3]
  values.forEach(function (item, index) {
    console.log(item);
    //1 2 3
  })
}
fun(1,2,3);


let arr=[2,3,4,5];
let arr1=[1,...arr,6];
console.log(arr1);
//[1, 2, 3, 4, 5, 6]



形参默认值：
function Test(x=6,y=6) {
  this.x=x;
  this.y=y;
}
let test1=new Test(8,8);
console.log(test1);
//Test {x: 8, y: 8}
let test2=new Test();
console.log(test2);
//Test {x: 6, y: 6}




Promise对象

<!--
1. 理解:
  * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)
  * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')
  * ES6的Promise是一个构造函数, 用来生成promise实例
2. 使用promise基本步骤(2步):
  * 创建promise对象
    let promise = new Promise((resolve, reject) => {
        //初始化promise状态为 pending
      //执行异步操作
      if(异步操作成功) {
        resolve(value);//修改promise的状态为fullfilled
      } else {
        reject(errMsg);//修改promise的状态为rejected
      }
    })
  * 调用promise的then()
    promise.then(function(
      result => console.log(result),
      errorMsg => alert(errorMsg)
    ))
3. promise对象的3个状态
  * pending: 初始化状态
  * fullfilled: 成功状态
  * rejected: 失败状态
4. 应用:
  * 使用promise实现超时处理

  * 使用promise封装处理ajax请求
    let request = new XMLHttpRequest();
    request.onreadystatechange = function () {
    }
    request.responseType = 'json';
    request.open("GET", url);
    request.send();
-->

let promise=new Promise((resolve,reject)=>{
  console.log('11');
  setTimeout(function () {
    console.log('22');
    resolve('hahaha');
    reject('hehe');
  },1000);
});
promise
  .then((msg)=>{
    console.log(msg,'success');
  },(error)=>{
    console.log(error,'failed');
  });

//___________________________________________________

function getNews(url) {
  let promise=new Promise((resolve,reject)=>{
    let xmlHttp=new XMLHttpRequest();
    xmlHttp.onreadystatechange=function () {
      if(xmlHttp.readyState==4){
        if(xmlHttp.status===200){
          let value=xmlHttp.responseText;
          resolve(value);
        }else{
          reject('暂时没有新闻推送');
        }
      }
    };
    xmlHttp.open('GET',url);
    xmlHttp.send();
  });
  return promise;
}
getNews('http://localhost:3000/new?id=2')
  .then((msg)=>{
    console.log(msg);
    let commentsUrl=JSON.parse(msg).commentsUrl;
    return getNews('http://localhost:3000'+commentsUrl);
  },(error)=>{
    console.log(error);
  })
  .then((msg)=>{
    console.log(msg);
  },(error)=>{
    console.log(error);
  })




class

<!--
1. 通过class定义类/实现类的继承
2. 在类中通过constructor定义构造方法
3. 通过new来创建类的实例
4. 通过extends来实现类的继承
5. 通过super调用父类的构造方法
6. 重写从父类中继承的一般方法
-->
//1. 通过class定义类
class Person{
 //2. 在类中通过constructor定义构造方法
 constructor(name,age){
   this.name=name;
   this.age=age;
 }
 showMsg(){
   console.log(this.name,this.age);
 }
}
//3. 通过new来创建类的实例
let person1=new Person('wenJingYe',18);
person1.showMsg();
//wenJingYe 18
console.log(person1);
//打印出来的结果： age:18  name:'wenJingYe'  __proto__
//showMsg()这个方法在person1的原型__proto__中

//定义一个子类
//4. 通过extends来实现类的继承
class StarPerson extends Person{
  constructor(name,age,sex){
    //5. 通过super调用父类的构造方法
    super(name,age);
    this.sex=sex;
    this.showMsg=function () {
      console.log(this.name,this.age,this.sex,'in constructor');
    }
  }
  //6. 重写从父类中继承的一般方法
  showMsg(){
    console.log(this.name,this.age,this.sex,'in __proto__');
  }
}
let person2=new StarPerson('huoshiqiang',16,'man');
person2.showMsg();
/*
1.当showMsg()定义在StarPerson的构造器中时，优先执行构造器中的这个方法；
2.其次执行的是在StarPerson的原型（一般方法）；
3.如果上面的都没有，就执行父类的原型中的方法。
*/
console.log(person2);



其它(ES6)：

字符串扩展：
let str='abcdefg';
console.log(str.includes('a'));//true
console.log(str.includes('h'));//false
console.log(str.startsWith('a'));//true
console.log(str.startsWith('d'));//false
console.log(str.endsWith('g'));//true
console.log(str.endsWith('a'));//false
console.log(str.repeat(5));//重复5次


数值扩展：
//  1. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o
console.log(0b1010);//二进制。10
console.log(0o56)//八进制。46
//  2. Number.isFinite(i) : 判断是否是有限大的数
console.log(Number.isFinite(NaN));//false
console.log(Number.isFinite(5));//true
//  3. Number.isNaN(i) : 判断是否是NaN
console.log(Number.isNaN(NaN));//true
console.log(Number.isNaN(5));//false
//  4. Number.isInteger(i) : 判断是否是整数
console.log(Number.isInteger(5.23));//false
console.log(Number.isInteger(3.0));//true
console.log(Number.isInteger(3));//true
//  5. Number.parseInt(str) : 将字符串转换为对应的数值
console.log(Number.parseInt('123abc'));//123
console.log(Number.parseInt('a123bc'));//NaN
//  6. Math.trunc(i) : 直接去除小数部分
console.log(Math.trunc(12.123));//12


数组扩展：
//  1. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组
let btns=document.getElementsByTagName('button');
console.log(btns.length);//3。通过getElementsByTagName()得到的是伪数组
Array.from(btns).forEach(function (item, index) {
  console.log(item,index);
});
//  2. Array.of(v1, v2, v3) : 将一系列值转换成数组
let arr=Array.of(1,'abc',true);
console.log(arr);//转换成了数组
//  3. find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素
let arr1=[1,3,5,4,3,6,7,3];
let result=arr1.find(function (item, index) {
  return item>3;
});
console.log(result);//5
//  4. findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标
let arr2=[1,3,5,4,3,6,7,3];
let result2=arr2.findIndex(function (item, index) {
  return item>5;
});
console.log(result2);//5


对象的扩展：
//  1. Object.is(v1, v2)
//  * 判断2个数据是否完全相等
console.log(Object.is('abc','abc'));//true
console.log(NaN==NaN);//false
console.log(Object.is(NaN,NaN));//true
console.log(0==-0);//true
console.log(Object.is(0,-0));//false
//  2. Object.assign(target, source1, source2..)
//  * 将源对象的属性复制到目标对象上
let obj={name:'huoshiqiang',age:16};
let obj1={};
Object.assign(obj1,obj);
console.log(obj1);//Object{name:'huoshiqiang',age:16}
//  3. 直接操作 __proto__ 属性
//  let obj2 = {};
//  obj2.__proto__ = obj1;
let obj3={name:'chenjinyu',age:40};
let obj4={};
obj4.__proto__=obj3;
console.log(obj4);//Object{}
console.log(obj4.name,obj4.age);//chenjinyu 40


set和map:
//1. Set容器 : 无序不可重复的多个value的集合体
//* Set()
let set=new Set([1,3,4,3,1,6]);
console.log(set);//Set(4){1, 3, 4, 6} --- (不会保留重复的元素)
//* Set(array)
//* add(value)
set.add('abc');
console.log(set,set.size);//Set(5) {1, 3, 4, 6, "abc"}  5
//* delete(value)
set.delete(3);
console.log(set);//Set(4) {1, 4, 6, "abc"}
//* has(value)
console.log(set.has(1));//true
console.log(set.has(2));//false
//* clear()清空
set.clear();

//2. Map容器 : 无序的 key不重复的多个key-value的集合体
//* Map()
let map=new Map([['abc',12][25,'age']]);
console.log(map);//Map(2) {"abc" => 12, 25 => "age"} -- key-value
//* Map(array)
//* set(key, value)//添加
map.set('男','性别');
//* get(key)
console.log(map.get(25));//'age'
//* delete(key)
map.delete('男');
//* has(key)
console.log(map.has('男'));//false
//* clear()清空


for_of循环：
//  for(let value of target){}循环遍历
//  1. 遍历数组
let arr=[1,2,3,4,5];
for(let num of arr){
  console.log(num);
}
//  2. 遍历Set
let set=new Set([1,2,3,4,5]);
for(let num of set){
  console.log(num);
}
//  3. 遍历Map
//  4. 遍历字符串
let str='abcdefg';
for(let num of str){
  console.log(num);
}
//  5. 遍历伪数组
let btns=document.getElementsByTagName('button');
for(let btn of btns){
  console.log(btn.innerHTML);
}



ES7->:

//1. 指数运算符(幂): **
console.log(3**3);//27
//2. Array.prototype.includes(value) : 判断数组中是否包含指定value
let arr=[1,2,3,4,'abc'];
console.log(arr.includes(2));//true
console.log(arr.includes(5));//false

<-ES7

			
	


## 模块化进化史教程
1. 全局function模式
  * module1.js
    ```
    //数据
    let data = 'atguigu.com'

    //操作数据的函数
    function foo() {
      console.log(`foo() ${data}`)
    }
    function bar() {
      console.log(`bar() ${data}`)
    }
    ```
  * module2.js
    ```
    let data2 = 'other data'

    function foo() {  //与另一个模块中的函数冲突了
      console.log(`foo() ${data2}`)
    }
    ```
  * test1.html
    ```
    <script type="text/javascript" src="module1.js"></script>
    <script type="text/javascript" src="module2.js"></script>
    <script type="text/javascript">

      let data = "修改后的数据"
      foo()
      bar()
    </script>
    ```
   * 说明:
      * 全局函数模式: 将不同的功能封装成不同的全局函数
      * 问题: Global被污染了, 很容易引起命名冲突
2. namespace模式
  * module1.js
    ```
    let myModule = {
      data: 'atguigu.com',
      foo() {
        console.log(`foo() ${this.data}`)
      },
      bar() {
        console.log(`bar() ${this.data}`)
      }
    }
    ```
  * module2.js
    ```
    let myModule2 = {
      data: 'atguigu.com2222',
      foo() {
        console.log(`foo() ${this.data}`)
      },
      bar() {
        console.log(`bar() ${this.data}`)
      }
    }
    ```
  * test2.html
    ```
    <script type="text/javascript" src="module2.js"></script>
    <script type="text/javascript" src="module22.js"></script>
    <script type="text/javascript">
      myModule.foo()
      myModule.bar()

      myModule2.foo()
      myModule2.bar()

      myModule.data = 'other data' //能直接修改模块内部的数据
      myModule.foo()

    </script>
    ```
  * 说明
    * namespace模式: 简单对象封装
    * 作用: 减少了全局变量
    * 问题: 不安全
3. IIFE模式
  （IIFE就是立即执行函数，Immediately Invoked Function Expression）
  * module3.js
    ```
    (function (window) {
      //数据
      let data = 'atguigu.com'

      //操作数据的函数
      function foo() { //用于暴露有函数
        console.log(`foo() ${data}`)
      }

      function bar() {//用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }

      function otherFun() { //内部私有的函数
        console.log('otherFun()')
      }

      //暴露行为
      window.myModule = {foo, bar}//给了window一个myModule对象，里面只包含两个函数
    })(window)
    ```
  * test3.html
    ```
    <script type="text/javascript" src="module3.js"></script>
    <script type="text/javascript">
      myModule.foo()
      myModule.bar()
      //myModule.otherFun()  //myModule.otherFun is not a function
      console.log(myModule.data) //undefined 不能访问模块内部数据
      myModule.data = 'xxxx' //不是修改的模块内部的data
      myModule.foo() //没有改变

    </script>
    ```
  * 说明:
    * IIFE模式: 匿名函数自调用(闭包)
    * IIFE : immediately-invoked function expression(立即调用函数表达式)
    * 作用: 数据是私有的, 外部只能通过暴露的方法操作
    * 问题: 如果当前这个模块依赖另一个模块怎么办?
4. IIFE模式增强
  * 引入jquery到项目中
  * module4.js
    ```
    (function (window, $) {
      //数据
      let data = 'atguigu.com'

      //操作数据的函数
      function foo() { //用于暴露有函数
        console.log(`foo() ${data}`)
        $('body').css('background', 'red')
      }

      function bar() {//用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }

      function otherFun() { //内部私有的函数
        console.log('otherFun()')
      }

      //暴露行为
      window.myModule = {foo, bar}
    })(window, jQuery)
    ```
  * test4.html
    ```
    <script type="text/javascript" src="jquery-1.10.1.js"></script>
    <script type="text/javascript" src="module4.js"></script>
    <script type="text/javascript">
      myModule.foo()
    </script>
    ```
  * 说明
    * IIFE模式增强 : 引入依赖
    * 这就是现代模块实现的基石

5. 页面加载多个js的问题
  * 页面:
    ```
    <script type="text/javascript" src="module1.js"></script>
    <script type="text/javascript" src="module2.js"></script>
    <script type="text/javascript" src="module3.js"></script>
    <script type="text/javascript" src="module4.js"></script>
    ```
  * 说明
    * 一个页面需要引入多个js文件
    * 问题:
        * 请求过多
        * 依赖模糊
        * 难以维护
    * 这些问题可以通过现代模块化编码和项目构建来解决




  解决需要引入多个js文件的问题：

  模块化管理/模块化的规范

CommonJs_Node模块化教程：

## Node.js模块化教程
1. 下载安装node.js
2. 创建项目结构
  ```
  |-modules
    |-module1.js
    |-module2.js
    |-module3.js
  |-app.js
  |-package.json
    {
      "name": "commonJS-node",
      "version": "1.0.0"
    }
  ```
3. 下载第三方模块
  * npm install uniq --save
4. 模块化编码
  /*
    暴露的本质是暴露exports对象。
  */

  * module1.js
    ```
    module.exports = {
      foo() {
        console.log('moudle1 foo()')
      }
    }
    ```
  * module2.js
    ```
    module.exports = function () {
      console.log('module2()')
    }
    ```
  * module3.js
    ```
    exports.foo = function () {
      console.log('module3 foo()')
    }

    exports.bar = function () {
      console.log('module3 bar()')
    }
    ```
  * app.js
    ```
    /**
      1. 定义暴露模块:
        module.exports = value;
        exports.xxx = value;
      2. 引入模块:
        var module = require(模块名或模块路径);
     */
    "use strict";
    //引用模块
    let module1 = require('./modules/module1')
    let module2 = require('./modules/module2')
    let module3 = require('./modules/module3')

    let uniq = require('uniq')
    let fs = require('fs')

    //使用模块
    module1.foo()
    module2()
    module3.foo()
    module3.bar()

    console.log(uniq([1, 3, 1, 4, 3]))


    ```
5. 通过node运行app.js
  * 命令: node app.js
  * 工具: 右键-->运行




CommonJs-Browserify模块化教程：


## Browserify模块化使用教程
1. 创建项目结构
  ```
  |-js
    |-dist //打包生成文件的目录
    |-src //源码所在的目录
      |-module1.js
      |-module2.js
      |-module3.js
      |-app.js //应用主源文件
  |-index.html
  |-package.json
    {
      "name": "browserify-test",
      "version": "1.0.0"
    }
  ```
2. 下载browserify
  * 全局: npm install browserify -g
  * 局部: npm install browserify --save-dev
3. 定义模块代码
  * module1.js
    ```
    module.exports = {
      foo() {
        console.log('moudle1 foo()')
      }
    }
    ```
  * module2.js
    ```
    module.exports = function () {
      console.log('module2()')
    }
    ```
  * module3.js
    ```
    exports.foo = function () {
      console.log('module3 foo()')
    }

    exports.bar = function () {
      console.log('module3 bar()')
    }
    ```
  * app.js (应用的主js)
    ```
    //引用模块
    let module1 = require('./module1')
    let module2 = require('./module2')
    let module3 = require('./module3')

    let uniq = require('uniq')

    //使用模块
    module1.foo()
    module2()
    module3.foo()
    module3.bar()

    console.log(uniq([1, 3, 1, 4, 3]))
    ```
* 打包处理js:
  * browserify js/src/app.js -o js/dist/bundle.js
* 页面使用引入:
  ```
  <script type="text/javascript" src="js/dist/bundle.js"></script>
  ```




AMD-RequireJS模块化教程：

## require.js使用教程
1. 下载require.js, 并引入
  * 官网: http://www.requirejs.cn/
  * github : https://github.com/requirejs/requirejs
  * 将require.js导入项目: js/libs/require.js
2. 创建项目结构
  ```
  |-js
    |-libs
      |-require.js
    |-modules
      |-alerter.js
      |-dataService.js
    |-main.js
  |-index.html
  ```
3. 定义require.js的模块代码
  * dataService.js
    ```
    define(function () {
      let msg = 'atguigu.com'

      function getMsg() {
        return msg.toUpperCase()
      }

      return {getMsg}
    })
    ```
  * alerter.js
    ```
    define(['dataService', 'jquery'], function (dataService, $) {
      let name = 'Tom2'

      function showMsg() {
        $('body').css('background', 'gray')
        alert(dataService.getMsg() + ', ' + name)
      }

      return {showMsg}
    })
    ```
4. 应用主(入口)js: main.js
  ```
  (function () {
    //配置
    requirejs.config({
      //基本路径
      baseUrl: "js/",
      //模块标识名与模块路径映射
      paths: {
        "alerter": "modules/alerter",
        "dataService": "modules/dataService",
      }
    })

    //引入使用模块
    requirejs( ['alerter'], function(alerter) {
      alerter.showMsg()
    })
  })()
  ```

5. 页面使用模块:
  <script data-main="js/main" src="js/libs/require.js"></script>

------------------------------------------------------------------------

6. 使用第三方基于require.js的框架(jquery)
  * 将jquery的库文件导入到项目:
    * js/libs/jquery-1.10.1.js
  * 在main.js中配置jquery路径
    ```
    paths: {
              'jquery': 'libs/jquery-1.10.1'
          }
    ```
  * 在alerter.js中使用jquery
    ```
    define(['dataService', 'jquery'], function (dataService, $) {
        var name = 'xfzhang'
        function showMsg() {
            $('body').css({background : 'red'})
            alert(name + ' '+dataService.getMsg())
        }
        return {showMsg}
    })
    ```
------------------------------------------------------------------------

7. 使用第三方不基于require.js的框架(angular)
    * 将angular.js导入项目
    * js/libs/angular.js

  * 在main.js中配置
    ```
    (function () {
      require.config({
        //基本路径
        baseUrl: "js/",
        //模块标识名与模块路径映射
        paths: {
          //第三方库
          'jquery' : './libs/jquery-1.10.1',
          'angular' : './libs/angular',
          //自定义模块
          "alerter": "./modules/alerter",
          "dataService": "./modules/dataService"
        },
        /*
         配置不兼容AMD的模块
         exports : 指定与相对应的模块名对应的模块对象
         */
        shim: {
          'angular' : {
            exports : 'angular'
          }
        }
      })
      //引入使用模块
      require( ['alerter', 'angular'], function(alerter, angular) {
        alerter.showMsg()
        console.log(angular);
      })
    })()
    ```



CMD-SeaJS模块化教程：


## sea.js简单使用教程
1. 下载sea.js, 并引入
  * 官网: http://seajs.org/
  * github : https://github.com/seajs/seajs
  * 将sea.js导入项目: js/libs/sea.js
2. 创建项目结构
  ```
  |-js
    |-libs
      |-sea.js
    |-modules
      |-module1.js
      |-module2.js
      |-module3.js
      |-module4.js
      |-main.js
  |-index.html
  ```
3. 定义sea.js的模块代码
  * module1.js
    ```
    define(function (require, exports, module) {
      //内部变量数据
      var data = 'atguigu.com'
      //内部函数
      function show() {
        console.log('module1 show() ' + data)
      }

      //向外暴露
      exports.show = show
    })
    ```
  * module2.js
    ```
    define(function (require, exports, module) {
      module.exports = {
        msg: 'I Will Back'
      }
    })
    ```
  * module3.js
    ```
    define(function (require, exports, module) {
      const API_KEY = 'abc123'
      exports.API_KEY = API_KEY
    })
    ```
  * module4.js
    ```
    define(function (require, exports, module) {
      //引入依赖模块(同步)
      var module2 = require('./module2')

      function show() {
        console.log('module4 show() ' + module2.msg)
      }

      exports.show = show
      //引入依赖模块(异步)
      require.async('./module3', function (m3) {
        console.log('异步引入依赖模块3  ' + m3.API_KEY)
      })
    })
    ```
  * main.js : 主(入口)模块
    ```
    define(function (require) {
      var m1 = require('./module1')
      var m4 = require('./module4')
      m1.show()
      m4.show()
    })
    ```
4. index.html:
  ```
  <!--
  使用seajs:
    1. 引入sea.js库
    2. 如何定义导出模块 :
      define()
      exports
      module.exports
    3. 如何依赖模块:
      require()
    4. 如何使用模块:
      seajs.use()
  -->
  <script type="text/javascript" src="js/libs/sea.js"></script>
  <script type="text/javascript">
    seajs.use('./js/modules/main')
  </script>
  ```


ES6模块化教程：
## ES6-Babel-Browserify使用教程
1. 定义package.json文件
  ```
  {
    "name" : "es6-babel-browserify",
    "version" : "1.0.0"
  }
  ```
2. 安装babel-cli, babel-preset-es2015和browserify
    * npm install babel-cli browserify -g
	* npm install babel-preset-es2015 --save-dev
	* preset 预设(将es6转换成es5的所有插件打包)
3. 定义.babelrc文件
	```
	{
    "presets": ["es2015"]
  }
	```
4. 编码
  * js/src/module1.js  分别暴露
    ```
    export function foo() {
      console.log('module1 foo()');
    }
    export function bar() {
      console.log('module1 bar()');
    }
    export const DATA_ARR = [1, 3, 5, 1]
    ```
  * js/src/module2.js  统一暴露
    ```
    let data = 'module2 data'

    function fun1() {
      console.log('module2 fun1() ' + data);
    }

    function fun2() {
      console.log('module2 fun2() ' + data);
    }

    export {fun1, fun2}
    ```
  * js/src/module3.js
    ```
    export default {
      name: 'Tom',
      setName: function (name) {
        this.name = name
      }
    }
    ```
  * js/src/app.js
    ```
    import {foo, bar} from './module1'
    import {DATA_ARR} from './module1'
    import {fun1, fun2} from './module2'
    import person from './module3'

    import $ from 'jquery'

    $('body').css('background', 'red')

    foo()
    bar()
    console.log(DATA_ARR);
    fun1()
    fun2()

    person.setName('JACK')
    console.log(person.name);
    ```
5. 编译
  * 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib
  * 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js
6. 页面中引入测试
  ```
  <script type="text/javascript" src="js/lib/bundle.js"></script>
  ```
7. 引入第三方模块(jQuery)
  1). 下载jQuery模块:
    * npm install jquery@1 --save
  2). 在app.js中引入并使用
    ```
    import $ from 'jquery'
    $('body').css('background', 'red')
    ```


小结：

## JS模块化
* 模块化的理解
* 什么是模块?
  * 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
  * 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信
* 一个模块的组成
  * 数据--->内部的属性
  * 操作数据的行为--->内部的函数
* 模块化
  * 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目
* 模块化的进化‘过程
  * 全局function模式 :
    * 编码: 全局变量/函数
    * 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全

  * namespace模式 :
    * 编码: 将数据/行为封装到对象中
    * 解决: 命名冲突(减少了全局变量)
    * 问题: 数据不安全(外部可以直接修改模块内部的数据)
  * IIFE模式/增强
    * IIFE : 立即调用函数表达式--->匿名函数自调用
    * 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
    * 引入依赖: 通过函数形参来引入依赖模块
      ```
      (function(window, module2){
        var data = 'atguigu.com'
        function foo() {
           module2.xxx()
           console.log('foo()'+data)
        }
        function bar() {
           console.log('bar()'+data)
        }

        window.module = {foo}
      })(window, module2)
      ```
* 模块化规范
  * CommonJS
    * Node.js : 服务器端
    * Browserify : 浏览器端    也称为js的打包工具
    * 基本语法:
      /*
        暴露的本质是暴露exports对象中的内容。
      */
      * 定义暴露模块 : exports
        ```
        exports.xxx = value
        module.exports = value
        ```
      引入模块 : require
        ```
        var module = require('模块名/模块相对路径')
        ```
    * 引入模块发生在什么时候?
      * Node : 运行时, 动态同步引入
      * Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),
                  运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块
  * AMD : 浏览器端
    * require.js
    * 基本语法
      * 定义暴露模块: define([依赖模块名], function(){return 模块对象})
      * 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2){//使用模块对象})
      * 配置:
        ```
        require.config({
          //基本路径
          baseUrl : 'js/',
          //标识名称与路径的映射
          paths : {
            '模块1' : 'modules/模块1',
            '模块2' : 'modules/模块2',
            'angular' : 'libs/angular',
            'angular-messages' : 'libs/angular-messages'
          },
          //非AMD的模块
          shim : {
            'angular' : {
                exports : 'angular'
            },
            'angular-messages' : {
                exports : 'angular-messages',
                deps : ['angular']
            }
          }
        })
        ```
  * CMD : 浏览器端
    * sea.js
    * 基本语法
      * 定义暴露模块:
        ```
        define(function(require, module, exports){
          通过require引入依赖模块
          通过module/exports来暴露模块
          exports.xxx = value
        })
        ```
      * 使用模块seajs.use(['模块1', '模块2'])
  * ES6
    * ES6内置了模块化的实现
    * 基本语法
      * 定义暴露模块 : export
        * 暴露一个对象:
          ```
          export default 对象
          ```
        * 暴露多个:
          ```
          export var xxx = value1
          export let yyy = value2

          var xxx = value1
          let yyy = value2
          export {xxx, yyy}
          ```

      * 引入使用模块 : import
        * default模块:
          ```
          import xxx  from '模块路径/模块名'
          ```
        * 其它模块
          ```
          import {xxx, yyy} from '模块路径/模块名'
          import * as module1 from '模块路径/模块名'
          ```
    * 问题: 所有浏览器还不能直接识别ES6模块化的语法
    * 解决:
        * 使用Babel将ES6--->ES5(使用了CommonJS) ----浏览器还不能直接支行
        * 使用Browserify--->打包处理----浏览器可以运行






项目构建工具


grunt快速入门教程



* Grunt介绍
  * 中文主页 : http://www.gruntjs.net/
  * 是一套前端**自动化构建**工具，一个基于nodeJs的命令行工具
  * 它是一个**任务运行器**, 配合其丰富强大的**插件**
  * 常用功能:
    * **合并文件**(js/css)
    * **压缩文件**(js/css)
    * **语法检查**(js)
    * **less/sass预编译处理**
    * 其它...
* 安装nodejs, 查看版本
  ```
  node -v
  ```
* 创建一个简单的应用grunt_test
  ```
  |- build----------构建生成的文件所在的文件夹
  |- src------------源码文件夹
      |- js---------------js源文件夹
      |- css--------------css源文件夹
  |- index.html-----页面文件
  |- Gruntfile.js---grunt配置文件(注意首字母大写)
  |- package.json---项目包配置文件
      {
        "name": "grunt_test",
        "version": "1.0.0"
      }
  ```
* 全局安装 grunt-cli  (cli是命令行，安装了就可以使用它的命令了，这种一般是全局安装)
  ```
  npm install -g grunt-cli
  ```
* 安装grunt
  ```
  npm install grunt --save-dev

  ```
* 运行构建项目命令
  ```
  grunt  //提示 Warning: Task "default" not found
  ```
* 配置文件: Gruntfile.js
  * 此配置文件本质就是一个node函数类型模块
  * 配置编码包含3步:
    1. 初始化插件配置
    2. 加载插件任务
    3. 注册构建任务
  * 基本编码:
    ```
    module.exports = function(grunt){
      // 1. 初始化插件配置
      grunt.initConfig({
          //主要编码处
      });
      // 2. 加载插件任务
      // grunt.loadNpmTasks('grunt-contrib-concat');
      // 3. 注册构建任务
      grunt.registerTask('default', []);
    };
    ```
  * 命令: grunt  //提示成功, 但没有任何效果(还没有使用插件定义任务)
* Grunt插件介绍
  * grunt官网的插件列表页面 http://www.gruntjs.net/plugins
  * 插件分类:
    * grunt团队贡献的插件 : 插件名大都以contrib-开头
    * 第三方提供的插件 : 大都不以contrib-开头
  * 常用的插件:
    * grunt-contrib-clean——清除文件(打包处理生成的)
    * grunt-contrib-concat——合并多个文件的代码到一个文件中
    * grunt-contrib-uglify——压缩js文件
    * grunt-contrib-jshint——javascript语法错误检查；
    * grunt-contrib-cssmin——压缩/合并css文件
    * grunt-contrib-htmlmin——压缩html文件
    * grunt-contrib-imagemin——压缩图片文件(无损)
    * grunt-contrib-copy——复制文件、文件夹
    * **grunt-contrib-requirejs**——合并压缩requirejs管理的所有js模块文件
    * grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行
* 合并js: 使用concat插件
  * 命令:
    ```
    npm install grunt-contrib-concat --save-dev
    ```
  * 编码:
    * src/js/test1.js
      ```
      (function () {
        function add(num1, num2) {
          return num1 + num2;
        }
        console.log(add(10, 20));
      })();
      ```
    * src/js/test2.js
      ```
      (function () {
        var arr = [2,3,4].map(function (item, index) {
          return item+1;
        });
        console.log(arr);
      })();
      ```
  * 配置: Gruntfile.js
    * 配置任务:
       ```
       concat: {
         options: { //可选项配置
           separator: ';'   //使用;连接合并
         },
         build: { //此名称任意
           src:  ["src/js/*.js"],  //合并哪些js文件
           dest: "build/js/built.js" //输出的js文件
         }
       }
       ```
    * 加载插件:
      ```
      grunt.loadNpmTasks('grunt-contrib-concat');
      ```
    * 注册任务:
      ```
      grunt.registerTask('default', ['concat']);
      ```
    * 命令:
      ```
      grunt   //会在build下生成一个built.js
      ```
* 压缩js: 使用uglify插件
  * 下载
    ```
    npm install grunt-contrib-uglify --save-dev
    ```
  * 配置: Gruntfile.js
    * 配置任务:
      ```
      pkg : grunt.file.readJSON('package.json'),
      uglify : {
        options: {  //不是必须的
          banner: '/*! <%= pkg.name %> - v<%= pkg.version %> - ' +
          '<%= grunt.template.today("yyyy-mm-dd") %> */'
        },
        build: {
          files: {
            'build/js/built-<%=pkg.name%>-<%=pkg.version%>.min.js': ['build/js/built.js']
          }
        }
      }
      ```
    * 加载任务:
      ```
      grunt.loadNpmTasks('grunt-contrib-uglify');
      ```
    * 注册任务:
      ```
      grunt.registerTask('default', ['concat', 'uglify']);
      ```
    * 命令:
      ```
      grunt   //会在build下生成一个压缩的js文件
      ```
* js语法检查: 使用jshint插件
  * 命令:
    ```
    npm install grunt-contrib-jshint --save-dev
    ```
  * 编码: .jshintrc
     ```
     {
       "curly": true,
       "eqeqeq": true,
       "eqnull": true,
       "expr" : true,
       "immed": true,
       "newcap": true,
       "noempty": true,
       "noarg": true,
       "regexp": true,
       "browser": true,
       "devel": true,
       "node": true,
       "boss": false,

       //不能使用未定义的变量
       "undef": true,
       //语句后面必须有分号
       "asi": false,
       //预定义不检查的全局变量
       "predef": [ "define", "BMap", "angular", "BMAP_STATUS_SUCCESS"]
     }
     ```
  * 修改src/js/test1.js
    ```
    (function () {
      function add(num1, num2) {
        num1 = num1 + num3
        return num1 + num2;
      }
      console.log(add(10, 20));
    })();
    ```
  * 配置 : Gruntfile.js
    * 配置任务:
      ```
      jshint : {
        options: {
          jshintrc : '.jshintrc' //指定配置文件
        },
        build : ['Gruntfile.js', 'src/js/*.js'] //指定检查的文件
      }
      ```
    * 加载任务:
      ```
      grunt.loadNpmTasks('grunt-contrib-jshint');
      ```
    * 注册任务:
      ```
      grunt.registerTask('default', ['concat', 'uglify', 'jshint']);
      ```
    * 命令:
      ```
      grunt   //提示变量未定义和语句后未加分号 -->修改后重新编译
      ```
* 使用cssmin插件
  * 安装:
    ```
    npm install grunt-contrib-cssmin --save-dev
    ```
  * 编码:
    * test1.css
      ```
      #box1 {
        width: 100px;
        height: 100px;
        background: red;
      }
      ```
    * test2.css
      ```
      #box2 {
        width: 200px;
        height: 200px;
        background: blue;
      }
      ```
    * index.html
      ```
      <link rel="stylesheet" href="build/css/output.min.css">
      <div id="box1"></div>
      <div id="box2"></div>
      ```

  * 配置 : Gruntfile.js
    * 配置任务:
      ```
      cssmin:{
        options: {
          shorthandCompacting: false,
          roundingPrecision: -1
        },
        build: {
          files: {
              'build/css/output.min.css': ['src/css/*.css']
          }
        }
      }
      ```
    * 加载任务:
      ```
      grunt.loadNpmTasks('grunt-contrib-cssmin');
      ```
    * 注册任务:
      ```
      grunt.registerTask('default', ['concat', 'uglify', 'jshint', 'cssmin']);
      ```
    * 命令:
      ```
      grunt    //在build/css/下生成output.min.css
      ```
* 使用watch插件（真正实现自动化）
  * 命令: npm install grunt-contrib-watch --save-dev
  * 配置 : Gruntfile.js

    * 配置任务:
      ```
      watch : {
        scripts : {
          files : ['src/js/*.js', 'src/css/*.css'],
          tasks : ['concat', 'jshint', 'uglify', 'cssmin'],
          options : {spawn : false}
        }
      }
      ```
    * 加载任务:
      ```
      grunt.loadNpmTasks('grunt-contrib-watch');
      ```
    * 注册任务:
      ```
      grunt.registerTask('default', ['concat', 'uglify', 'jshint', 'watch']);
      改进：
      grunt.registerTask('default', ['concat', 'uglify', 'jshint']);
      grunt.registerTask('myWatch', ['default','watch']);
      ```
    * 命令:
      ```
      grunt   //控制台提示watch已经开始监听, 修改保存后自动编译处理
      ```




gulp快速入门教程



* Gulp介绍
  * 中文主页: http://www.gulpjs.com.cn/
  * gulp是与grunt功能类似的**前端项目构建**工具, 也是基于Nodejs的自动**任务运行器**
  * 能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的
    合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务
  * gulp更高效(异步多任务), 更易于使用, 插件高质量
* 安装 nodejs, 查看版本: node -v
* 创建一个简单的应用gulp_test
  ```
  |- dist
  |- src
    |- js
    |- css
    |- less
  |- index.html
  |- gulpfile.js-----gulp配置文件
  |- package.json
    {
      "name": "gulp_test",
      "version": "1.0.0"
    }
  ```
* 安装gulp:
  * 全局安装gulp
    ```
    npm install gulp -g
    ```
  * 局部安装gulp
    ```
    npm install gulp --save-dev
    ```
  * 配置编码: gulpfile.js
    ```
    //引入gulp模块
    var gulp = require('gulp');
    //定义默认任务
    gulp.task('任务名', function() {
      // 将你的任务的任务代码放在这
    });
    gulp.task('default', ['任务'])//异步执行
    ```
  * 构建命令:
    ```
    gulp
    ```
* 使用gulp插件
  * 相关插件:
    * gulp-concat : 合并文件(js/css)
    * gulp-uglify : 压缩js文件
    * gulp-rename : 文件重命名
    * gulp-less : 编译less
    * gulp-clean-css : 压缩css
    * gulp-livereload : 实时自动编译刷新
  * 重要API
    * gulp.src(filePath/pathArr) :
      * 指向指定路径的所有文件, 返回文件流对象
      * 用于读取文件
    * gulp.dest(dirPath/pathArr)
      * 指向指定的所有文件夹
      * 用于向文件夹中输出文件
    * gulp.task(name, [deps], fn)
      * 定义一个任务
    * gulp.watch()
      * 监视文件的变化
  * 处理js
    * 创建js文件
      * src/js/test1.js
        ```
        (function () {
          function add(num1, num2) {
            var num3 = 0;
            num1 = num2 + num3;
            return num1 + num2;
          }
          console.log(add(10, 30));
        })();
        ```
      * src/js/test2.js
        ```
        (function () {
          var arr = [2,3,4].map(function (item, index) {
              return item+1;
          });
          console.log(arr);
        })();
        ```
    * 下载插件:
      ```
      npm install gulp-concat gulp-uglify gulp-rename --save-dev
      ```
    * 配置编码
      ```
      var concat = require('gulp-concat');
      var uglify = require('gulp-uglify');
      var rename = require('gulp-rename');

      gulp.task('minifyjs', function() {
          return gulp.src('src/js/*.js') //操作的源文件
              .pipe(concat('built.js')) //合并到临时文件
              .pipe(gulp.dest('dist/js')) //生成到目标文件夹
              .pipe(rename({suffix: '.min'})) //重命名
              .pipe(uglify())    //压缩
              .pipe(gulp.dest('dist/js'));
      });

      gulp.task('default', ['minifyjs']);
      ```
    * 页面引入js浏览测试 : index.html
      ```
      <script type="text/javascript" src="dist/js/built.min.js"></script>
      ```
    * 打包测试: gulp
  * 处理css
    * 创建less/css文件
      * src/css/test1.css
        ```
        #div1 {
          width: 100px;
          height: 100px;
          background: green;
        }
        ```
      * src/css/test2.css
        ```
        #div2 {
          width: 200px;
          height: 200px;
          background: blue;
        }
        ```
      * src/less/test3.less
        ```
        @base: yellow;
        .index1 { color: @base; }
        .index2 { color: green; }
        ```
    * 下载插件:
      ```
      npm install gulp-less gulp-clean-css --save-dev
      ```
    * 配置编码
      ```
      var less = require('gulp-less');
      var cleanCSS = require('gulp-clean-css');

      //less处理任务
      gulp.task('lessTask', function () {
        return gulp.src('src/less/*.less')
            .pipe(less())

            .pipe(gulp.dest('src/css'));
      })
      //css处理任务, 指定依赖的任务
      gulp.task('cssTask',['lessTask'], function () {

        return gulp.src('src/css/*.css')
            .pipe(concat('built.css'))
            .pipe(gulp.dest('dist/css'))
            .pipe(rename({suffix: '.min'}))
            .pipe(cleanCSS({compatibility: 'ie8'}))
            .pipe(gulp.dest('dist/css'));
      });

      gulp.task('default', ['minifyjs', 'cssTask']);
      ```
    * 页面引入css浏览测试 : index.html
      ```
      <link rel="stylesheet" href="dist/css/built.min.css">
      <div id="div1" class="index1">div1111111</div>
      <div id="div2" class="index2">div2222222</div>
      ```
    * 打包测试: gulp
  * 处理html
      * 下载插件:
        ```
        npm install gulp-htmlmin --save-dev
        ```
      * 配置编码
        ```
        var htmlmin = require('gulp-htmlmin');
        //压缩html任务
        gulp.task('htmlMinify', function() {
            return gulp.src('index.html')
                .pipe(htmlmin({collapseWhitespace: true}))
                .pipe(gulp.dest('dist'));
        });
        gulp.task('default', ['minifyjs', 'cssTask', 'htmlMinify']);
        ```
      * 修改页面引入
        ```
        <link rel="stylesheet" href="css/built.min.css">
        <script type="text/javascript" src="js/built.min.js"></script>
        ```
      * 打包测试: gulp
  * 自动编译
    * 下载插件
      ```
      npm install gulp-livereload --save-dev
      ```
    * 配置编码:
      ```
      var livereload = require('gulp-livereload');

      //所有的pipe
      .pipe(livereload());

      gulp.task('watch', ['default'], function () {
        //开启监视
        livereload.listen();
        //监视指定的文件, 并指定对应的处理任务
        gulp.watch('src/js/*.js', ['minifyjs'])
        gulp.watch(['src/css/*.css','src/less/*.less'], ['cssTask','lessTask']);
      });
      ```

    * 热加载(实时加载)
        * 下载插件：gulp-connect
        ```
        1、 npm install gulp-connect --save-dev
        2、 注册 热加载的任务 server，注意依赖build任务
        3、注册热加载的任务
            //配置加载的选项
            connect.server({
                  root : 'dist/',//监视的源目标文件路径
                  livereload : true,//是否实时刷新
                  port : 5000//开启端口号
             });
             // 自动开启链接
             open('http://localhost:5000');//npm install open --save-dev
             // 监视目标文件
            gulp.watch('src/js/*.js', ['js']);
            gulp.watch(['src/css/*.css', 'src/css/*.less'], ['cssMin', 'less']);
        ```

    * 扩展
        * 打包加载gulp插件
        * 前提：将插件下载好。
        * 下载打包插件： gulp-load-plugins
        * npm install gulp-load-plugins --save-dev
        * 引入： var $ = require('gulp-load-plugins')();！！！引入的插件是个方法，必须记住调用。
        * 神来之笔：其他的插件不用再引入了
        * 使用方法：
            ```
            * 所有的插件用 $ 引出，其他插件的方法名统一为插件的功能名字(即插件名字的最后一部分)：如：concat,connect,cssmin...
            gulp.task('lib', function() {
              gulp.src('bower_components/**/*.js')
              .pipe(gulp.dest(app.devPath + 'vendor'))
              .pipe(gulp.dest(app.prdPath + 'vendor'))
              .pipe($.connect.reload());
            });

            ```



webpack快速入门教程：


* 了解Webpack相关
  * 什么是webpack
    * Webpack是一个模块打包器(bundler)。
    * 在Webpack看来, 前端的所有资源文件(js/css/img/less/...)都会作为模块处理
    * 它将根据模块的依赖关系进行静态分析，生成对应的静态资源
  * 理解Loader
    * Webpack 本身只能加载JS模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载
    * Loader 本身也是运行在 node.js 环境中的 JavaScript 模块
    * 它本身是一个函数，接受源文件作为参数，返回转换的结果
    * loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。
  * 配置文件(默认)
    * webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象
  * 插件
    * 插件件可以完成一些loader不能完成的功能。
    * 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。
    * Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件
* 学习文档 :
  * webpack官方入门: http://webpack.github.io/docs/tutorials/getting-started/
  * Webpack中文指南: http://zhaoda.net/webpack-handbook/index.html
* 你将学到:
  * How to install webpack
  * How to use webpack
  * How to use loaders
  * How to use the development server
  * How to use image
* 初始化项目: package.json
  ```
  {
    "name": "webpack_test",
    "version": "1.0.0"
  }
  ```
* 安装webpack
  ```
  npm install webpack@1 -g  //全局安装
  npm install webpack@1 --save-dev  //局部安装
  ```
* 开始编译
  * 创建入口src/js/ : entry.js
    ```
    document.write("entry.js is work");
    ```
  * 创建主页面 build/: index.html
    ```
    <script type="text/javascript" src="js/build.js"></script>
    ```
  * 编译js
    ```
    webpack src/js/entry.js build/js/build.js
    ```
  * 查看页面效果
* 第二个js
  * 创建第二个js: src/js/content.js
    ```
    module.exports = " <br> It works from content.js";
    ```
  * 更新入口js : entry.js
    ```
    * document.write("entry.js is works.");
    * document.write(require("./content.js"));
    ```
  * 编译js:
    ```
    webpack src/js/entry.js build/js/build.js
    ```
  * 查看页面效果
  npm install webpack-dev-server -g            ????????????????
* 第一个加载器(loader)
  * 安装样式的loader
    ```
    npm install css-loader style-loader --save-dev
    ```
  * 创建样式文件: src/css/test.css
    ```
    body {
      background: red;
    }
    ```
  * 更新入口js : entry.js
    ```
    + require("style-loader!css-loader!../css/test.css");//前面的+不能省???
    * document.write("entry.js is works.");
    * document.write(require("./content.js"));
    ```
  * 编译js, 并查看页面效果
    ```
    webpack src/js/entry.js build/js/build.js
    ```
* 绑定加载器
  * 更新入口js : entry.js
    ```
    - require("style-loader!css-loader!./test.css");
    + require("./test.css");
    ```
  * 编译:
    ```
    webpack src/js/entry.js build/js/build.js --module-bind css=style-loader!css-loader
    ```
  * 查看页面效果
* 使用webpack配置文件
  * 创建webpack.config.js
    ```
    module.exports = {
      entry: "./src/js/entry.js",//入口路径配置
      output: {//出口配置
          path: __dirname + '/build/js',//输出路径
          filename: "bundle.js"//输出文件名
      },
      module: {
        loaders: [//模块加载器配置
          { test: /\.css$/, loader: "style!css"}  //所有css文件声明使用css-loader和style-loader加载器
        ]
      }
    };
    ```
  * 编译
    ```
    webpack
    webpack --progress   //编译显示进度
    ```
  * 问题---每次修改模块文件内容的重新手动打包，刷新
  * 自动编译
    ```
    webpack --watch  //编译并启动监视(但需要刷新浏览器)

    ```
  * 浏览器自动刷新(热加载)----解决手动刷新浏览器问题
    ```
    npm install webpack-dev-server@1 -g
    webpack-dev-server
      访问: http://localhost:8080/webpack-dev-server/
          ; http://localhost:8080
      !!!发现问题----访问的是文件夹路径而不是页面
        devServer:{
              contentBase: './build',//内置服务器动态加载页面所在的目录
              historyApiFallback:true,//不跳转
              inline:true
          }

        contentBase : 默认webpack-dev-server为根文件夹提供内置的服务，如果其他目录下的文件
                      提供服务需要在此设置目录(我们设置为build文件夹)
        historyApiFallback : 开发单页面的时候非常有用，它依赖于H5的 history API，当
                            设置为true的时候所有的跳转都指向index.html；
        port：可以设置端口号，不设置时候默认为 8080
        inline ： 设置为true的时候回自动刷新(有的版本需要配合hot : true使用)

      webpack-dev-server
      访问: http://localhost:8080

     问题：页面没有热加载，自动刷新，因为index的src引入的硬盘中的build文件而不是webpack-dev-server服务器内存中的build
    特点:
      自动编译并刷新界面
      不生成编译后的文件, 直接在内存中编译处理, 并启动服务器运行项目
    ```
* 加载图片
    * 安装依赖的loader
      ```
      npm install url-loader file-loader --save-dev
      url-loader比file-loader功能更加完善是对file-loader的上层封装,但二者需配合使用
      ```
    * 添加config中loader的配置
      ```
      { test: /\.(png|jpg)$/, loader: "url-loader?limit=8192" }  //如果图片小于limit就会进行Base64编码
      ```
    * 拷入2张图片:
      * 小图: img/logo.png
      * 大图: img/big.jpg
    * 定义引用图片的样式: test.css
      ```
      #box1{
        background-image: url(../img/logo.jpg);
        height: 200px;
        width: 200px;
      }
      #box2{
        background-image: url(../img/big.jpg);
        height: 200px;
        width: 200px;
      }
      ```
    * 在页面引用样式或图片: index.html
      ```
      <div id="box1"></div>
      <div id="box2"></div>
      ```
    * 编译并浏览
      ```
      webpack-dev-server
      ```
    * 图片打包问题
        ```
        1、图片大于8kb的时候无法打包到js文件中，
        2、index.html引入js的时候发现没有打包进去的图片路径不对
        3、解决方法：
            * //publicPath : './js/',//webpack的绝对路径,设置服务index.html资源的路径
        ```
* 配置npm script命令
  ```
  "scripts": {
    "start": "webpack-dev-server",
    "build": "webpack"
  }

  npm start: 编译运行项目
  npm build: 编译打包

  ```


面试题
->->
->->
->->
->->
->->
->->
->->
###new 操作符干了那些事情
1.构造函数体代码执行
2.创建空的对象（未来将要装实例对象）
3.将this指向空的对象
4.将函数执行的结果赋值给空的对象

面试题：


var a = {n: 1}
var b = a
a.x = a = {n: 2}
console.log(a.n, b.n) //2  1
console.log(a.x, b.x) //undefined   {n:2}
/*
  在a.x=a={n:2}这种表达式中:
  a.x先等于a,然后等于{n:2},这样最终等同于a.x={n:2},
  然后执行，a={n:2}
*/

var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  f()
}
show(fn) //10
/*
虽然fn()是在show()函数中调用的，
但是函数在定义的位置执行，
同时函数在执行的位置找x,
     即在定义的位置找x.
*/


var fn = function () {
  console.log(fn)
}
fn() //function函数
var obj = {
  fn2: function () {
    console.log(fn2) // 去全局找，没有变量fn2   上面的fn2是obj对象中的属性，而不是一个变量？
  }
}
obj.fn2() //报错
/*
去全局找，没有变量fn2。上面的fn2是obj对象中的属性，而不是一个变量？
*/


var c = 1
function c(c) {
  console.log(c)
  var c = 3
}
console.log(c) //1
c(2) //报错。
/*
报错是因为，执行到c(2)到时候的c是1。
最开始c通过function的方式被提升声明，然后执行到var c=1的时候，就被覆盖成1了。
*/


var name = 'World!'
;(function () {
  //var name;
  if (typeof name === 'undefined') {
    var name = 'Jack'
    console.log(name) //jack
  } else {
    console.log(name)
  }
})()
/*
  typeof的特点就是在如上位置var name。
*/


var a = 6
setTimeout(function () {
  console.log(0)
  alert(a) //66
  a = 666
}, 0)
console.log(1)
a = 66
/*
回调要等主线程执行完
*/


function fn1() {
  var a = 2
  function fn2 () {
    a++
    console.log(a)
  }
  return fn2
}
var f = fn1()
f()//3
f()//4
/**/


var name = "A"
var object = {
  name: "B",
  getNameFunc: function () {
    return function () {
      return this.name  //this是谁?window
    }
  }
}
console.log(object.getNameFunc()())  //A

//object.getNameFunc()()中，
//因为执行()的时候，是前面object.getNameFunc()这个整体在执行。


var name2 = "A"
var object2 = {
  name2: "B",
  getNameFunc: function () {
    var that = this  // 缓存this?object2
    return function () {
      return that.name2
    }
  }
}
console.log(object2.getNameFunc()()) //B



//实例被构造函数构造出来之后，再改构造函数对这个实例也没影响了（已经造完）。



var F = function(){}
Object.prototype.a = function(){
  console.log('a()')
}
Function.prototype.b = function(){
  console.log('b()')
}
var f = new F()
F.a() //a()
F.b() //b()
f.a() //a()
f.b() //报错
/*
  F.a() -- 因为F是函数，先去Function的原型中找，找不到再去祖宗Object的原型中找。
  只有用Function来new出来的是函数，其它情况new出来的都是对象。
  所以f也是一个对象。
  对象只找Object,函数才找Function（但是找不到也会去Object中找）。
*/


请阅读：
var fun1=new Function();
var obj1=new Object();
Function.prototype.a="sunwukong";
Object.prototype.b="wanger";
console.log(fun1.a);//sunwukong
console.log(fun1.b);//wanger
console.log(obj1.a);//undefined
console.log(obj1.b);//wanger

var date=new Date();
var r1=new RegExp();
console.log(typeof fun1);//function
console.log(typeof date);//object
console.log(typeof r1);//object

var F1=function(){};
var f=new F1();
console.log(typeof f);//object




function Person() {
  getAge = function () {
    console.log(10)
  }
  return this
}
Person.getAge = function () {
  console.log(20)
}
Person.prototype.getAge = function () {
  console.log(30)
}
var getAge = function () {
  console.log(40)
}
function getAge() {
  console.log(50)
}
Person.getAge() //20
getAge() //40
Person().getAge() //10
getAge() //10
new Person.getAge() //20
new Person().getAge() //30
/*
new 操作符干了那些事情
 1.构造函数体代码执行
 2.创建空的对象（未来将要装实例对象）
 3.将this指向空的对象
 4.将函数执行的结果赋值给空的对象

 person().getAge():
  person()这里是返回的对象window；
  person()在调用时执行，覆盖了全局的getAge函数。

  new Person.getAge():
  new的是后面的整体。
  根据new操作符干了哪些事情第一条：
  构造函数体代码执行，
  所以Person.getAge()执行直接打印20。
*/




function fun(n, o) {
  console.log(o)
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }
}
var a = fun(0)
a.fun(1)
a.fun(2)
a.fun(3)
var b = fun(0).fun(1).fun(2).fun(3)
var c = fun(0).fun(1)
c.fun(2)
c.fun(3)
/*
  第一次执行得到一个对象
  n=0 m=1 调用fun(m)

  第二次a.fun(2)
  后面看的都是第一次保存的值，
  没有人接收/保存值。

  对象.  连点可以保存值

  ？
*/





# 阶段知识点考题总结
## 1、简述mvc和mvvm
早期的mvc是一种架构理念，随着互联网的发展，这种架构理念逐渐被应用到实际的开发当中，成为一种架构模式。
最终达到的效果是页面与数据分离
* MVC：
- M层(数据层)
  - 存储数据的实体模型
- C层(控制层)
  - 操作模型数据, 更新视图
  - View与Model之间的桥梁
  - 是v层的直接数据源
- V(层)
  - 显示数据
  - 响应用户操作, 与用户进行交互
- 在mvc中最核心的是C层，它是M层与V层的纽带
* mvvm
  - 在mvvm中最核心的vm层($scope)，controller层只是起辅助作用，其他的同MVC一样，MVVM是MVC的一个升级版，angular应用的就是MVVM架构模式
## 2、简述箭头函数的特点，并用箭头函数写出数组map遍历的方法
- 箭头函数没有自己的this，在语法上更为简介。
- 箭头函数的this不是在调用的时候决定的，是在定义的时候决定的，定义时候所处的对象就是箭头函数的this
- 箭头函数的this是看外层有没有函数，如果有，和外层的函数指向的是同一个this，如果没有则指向window
- arr.map((item, index) => {
    console.log(item, index)
  })
## 3、bind，call，apply的相同点和不同点
- bind，call，apply都能强制指定this
- call，apply指定完this后立即调用当前函数
- bind绑定完this不会立即调用，将当前的函数返回
- call，apply传参形式不一样，apply需要传入数组里
- bind也可以传入参数，同call一样直接传参

## 4、promise对象的原理及作用
> Promise对象: 代表了 未来 某个将要发生的事件(通常是一个异步操作)
> ES6的Promise是一个构造函数, 用来生成promise实例
> 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的 回调函数 (俗称'回调地狱')
> promise有三种状态('初始化状态'， '成功的状态'， '失败的状态')
> 通过执行异步任务返回的结果(通常是发送ajax请求)来修改promise的状态，
> 当promise的状态发生改变的时候会调用promise的实例中的then方法的成功或者失败的回调后函数，去执行相应的操作。
## 5、package.json中最重要的五个属性，及作用是什么
{
    "name": "npm_command", //包名，必不可少
    "version": "1.0.0", //版本， 必不可少
    "scripts": { //配置npm运行命令
      "start": "node bin/www"
    },
    "dependencies": {//运行依赖的包
      "jquery": "^3.2.1"
    },
    "devDependencies": {//开发依赖的包
      "babel": "^6.23.0"
    }
  }

## 6、什么是跨域，解决跨域的方法及原理是什么？
1. 不同源就是跨域
2. 同源策略是浏览器的一种安全策略
3. 协议，域名，端口号完全相同就是同源，只要有一处不一样就是跨域
4. 特例： ajax在判断域名的时候只能解析字符串，导致(localhost和127.0.0.1)在它看来也是跨域请求
5. 解决跨域的方式通常用cors和jsonp
6. JSONP
  1. JSONP是一种技巧，不是一门新的技术
  2. 利用scirpt标签的src属性不受跨域的限制的特点
  3. 解决跨域：
    1. 浏览器端：
      动态生成script标签，提前定义好回调函数，在合适的时机添加src属性指定请求的地址。
    2. 服务器端：
      后台接收到回调函数，将数据包括在回调函数调用的句柄中，一起返回。
    3. 只支持get请求
7. cors
  1. 浏览器端什么也不用干
  2. 服务器端设置响应头：Access-Control-Allow-Origin
  3. cors是一门技术，在本质上让ajax引擎允许跨域
  4. get和post请求都支持

## commonjs和ES6模块化暴露的本质分别是什么，请详细说明
1、commonjs暴露的方式
  - module.exports = value;
  - exports.xxx = value;
  - 暴露的本质是exports对象
2、ES6中暴露的方式
  - export xxx （常规暴露，暴露的本质是对象，接收的时候只能以对象的解构赋值的方式来接收值）
  - export default （默认暴露，暴露任意数据类型，暴露什么数据类型，接收什么数据类型）

## 模块化的优点和缺点
1、模块缺点：
    - 请求过多
    - 依赖模糊
    - 难以维护
2、模块化优点：
  - 避免命名冲突(减少命名空间污染)
  - 更好的分离, 按需加载
  - 更高复用性
  - 高可维护性


## 请写出自动化工具里的至少两种项目构建的方法，特点和需要注意的地方
1、grunt
  - 执行任务是同步的
  - 配置文件需要首字母大写 Gruntfile.js
  - 执行任务需要依赖对应的插件
  - 配置任务的时候要注意加载对应的插件任务
2、gulp
  - 执行任务是异步的
  - 任务化
  - 基于流
  - 所有的操作都是在内存中，操作完的数据通过pipe管道流出。
  - 可全自动加载(connect)也可半自动加载(’某某‘插件)
  - gulp-load-plugins可打包加载项目中gulp的所有插件，注意引入后得到的是一个函数，必须调用，返回得一个对象，对象里边封装了所有打包插件的方法。
3、webpack
  - 所有的文件都是模块(html除外)
  - webpack本身只能加载js模块，加载其他的模块需要依赖对应的loader
  ```
  module.exports = {
      entry: "./src/js/entry.js",//入口文件的路径
      output: {//输出文件的配置
          path: __dirname + '/dist/js/',//输出文件的路径
          publicPath : './dist/js/',//webpack的绝对路径
          filename: "build.js"//输出的文件名
      },
      module: {
          loaders: [//加载对应的loader
              { test: /\.css$/, loader: "style!css" },
              { test: /\.(png|jpg)$/, loader: "url-loader?limit=8192" }
          ]
      },

  }
  ```
  - 使用webpack-dev-server的时候需要注意的地方
    - webpack-dev-server为根文件夹下的index.html提供内置的服务
    - 如果其他目录下的文件提供服务需要在此设置目录(我们设置为build文件夹)
    `
      devServer:{
              contentBase: './build',//内置服务器生成的打包的js文件的服务路径
              historyApiFallback:true,//不跳转
              inline:true,
              port : 5000
          }
    `
  - 打包图片使用url-loader时候注意的问题
    - 当图片大于8kb的是无法打包到主文件里
    - 导致图片的路径发生错误
    - 解决办法：
      - publicPath : './dist/js/',//webpack的绝对路径



bootstrap
概念：
什么是响应时页面？
某个网站或web应用可以同时匹配多个终端的显示效果。

实现响应式的方式：
1.针对不同的终端提供不同的样式	--> 适用于复杂的网站或web应用。
2.只提供一个样式匹配所有终端	--> 适用于简单的网站或web应用

bootstrap就是第二种响应式方式：只提供一个样式匹配所有终端。

http://v3.bootcss.com/

手写响应式布局：
1.viewport
表示视口，通过viewport设置当前页面的可视宽度、缩放比例等。
2.相对单位
高度和宽度 - 将像素值修改为百分值
注意：不同浏览器的显示效果可能有不同。
字体 - 将像素值修改为em或rem
注意：不同的浏览器默认的字体大小不同。
3.网格布局
*将HTML页面的整个宽度等分为12列，
页面的整个宽度 - 100%
*将页面中所有元素的盒子模型设置为border-box，
*将用于布局的所有元素设置为浮动。
4.媒体查询
语法格式
@media 媒体类型 逻辑操作符 媒体属性{
	包含正常的CSS定义的样式内容
}
  媒体类型：all - 适用于所有设备
	   screen - 适用于屏幕
  逻辑操作符：and - 表示连接
	     not - 表示取反
	      only - 表示只有
  媒体属性：width
	    min-width
	    max-width


创建流式布局：
a.计算每列所占的百分比：100%/12列=8.33%
.col-1 {width: 8.33%;}
.col-2 {width: 16.66%;}
.col-3 {width: 25%;}
.col-4 {width: 33.33%;}
.col-5 {width: 41.66%;}
.col-6 {width: 50%;}
.col-7 {width: 58.33%;}
.col-8 {width: 66.66%;}
.col-9 {width: 75%;}
.col-10 {width: 83.33%;}
.col-11 {width: 91.66%;}
.col-12 {width: 100%;}
b.将所有列设置为浮动（一般为左浮动）
[class*="col-"] {
  float: left;
}
c.将HTML页面中所有的元素设置
box-sizing:border-box;


响应式图片
实现图片的显示根据浏览器的窗口大小变化而变化，。只需将图片的width设置为100%即可。
但这样设置后，图片的显示可能不实际大小更大。解决这个问题可以利用max-width替代widtn属性即可。
max-width:100%;

bootstrap引入

<!-- 新 Bootstrap 核?心 CSS ?文件 -->
<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
<!-- 可选的Bootstrap主题?文件（?一般不不?用引?入） -->
<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap-theme.min.css
<!-- jQuery?文件。务必在bootstrap.min.js 之前引?入 -->
<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
<!-- 最新的 Bootstrap 核?心 JavaScript ?文件 -->
<script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>


bootstrap不支持ie古老的兼容模式。为了让ie浏览器运行最新的渲染模式下，建议将此<meta>元素加入到页面中：
<meta http-equiv="X-UA-Compatible" content="IE=edge">

将下面的<meta>元素加入到页面中，可以让部分国产浏览器默认采用高速模式渲染页面：
<meta name='renderer' content='webkit'>


基本模板
bootstrap提供了一个最基本的HTML模板，基于这个模板开始实现bootstrap响应页面。
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 设置当前 HTML ?页?面的编码格式为 UTF-8 -->
<meta charset="utf-8">
<!-- 设置 IE 的兼容模式 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- 设置移动优先 -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- 上述3个meta标签必须放在最前?面，任何其他内容都必须跟随其后！ -->
<title>Bootstrap最基本的HTML模板</title>
<!-- 导?入 Bootstrap 框架的 CSS ?文件 -->
<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
<!--
html5shiv.js ?文件解决 IE8及之前版本的浏览器??支持 HTML 5 元素的问题。
respond.js ?文件解决 IE8及之前版本的浏览器??支持 CSS 3 的媒体查询问题。
-->
<!--[if lt IE 9]>
<script src="bootstrap/js/html5shiv.min.js"></script>
<script src="bootstrap/js/respond.min.js"></script>
<![endif]-->
</head>
<body>
<h1>你好，世界！</h1>
<!--
由于 Bootstrap 是基于 jQuery 实现的核?心 js 功能,
所以想要使?用 Bootstrap 提供的插件功能,需要先导?入 jQuery ?文件。
-->
<script src="bootstrap/js/jquery-1.11.3.js"></script>
<!-- 导?入 Bootstrap 框架的 js ?文件 -->
<script src="bootstrap/js/bootstrap.min.js"></script>
</body>
</html>


h5新的标签
<input type="text" id="user" required>
//required内容不许为空。
<input type="text" pattern="[0-9]{0-8}">
<input type="text" minlength="6" maxlength="8">
自动获得焦点：autofocus
输入框内的提示文字：placeholder='...'
进度条：
<progress id="pro" max="100" value="0"></progress>
var progress = document.getElementById('pro');
var max = progress.max;
var t = setInterval(function(){
    var value = progress.value;
    if(value >= max){
        clearInterval(t);
    }
    value++;
    progress.value = value;
},50);
电池效果：
<meter min='0' max='100' value='95' low='10' high='90'></meter>

validity
用户名
var user=document.getElementById('user');
user.onblur=function(){
    if(user.validity.valid){
        //表示输入正确
    }else if(user.validity.valueMissing){
        console.log('用户名为空');
    }else if(user.validity.tooLong){
        console.log('用户名太长');
    }else if(user.validity.tooShort){
        console.log('用户名太短');
    }
}
密码
var pwd=document.getElementById('pwd');
pwd.onblur=function () {
    //需要pwd中有pattern="[0-9]{6,8}"类似的属性
    if(pwd.validity.patternMismatch){
        console.log('密码输入错误');
    }
}
邮箱
var mail=document.getElementById('mail');
mail.onblur=function () {
    if(mail.validity.typeMismatch){
        console.log('电子邮箱格式不对');
    }
}
年龄
var age=document.getElementById('age');
age.onblur=function () {
    if(age.validity.rangeUnderflow){
        console.log('年龄太小了');
    }else if(age.validity.rangeOverflow){
        console.log('年龄太大了');
    }else if(age.validity.stepMismatch){
        console.log('年龄不匹配');
    }
}
自定义错误信息
var user=document.getElementById('user');
user.onblur=function () {
    if(user.validity.valueMissing){
        user.setCustomValidity('用户名不能为空');
    }else if(user.validity.customError){
        user.setCustomValidity('');
    }
}



canvas

注意：不要在CSS中设置画布的大小，否则绘制出来会有问题。
     而是通过内联样式设置画布的大小。

画一个矩形：
var canvas=document.getElementById('canvas');
var context=canvas.getContext('2d');
context.fillRect(10,10,100,100);//实心矩形
context.strokeRect(120,120,100,100);//空性矩形
context.clearRect(0,0,500,300);//擦除

h5动画方法:
替换：setTimeout(fun,time);
window.requestAnimationFrame(fun);



组件化和模块化都实现特定的功能。
区别：组件化带界面，另外包含有HTML CSS等。

构建包括：
1.初始化显示
2.更新显示

声明式函数就是命令式函数被封装后的结果。

React的声明式体现在哪方面？
比如说，只改变state而不用操作DOM，就能完成更新。

JSX（是JS的扩展）：
是标签和JS的混合。
其中标签包括HTML标签和组件（即自定义标签）。

React是面向组件编程的。
方式1（工厂函数、无状态函数）：
不用new，直接调用，特点是快。
它的无状态指，不能像方式2中有constructor中定义state。
方式2：
有状态。

三点运算符。
包括打包和解包两种方式，针对的是数组和对象。

绑定事件监听包括：
事件名，
回调函数。

触发事件：用户用对应的操作操作对应的界面。

判断数据类型：
typeof
instance of
===

{}/[]使用typeof判断结果都是‘object’,不能区别数组和对象。

console.log(typeof console.log)//'function'
console.log(typeof console.log('abc'))//'undefined'
*因为console.log()没有返回值

console.log({} instance of arry)//'false'

得到undefined的情况：
1.声明变量
2.读取对象中不存在的属性
3.调用一个没有返回值的函数

console.log(Object.prototype.__proto__)//null

对于变量只有读和写操作。
传递的只是数值，而非变量。
变量本质上就是一个内存空间，内存空间是不能动的。
赋值操作就好像：
有a b两个盒子，a赋值给b的过程就是，b看了一眼a里面有什么，然后自己里面也要什么，而不是把a盒子直接塞进自己里面，也不是把a盒子里面的东西放到自己里面。

引用变量传递的是地址值。
相当于传递一把指向某个房间的钥匙。这个要是就代表了那个房间。

局部变量在调用完之后就释放。

var obj={} 此时{}不是垃圾对象，因为obj引用的它
obj=null   此时{}是垃圾对象
在垃圾回收器回收时释放。

全局变量一直都存在，知道页面关闭/刷新页面。

方法：是特定的属性（属性值是方法）

查找对象属性，先从自身查找；
找不到沿原型链查找；
再找不到返回undefined.
因为Object.prototype.__prototype__为null


prototype属性是什么时候产生的？值是多少？什么时候用到？
prototype是执行函数定义（创建函数对象）的时候产生的。
内部执行Fn.protoType={} (不是没东西，是没有我们自己定义的东西)。
显示原型prototype在创建实例时用到。

__proto__属性什么时候产生的，值是多少，什么时候用到？
创建实例对象产生。
内部执行this.__proto__=Fn.prototype
隐式原型__proto__在查找时用到。
__proto__值为构造函数prototype属性值。

不是函数执行()就会报错。

a.b的查找顺序：
1.沿作用域找a(如果找不到:报错)；
2.找到a后，沿原型链找对象。

所有函数都是Function的实例，
包括它自己。

Function.prototype===Function.__proto__

Object是Function的实例。

A.prototype.n=1 //这种修改显示原型的方式，前后创建的对象都可见
A.prototype={
 m:3
}//这种方式只影响后面创建的对象
prototype相当于发钥匙的过程。
第一种方式，每创建一个新对象，就相当于给每个对象发一把钥匙，它们都通向同一个房间。当修改原型prototype中的n属性时，相当于动了房间里的东西。问题的关键在于，创建新对象的先后并不能改变一个事实，那就是它们的房间一直以来就是这同一个房间。所以只要改变其中的属性，必定导致创建的对象改变。
第二种方式，在刚开始的时候，和第一种方式相同，也是每个对象发一把钥匙，而且是指向同一个房间，只要改变房间里的东西，它们同样也都跟着改变（其实不是跟着改变，问题关键就是它们的房间一直以来就是同一个，你改的东西本身就是我的）。但是，关键区别来了，这次的方式并不是在改房间里的东西，当prototype被赋值了一个对象的时候，就相当于老板又开了一个崭新的房间，那么，再后面，老板还是重复之前的事情，没创建一个对象的时候就给他们一把钥匙，而且是通向同一个房间的。但是，注意那个重要的分隔点，老板已经开了一间新的房间，新的成员只拿到了新房间的钥匙，他们根本不知道另一个房间，另一个房间也不知道他们。

if(!(b in window)){
 var b=1;
}
console.log(b)//undefined

先提升变量再提升函数。
函数的优先级高于变量。
优先级高体现在哪方面？就是有决定性的作用。
函数的优先级高体现在，它比变量后执行，然后覆盖变量。


两大神兽：
原型、闭包。

闭包：
形成条件->
1.函数嵌套。
2.内部函数访问/引用外部变量。
（执行函数定义时。函数执行与否对闭包产生基本无影响。没项目也要给员工发工资啊。）
3.调用外部函数。

闭包产生：
内部函数定义执行完时。
消失：
内部函数成为垃圾对象。
f=null不再引用内部函数。


属性是函数的时候就是方法。

函数也是对象。

为什么说函数也是对象？
1.console.log(Foo.instanceof Object)//true
2.Foo.prototype --有属性
3.Foo.call()/... --有方法
4.可以添加新的属性

在window中，
xxx()的this不一定是window，
//有可能是已经被bind()绑定了

this指向的是	
定时器回调 	-> window
arr.forEach() 	-> window
ajax回调		-> window
DOM事件回调	->调用它的DOM事件

作用域在创建的时候就确定了，之后不会改变。

闭包的作用：
1.延长局部变量生命周期。（如果没有闭包，执行完之后立即消失）
2.外部可以间接访问内部变量。

一个对象不能直接包含另一个对象，
只能包含另一个对象的引用。
房间里只能存其它房间的钥匙，
而不是直接把房间直接装另一个房间里面。

(function(){})()
(function(window){})(window)
传入window的作用：
1.可以压缩，（把函数内部的window压缩）。
2.快。（直接找到window对象）

jQuery内部包含一个很大的闭包。

1.内存溢出
程序运行需要的内存大于可用内存。
2.内存泄露
 -意外的全局变量
 -没有及时清理的计时器
 -没有被释放的闭包

内存泄漏就是脱离管理的内存，没有作用，但是却继续占着内存。

把方法存在prototype中就是为了节省内存。
不是同一个的实例的__proto__地址不同，但是里面存的地址相同。
存钥匙的盒子不同，但是这些钥匙都指向同一个房间。

实现继承：
Child.prototype=new Parent
//让子类原型指向父类的实例
//new Parent的过程中，是Parent创建实例的过程，创建实例会发它提供的prototype的房间所对应的钥匙，Child.prototype=new Parent也就是说让Child.prototype接收这个值，即Parent的钥匙发给了Child.prototype，这样以来Child的公共房间就继承了Parent的公共房间。

Child.prototype.constructor=Child
//让构造器变回子类的构造器（可能是上一步把构造器也给顶了吧）


Person.call(this,name,age)
Person是一个构造函数，这条语句放在另一个构造函数中
这样就可以让任意函数（比如Person）被任意函数临时调用。
//借用父类型的构造的函数。

基于原型链的主要是用来继承的方法。
而用来继承的属性基于.call()???

什么是构造函数的继承？
1.Parent
2.Child。Parent.call(this,name,age)	->共同属性的初始化
3.Child.prototype=new Prototype		->共同方法的继承（通过原型链）


进程与线程
进程：
程序的一次执行，它占有一个独立的内存空间。
多个进程之间的数据不能直接分享。
Chrome是多进程；firefox是单进程。
线程：	
多个线程之间的数据可以直接分享。
什么是多线程？一个进程里运行多个线程，称多线程。
js是单线程运行，浏览器是多线程运行。

浏览器内核：
支撑浏览器运行的最核心的程序。

浏览器用正则表达式解析服务器端发来的字符串。

alert()的作用：
1.弹对话框。
2.让当前主线程暂停执行。
3.让计时器也暂停了。

代码分类：
1.初始化代码（同步代码）
2.回调代码（异步代码）

js引擎先执行初始化代码，再执行回调代码。

setTimeout本身是同步代码，但是包含的回调代码时异步代码。
所以setTimeout正常执行了，而里面的回调代码进入了回调队列中等待主线程的执行。

分线程->待处理的回调函数->在JS主线程执行完
即：管理模块->回调队列->主线程

执行上下文栈就是现金后出。


闭包的应用：
1.模块化
2.循环遍历加监听
3.JS框架（jquery）


定时器不准时：
定时器启动后，主线程执行时间大于定时。


js解析过程中的三个部分：
JS引擎（主线程，是单线程的），
管理模块（分线程），
回调队列（待处理的回调函数）。

浏览器是多线程的，
但是JS引擎是单线程的，
同时也是主线程，
分线程上有一个管理模块，
其中包括DOM、ajax和setTimeout。
分线程在主线程进行的时候也在进行，
解析完成的分线程会在回调队列中排队，
即成为待处理的回调函数，
直到主线程进行完之后再进行。

分线程能更新界面吗？
不能。因为分线程的全局不是window.


HMR
Hot Module Replace
热模替换


xxx脚手架：创建一个基于xxx库的模板项目。


脚手架开发项目的特点：
1.模块化。js是一个一个模块编写的。
2.组件化。界面是由多个组件组合编写实现的。
3.工程化。实现了自动构建/运行/打包。


组件的生命周期：
componentDidMount
componentUpdate
componentUnmount


‘钩子’=回调函数


react是一种
虚拟DOM + DOM diff算法


setState没有覆盖之前的虚拟DOM，而是重新创建了一个虚拟DOM树，
并和之前的进行比较。


cli
controll line io
命令行接口


项目整体架构？
react+webpack+es6+babel+eslint(检查语法)

babel:将jsx转换成js，将es6转换成es5


react-router:
react的一个插件，
专门用来实现一个SPA应用，
Single Page App

什么是路由？
路由就是一个映射关系。
就是 key 和 value 的关系。
key:path
value:回调函数

value可能是:function	<- 后台
	    component	<- 前台



子组件不能改变主组件的state,
于是主组件定义了一个改变自己的state的方法，
并把这个方法暴露给需要的子组件。
state是可以改的，props只能传递。
只能从主组件向子组件流动，单向数据流。

路由的工作流程？

API接口：
（前后台交互API接口）

包含四部分：
1.url
2.请求方式（get、post...）
3.请求参数格式
4.响应数据格式

需要先知道数据类型：json[]? {}?


接口文档：描述接口的文档。

前后台分离：前台页面，后台只提供数据。

mock数据：模拟数据

模拟后台，mock接口。
（但是要上线，切到真实数据时不一定100%匹配）


base64
把图片变成字符串。
优点：快（因为不用再发送http请求）。
webpack可以直接将小于1024的图片转换成base64格式。


rest接口：
url只用来定位资源，
不携带行为的数据，
关键是由服务器决定的，用户只要提供相应的请求。
github提供了rest接口。
有post delete put get(增删改查)等多种方式。

非rest接口：
包含行为数据（get、post...）
这种的特点就是几乎只用get和post


mongodb中的两个概念：
集合。
文档。
集合就是数组，里面包含很多文档。
文档就是对象。

如何来模拟一个后台数据？



提交git
配置gitignore
git init
git add *
git commit -m 'node'
git remote origin add url
git push origin master





小飞的笔记

js高级

## 数据类型的分类和判断
* 基本(值)类型
  * Number ----- 任意数值 -------- typeof
  * String ----- 任意字符串 ------ typeof
  * Boolean ---- true/false ----- typeof
  * undefined --- undefined ----- typeof/===
  * null -------- null ---------- ===
* 对象(引用)类型
  * Object ----- typeof/instanceof
  * Array ------ instanceof
  * Function ---- typeof

## 数据,变量, 内存的理解
* 什么是数据?
  * 在内存中可读的, 可传递的保存了特定信息的'东东'
  * 一切皆数据, 函数也是数据
  * 在内存中的所有操作的目标: 数据
* 什么是变量?
  * 在程序运行过程中它的值是允许改变的量
  * 一个变量对应一块小内存, 它的值保存在此内存中  
* 什么是内存?
  * 内存条通电后产生的存储空间(临时的)
  * 一块内存包含2个方面的数据
    * 内部存储的数据
    * 地址值数据
  * 内存空间的分类
    * 栈空间: 全局变量和局部变量
    * 堆空间: 对象 
* 内存,数据, 变量三者之间的关系
  * 内存是容器, 用来存储不同数据
  * 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  
  
## 对象的理解和使用
* 什么是对象?
  * 多个数据(属性)的集合
  * 用来保存多个数据(属性)的容器
* 属性组成:
  * 属性名 : 字符串(标识)
  * 属性值 : 任意类型
* 属性的分类:
  * 一般 : 属性值不是function  描述对象的状态
  * 方法 : 属性值为function的属性  描述对象的行为
* 特别的对象
  * 数组: 属性名是0,1,2,3之类的索引
  * 函数: 可以执行的
* 如何操作内部属性(方法)
  * .属性名
  * ['属性名']: 属性名有特殊字符/属性名是一个变量
  
## 函数的理解和使用
* 什么是函数?
  * 用来实现特定功能的, n条语句的封装体
  * 只有函数类型的数据是可以执行的, 其它的都不可以
* 为什么要用函数?
  * 提高复用性
  * 便于阅读交流
* 函数也是对象
  * instanceof Object===true
  * 函数有属性: prototype
  * 函数有方法: call()/apply()/bind()
  * 可以添加新的属性/方法
* 函数的3种不同角色
  * 一般函数 : 直接调用
  * 构造函数 : 通过new调用
  * 对象 : 通过.调用内部的属性/方法
* 函数中的this
  * 显式指定谁: obj.xxx()
  * 通过call/apply指定谁调用: xxx.call(obj)
  * 不指定谁调用: xxx()  : window   // xxx不是通过bind()产生的
  * xxx.bind(obj)返回的函数 : obj
  * 回调函数: 看背后是通过谁来调用的: window/其它
    定时器回调: window
    arr.forEach()回调: window
    ajax回调: window
    DOM事件回调: 发生事件的DOM元素
* 匿名函数自调用:
  ```
  (function(w, obj){
    //实现代码
  })(window, obj)
  ```
  * 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式
						  
* 回调函数的理解
  * 什么函数才是回调函数?
    * 你定义的
    * 你没有调用
    * 但它最终执行了(在一定条件下或某个时刻)
  * 常用的回调函数
    * dom事件回调函数
    * 定时器回调函数
    * ajax请求回调函数
    * 生命周期回调函数
  

## 原型与原型链
* 所有函数都有一个特别的属性:
  * `prototype` : 显式原型属性
* 所有实例对象都有一个特别的属性:
  * `__proto__` : 隐式原型属性
* 显式原型与隐式原型的关系
  * 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
  * 实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  * 原型对象即为当前实例对象的父对象
* 原型链
  * 所有的实例对象都有__proto__属性, 它指向的就是原型对象
  * 这样通过__proto__属性就形成了一个链的结构---->原型链
  * 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

## 执行上下文与执行上下文栈
* 变量提升与函数提升
  * 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  * 函数提升: 在函数定义语句之前, 就执行该函数
  * 先有变量提升, 再有函数提升
* 理解
  * 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性
  * 执行上下文栈: 用来管理产生的多个执行上下文
* 分类:
  * 全局: window
  * 函数: 对程序员来说是透明的
* 生命周期
  * 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  * 函数 : 调用函数时产生, 函数执行完时死亡
* 包含哪些属性:
  * 全局 : 
    * 用var定义的全局变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===>window
  * 函数
    * 用var定义的局部变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===> 调用函数的对象, 如果没有指定就是window 
    * 形参变量   ===>对应实参值
    * arguments ===>实参列表的伪数组
* 执行上下文创建和初始化的过程
  * 全局:
    * 在全局代码执行前最先创建一个全局执行上下文(window)
    * 收集一些全局变量, 并初始化
    * 将这些变量设置为window的属性
  * 函数:
    * 在调用函数时, 在执行函数体之前先创建一个函数执行上下文
    * 收集一些局部变量, 并初始化
    * 将这些变量设置为执行上下文的属性
## 作用域与作用域链
* 理解:
  * 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
  * 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
* 分类:
  * 全局
  * 函数
  * js没有块作用域(在ES6之前)
* 作用
  * 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
  * 作用域链: 查找变量
* 区别作用域与执行上下文
  * 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
  * 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失
  * 联系: 执行上下文环境是在对应的作用域中的

## 闭包 
* 理解:
  * 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
* 作用:
  * 延长局部变量的生命周期
  * 让函数外部能操作内部的局部变量
* 写一个闭包程序
  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  
  ```
* 闭包应用:
  * 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  * 循环遍历加监听
  * JS框架(jQuery)大量使用了闭包
* 缺点:
  * 变量占用内存的时间可能会过长
  * 可能导致内存泄露
  * 解决:
    * 及时释放 : f = null; //让内部函数对象成为垃圾对象
    
## 内存溢出与内存泄露
1. 内存溢出
  * 一种程序运行出现的错误
  * 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
2. 内存泄露
  * 占用的内存没有及时释放
  * 内存泄露积累多了就容易导致内存溢出
  * 常见的内存泄露:
    * 意外的全局变量
    * 没有及时清理的计时器或回调函数
    * 闭包
    


## 对象的创建模式
* Object构造函数模式
  ```
  var obj = {};
  obj.name = 'Tom'
  obj.setName = function(name){this.name=name}
  ```
* 对象字面量模式
  ```
  var obj = {
    name : 'Tom',
    setName : function(name){this.name = name}
  }
  ```
* 构造函数模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.setName = function(name){this.name=name;};
  }
  new Person('tom', 12);
  ```
* 构造函数+原型的组合模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  Person.prototype.setName = function(name){this.name=name;};
  new Person('tom', 12);
  ```
  
## 继承模式
* 原型链继承 : 得到方法
  ```
  function Parent(){}
  Parent.prototype.test = function(){};
  function Child(){}
  Child.prototype = new Parent();
  var child = new Child(); //有test()
  ```
* 借用构造函数 : 得到属性
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  var child = new Child('a', 'b');  //child.xxx为'a', 但child没有test()
  ```
* 组合
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  Child.prototype = new Parent(); //得到test()
  var child = new Child(); //child.xxx为'a', 也有test()
  ```
* new一个对象背后做了些什么?
  * 创建一个空对象
  * 给对象设置__proto__, 值为构造函数对象的prototype属性值
  * 执行构造函数体(给对象添加属性/方法)

## 线程与进程
* 进程:
  * 程序的一次执行, 它占有一片独有的内存空间
  * 可以通过windows任务管理器查看进程
* 线程:
  * 是进程内的一个独立执行单元
  * 是程序执行的一个完整流程
  * 是CPU的最小的调度单元
* 关系
  * 一个进程至少有一个线程(主)
  * 程序是在某个进程中的某个线程执行的

## 浏览器内核模块组成
* 主线程
  * js引擎模块 : 负责js程序的编译与运行
  * html,css文档解析模块 : 负责页面文本的解析
  * DOM/CSS模块 : 负责dom/css在内存中的相关处理 
  * 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)
* 分线程
  * 定时器模块 : 负责定时器的管理
  * 事件响应模块 : 负责事件的管理
  * 网络请求模块 : 负责Ajax请求

## js线程
* js是单线程执行的(回调函数也是在主线程)
* H5提出了实现多线程的方案: Web Workers   --->Worker
* 只能是主线程更新界面

## 定时器问题:
* 定时器并不真正完全定时
* 如果在主线程执行了一个长时间的操作, 可能导致延时才处理
    
## 事件处理机制(图)
* 代码分类
  * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
  * 回调执行代码: 处理回调逻辑
* js引擎执行代码的基本流程: 
  * 初始化代码===>回调代码
* 模型的2个重要组成部分:
  * 事件管理模块
  * 回调队列
* 模型的运转流程
  * 执行初始化代码, 将事件回调函数交给对应模块管理
  * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
  * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行
    
## H5 Web Workers
* 可以让js在分线程执行
* Worker
  ```
  var worker = new Worker('worker.js');
  worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
  worker.postMessage(data1) : 向另一个线程发送数据
  ```
* 问题:
  * worker内代码不能操作DOM更新UI
  * 不是每个浏览器都支持这个新特性
  * 不能跨域加载JS


react

# 1. 几个重要概念理解
## 1). 模块与组件
	1. 模块:
	  	理解: 向外提供特定功能的js程序, 一般就是一个js文件
	  	为什么: js代码更多更复杂
	  	作用: 复用js, 简化js的编写, 提高js运行效率
	2. 组件: 
		理解: 用来实现特定功能效果的代码集合(html/css/js)
	  	为什么: 一个界面的功能太复杂了
	  	作用: 复用编码, 简化项目界面编码, 提高运行效率
![组件](http://i.imgur.com/YnVjluG.jpg)
## 2). 模块化与组件化
    1. 模块化:
    	当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
    2. 组件化:
    	当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用

# 2. React的基本认识
	1). Facebook开源的一个js库
	2). 一个用来动态构建用户界面的js库
	3). React的特点
		Declarative(声明式编码)
		Component-Based(组件化编码)
		Learn Once, Write Anywhere(支持客户端与服务器渲染)
		高效
		单向数据流
	4). React高效的原因
    	虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数) 
    	高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)
# 3. 使用React
	1). 导入相关js库文件(react.js, react-dom.js, babel.min.js)
	2). 编码:
		<div id="container"></div>
		<script type="text/babel">
			var aa = 123
			var bb = 'test'
			ReactDOM.render(<h1 id={bb}>{aa}</h1>, containerDOM)
		</script>

# 4. JSX
	1). 理解
		* 全称: JavaScript XML
		* react定义的一种类似于XML的JS扩展语法: XML+JS
		* 作用: 用来创建react虚拟DOM(元素)对象
	2). 编码相关
		* js中直接可以套标签, 但标签要套js需要放在{}中
		* 在解析显示js数组时, 会自动遍历显示
		* 把数据的数组转换为标签的数组: 
			var liArr = dataArr.map(function(item, index){
				return <li key={index}>{item}</li>
			})
	3). 注意:
	    * 标签必须有结束
	    * 标签的class属性必须改为className属性
	    * 标签的style属性值必须为: {{color:'red', width:12}}
    
# 5. Component : React是面向组件编程的(组件化编码开发)
## 1). 基本理解和使用
	1). 自定义的标签: 组件类(函数)/标签
	2). 创建组件类
		//方式1: 无状态函数(简单组件, 推荐使用)
		function MyComponent1() {
			return <h1>自定义组件标题11111</h1>
		}
		//方式2: ES6类语法(复杂组件, 推荐使用)
		class MyComponent3 extends React.Component {
			render () {
			  return <h1>自定义组件标题33333</h1>
			}
		}
		//方式3: ES5老语法(不推荐使用了)
		var MyComponent2 = React.createClass({
			render () {
			  return <h1>自定义组件标题22222</h1>
			}
		})
	3). 渲染组件标签
		ReactDOM.render(<MyComp />,  cotainerEle)
## 2). ReactDOM.render()渲染组件标签的基本流程
	React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象
	将虚拟DOM并解析为真实DOM
	插入到指定的页面元素内部
## 3). props
	所有组件标签的属性的集合对象
	给标签指定属性, 保存外部数据(可能是一个function)
	在组件内部读取属性: this.props.propertyName
	作用: 从目标组件外部向组件内部传递数据
	对props中的属性值进行类型限制和必要性限制
		Person.propTypes = {
			name: React.PropTypes.string.isRequired,
			age: React.PropTypes.number.isRequired
		}
	扩展属性: 将对象的所有属性通过props传递
	    <Person {...person}/>
## 4). 组件的组合
	组件标签中包含子组件标签
	拆分组件: 拆分界面, 抽取组件
	通过props传递数据
## 5). refs
	组件内包含ref属性的标签元素的集合对象
	给操作目标标签指定ref属性, 打一个标识
	在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)
	作用: 找到组件内部的真实dom元素对象, 进而操作它
## 6). 事件处理
	1. 给标签添加属性: onXxx={this.eventHandler}
	2. 在组件中添加事件处理方法
	    eventHandler(event) {
	                
	    }
	3. 使自定义方法中的this为组件对象
	  	在constructor()中bind(this)
	  	使用箭头函数定义方法(ES6模块化编码时才能使用)
## 7). state
	1. 组件被称为"状态机", 页面的显示是根据组件的state属性的数据来显示
	2. 初始化指定:
        constructor() {
          super()
          this.state = {
            stateName1 : stateValue1,
            stateName2 : stateValue2
          }
        }
	3. 读取显示: 
	    this.state.stateName1
	4. 更新状态-->更新界面 : 
	    this.setState({stateName1 : newValue})
## 8). 实现一个双向绑定的组件
	React是单向数据流
	需要通过onChange监听手动实现
## 9). 组件生命周期
	1. 组件的三个生命周期状态:
		Mount：插入真实 DOM
		Update：被重新渲染
		Unmount：被移出真实 DOM
	2. 生命周期流程:
		* 第一次初始化显示
			constructor()
			componentWillMount() : 将要插入回调
			render() : 用于插入虚拟DOM回调
			componentDidMount() : 已经插入回调
		* 每次更新state
		    componentWillReceiveProps(): 接收父组件新的属性
		    componentWillUpdate() : 将要更新回调
		    render() : 更新(重新渲染)
		    componentDidUpdate() : 已经更新回调
		* 删除组件
			ReactDOM.unmountComponentAtNode(div): 移除组件
			componentWillUnmount() : 组件将要被移除回调
	3. 常用的方法
		render(): 必须重写, 返回一个自定义的虚拟DOM
	  	constructor(): 初始化状态, 绑定this(可以箭头函数代替)
	  	componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听
![组件生命周期](http://i.imgur.com/h5khD9F.png)

# 6. ajax
	1). React没有ajax模块
	2). 集成其它的js库(如axios/fetch/jQuery/), 发送ajax请求
		* axios
			* 封装XmlHttpRequest对象的ajax
			* promise
			* 可以用在浏览器端和服务器
	  	* fetch
	    	* 不再使用XmlHttpRequest对象提交ajax请求
	    	* fetch就是用来提交ajax请求的函数, 只是新的浏览才内置了fetch
	    	* 为了兼容低版本的浏览器, 可以引入fetch.js
	3). 在哪个方法去发送ajax请求
	  	* 只显示一次(请求一次): componentDidMount()
	  	* 显示多次(请求多次): componentWillReceiveProps()
	  
# 7. 虚拟DOM
## 1). 虚拟DOM是什么?
	一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)
	虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
	如果只是更新虚拟DOM, 页面是不会重绘的
## 2). Virtual DOM 算法的基本步骤
	用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
	当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
	把差异应用到真实DOM树上，视图就更新了
## 3). 进一步理解
    Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
    可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。
![](http://i.imgur.com/psaZdqN.png)


# git管理项目的流程
## 1. 本地管理
	创建.gitignore文件, 并指定需要忽略文件/文件夹
	git init
	git add *
	git commit -m "init app"
## 2. 创建远程仓库
## 3. 推送到远程
	git remote add origin https://github.com/zxfjd3g/170507_reactTest.git
	git push origin master
## 4. 修改代码
	git add *
	git commit -m "update"
	git push origin master

## 5. 你们
	git clone https://github.com/zxfjd3g/170507_reactTest.git
	git pull origin master
##



antd

# 1. 最流行的开源React UI组件库
## 1). material-ui(国外)
	官网: http://www.material-ui.com/#/
	github: https://github.com/callemall/material-ui
## 2). ant-design(国内蚂蚁金服)
	官网: https://ant.design/
	github: https://github.com/ant-design/ant-design/

# 2. ant-design使用入门
## 1). 使用create-react-app搭建react开发环境
	npm install create-react-app -g
	create-react-app antd-demo
	cd antd-demo
	npm start
## 2). 搭建antd的基本开发环境
	1. 下载
    	npm install antd@2.7.4 --save
	2. src/App.js
	    import React, { Component } from 'react';
	    import { Button } from 'antd';
	    import './App.css';
	    
	    class App extends Component {
	      render() {
	        return (
	          <div className="app">
	            <Button type="primary">Button</Button>
	          </div>
	        );
	      }
	    }
    	export default App;
	3. src/App.css
	    @import '~antd/dist/antd.css';
	    
	    .app {
	      text-align: center;
	    }

## 3). 实现按需打包(组件js/组件css)
	1. 使用eject命令将所有内建的配置暴露出来
    	npm run eject
	2. 下载babel-plugin-import(用于按需加载组件代码和样式的 babel 插件)
    	npm install babel-plugin-import --save-dev
	3. 修改配置: config/webpack.config.dev.js
	    // Process JS with Babel.
	    {
	      test: /\.(js|jsx)$/,
	      include: paths.appSrc,
	      loader: 'babel',
	      options: {
          +   plugins: [
          +     ['import', { libraryName: 'antd', style: 'css' }],
          +   ],
              // This is a feature of `babel-loader` for webpack (not Babel itself).
              // It enables caching results in ./node_modules/.cache/babel-loader/
              // directory for faster rebuilds.
              cacheDirectory: true
            }
		 },
	4. 去除引入全量样式的语句: src/App.css
	    @import '~antd/dist/antd.css' 



# 1. 使用React脚手架创建一个React应用
## 1). react脚手架
	1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目
		* 包含了所有需要的配置
		* 指定好了所有的依赖
		* 可以直接安装/编译/运行一个简单效果
	2. react提供了一个专门用于创建react项目的脚手架库: create-react-app
	3. 项目的整体技术架构为: react + webpack + es6 + eslint
## 2). 创建项目并启动
	npm install -g create-react-app
	create-react-app hello-react
	cd hello-react
	npm start
## 3). 使用脚手架开发的项目的特点
	模块化
	组件化
	工程化
## 4). 组件化编写项目的流程
	编写静态页面
	拆分页面, 抽取组件
	实现静态组件--->静态页面
	实现动态组件
		动态显示初始化数据
		交互

# 2. app1: 实现一个评论管理功能
## 1). 拆分组件:
	应用组件: App
	添加评论组件: CommentAdd
	评论项组件: CommentItem
	评论列表组件: CommentList
## 2). 确定组件的state和props:
	App: 
		* state: comments/array
	CommentAdd
		* state: username/string, content/string
		* props: add/func
	commentList
	  	* props: comments/array, delete/func
	CommentItem
		* props: comment/object, delete/func, index/number
## 3). 编写静态组件
	拆分页面
	拆分css
## 4). 实现动态组件
	1. 动态展示初始化数据
	  * 初始化状态数据
	  * 传递属性数据
	2. 响应用户操作, 更新组件界面
	  * 绑定事件监听, 并处理
	  * 更新state

# 3. app2: 实现github用户搜索功能
## 1). 拆分组件
	App
	Search
	List
## 2). 确定组件的state和props
    App
		* state: searchName/string
    Search
      	* props: setSearchName/func
    List
      	* props: searchName/string
      	* state: firstView/bool, loading/bool, users/array, errMsg/string
## 3). 编写组件
	编写静态组件
	编写动态组件
		componentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax
		使用axios库发送ajax请求

# 4. 组件间通信总结
## 1). 方式一: 通过props传递
	共同的数据放在父组件上, 特有的数据放在自己组件内部(state)
	通过props可以传递一般数据和函数数据, 只能一层一层传递
	一般数据-->父组件传递数据给子组件-->子组件读取数据
	函数数据-->子组件传递数据给父组件-->子组件调用函数
## 2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制
	工具库: PubSubJS
	下载: npm install pubsub-js --save
	使用: 
	  import PubSub from 'pubsub-js' //引入
	  PubSub.subscribe('delete', function(data){ }); //订阅
	  PubSub.publish('delete', data) //发布消息


## 3). 事件监听理解
	1. DOM事件
		* 绑定事件监听
			* 事件名(类型): 只有有限的几个, 不能随便写
			* 回调函数
		* 用户操作触发事件(event)
			* 事件名(类型)
			* 数据()
	2. 自定义事件
		* 绑定事件监听
			* 事件名(类型): 任意
			* 回调函数: 通过形参接收数据, 在函数体处理事件
		* 触发事件(编码)
			* 事件名(类型): 与绑定的事件监听的事件名一致
			* 数据: 会自动传递给回调函数
      
# 5. ES6新语法总结
	定义变量/常量: const/let
	解构赋值: let {a, b} = this.props   import {aa} from 'xxx'
	对象的简洁表达: {a, b}
	箭头函数: 
		组件的自定义方法: xxx = () => {}
		map/filter的回调方法: (item, index) => {}
		优点:
			* 简洁
			* 没有自己的this,使用引用this查找的是外部this
	扩展运算符: ...
		拆解对象:  const MyProps = {}, <Xxx {...MyProps}>
	类: class/extends/constructor/super
	ES6模块化(Babel): export default | import

# 6. 项目打包运行
	npm run build  //生成打包文件
	npm install -g pushstate-server  //全局下载服务器包
	pushstate-server build  //通过服务器命令运行打包项目
	访问: http://localhost:9000  //浏览器访问




react router

# 1. 理解react-router
	react的一个react插件库
	专门用来实现一个SPA(single Page App)应用
	基于react的项目基本都会用到此库

# 2. 几个重要问题
## 1). SPA应用
	单页Web应用（single page web application，SPA）
	整个应用只有一个完整的页面
	点击页面中的链接不会刷新页面, 本身也不会向服务器发请求
	当点击链接时, 只会做页面的局部更新
	数据都需要通过ajax请求获取, 并在前端异步展现
## 2). 路由
	1. 什么是路由?
		一个路由就是一个映射关系(key:value)
		key为路由路径, value可能是function/component
	2. 路由分类
		后台路由: node服务器端路由, value是function, 用来处理客户端提交的请求并返回一个响应数据
		前台路由: 浏览器端路由, value是component, 当请求的是路由path时, 浏览器端前没有发送http请求, 但界面会更新显示对应的组件 
	3. 后台路由
		* 注册路由: router.get(path, function(req, res))
		* 当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据
	* 前端路由
		* 注册路由: <Route path="/about" component={About}>
		* 当浏览器的hash变为#/about时, 当前路由组件就会变为About组件
		
		
    
    
## 3). 关于url中的#
	1. 理解#
		'#'代表网页中的一个位置。其右面的字符，就是该位置的标识符
		改变#不触发网页重载
		改变#会改变浏览器的访问历史
	2. 操作#
		window.location.hash读取#值
		window.onhashchange = func 监听hash改变
	3. 学习资源: 
		阮一峰教程: http://www.ruanyifeng.com/blog/2011/03/url_hash.html
	
# 3. react-router的学习资源
	github主页: https://github.com/ReactTraining/react-router
	官网教程: https://github.com/reactjs/react-router-tutorial
	阮一峰教程: http://www.ruanyifeng.com/blog/2016/05/react_router.html

# 4. 相关API
## 1). react-router中的相关组件: 
	Router: 路由器组件, 用来包含各个路由组件
	Route: 路由组件, 注册路由 
	IndexRoute: 默认路由组件
	hashHistory: 路由的切换由URL的hash变化决定，即URL的#部分发生变化
	Link: 路由链接组件
## 2). Router: 路由器组件
    属性:  history={hashHistory} 用来监听浏览器地址栏的变化, 并将URL解析成一个地址对象，供React Router匹配
    子组件: Route
## 3). Route: 路由组件
    属性1: path="/xxx"  
    属性2: component={Xxx}
    根路由组件: path="/"的组件, 一般为App
    子路由组件: 子<Route>配置的组件
## 4). IndexRoute: 默认路由
    当父路由被请求时, 默认就会请求此路由组件
## 5). hashHistory
    用于Router组件的history属性
    作用: 为地址url生成?_k=hash, 用于内部保存对应的state
## 6). Link: 路由链接
    属性1: to="/xxx"
    属性2: activeClassName="active"

# 5. react-router的基本使用
## 1). 下载
	npm install react-router --save
## 2). 定义各个路由组件
	1. About.js
	  import React from 'react'
	  function About() {
	    return <div>About组件内容</div>
	  }
	  export default About
    2. Home.js
      import React from 'react'
      function Home() {
        return <div>Home组件内容2</div>
      }
      export default Home
    3. Repos.js
      import React, {Component} from 'react'
      export default class Repos extends Component {
        render() {
          return (
            <div>Repos组件</div>
          )
        }
      }
	4. App.js
    import React, {Component} from 'react'
    import {Link} from 'react-router'
    
    export default class App extends Component {
      render() {
        return (
          <div>
            <h2>Hello, React Router!</h2>
            <ul>
              <li><Link to="/about" activeClassName="active">About2</Link></li>
              <li><Link to="/repos" activeClassName="active">Repos2</Link></li>
            </ul>
            {this.props.children}
          </div>
        )
      }
    }
## 3). index.js: 注册路由, 渲染路由器标签
    import React from 'react'
    import {render} from 'react-dom'
    import {Router, Route, IndexRoute, hashHistory} from 'react-router'
    import App from './modules/App'
    import About from './modules/About'
    import Repos from './modules/Repos'
    import Home from './modules/Home'
    
    render((
      <Router history={hashHistory}>
        <Route path="/" component={App}>
          <IndexRoute component={Home}/>
          <Route path="/about" component={About}></Route>
          <Route path="/repos" component={Repos}></Route>
        </Route>
      </Router>
    ), document.getElementById('app'))


## 3). 主页面: index.html
    <style>
      .active {
        color: red;
      }
    </style>

# 6. 向路由组件传递请求参数
## 1). repo.js: repos组件下的分路由组件
    import React from 'react'
    export default function ({params}) {
      let {username, repoName} = params
      return (
        <div>用户名:{username}, 仓库名:{repoName}</div>
      )
    }
## 2). repos.js
    import React from 'react'
    import NavLink from './NavLink'
    
    export default class Repos extends React.Component {
    
      constructor(props) {
        super(props);
        this.state = {
          repos: [
            {username: 'faceback', repoName: 'react'},
            {username: 'faceback', repoName: 'react-router'},
            {username: 'Angular', repoName: 'angular'},
            {username: 'Angular', repoName: 'angular-cli'}
          ]
        };
        this.handleSubmit = this.handleSubmit.bind(this)
      }
    
      handleSubmit () {
    
        const repos = this.state.repos
        repos.push({
          username: this.refs.username.value,
          repoName: this.refs.repoName.value
        })
        this.setState({repos})
        this.refs.username.value = ''
        this.refs.repoName.value = ''
      }
    
      render() {
        return (
          <div>
            <h2>Repos</h2>
            <ul>
              {
                this.state.repos.map((repo, index) => {
                  const to = `/repos/${repo.username}/${repo.repoName}`
                  return (
                    <li key={index}>
                      <Link to={to} activeClassName='active'>{repo.repoName}</Link>
                    </li>
                  )
                })
              }
              <li>
                <form onSubmit={this.handleSubmit}>
                  <input type="text" placeholder="用户名" ref='username'/> / {' '}
                  <input type="text" placeholder="仓库名" ref='repoName'/>{' '}
                  <button type="submit">添加</button>
                </form>
              </li>
            </ul>
            {this.props.children}
          </div>
        );
      }
    }
## 3). index.js: 配置路由
    <Route path="/repos" component={Repos}>
      <Route path="/repos/:username/:repoName" component={Repo}/>
    </Route>

# 7. 优化Link组件
## 1). NavLink.js
    import React from 'react'
    import {Link} from 'react-router'
    export default function NavLink(props) {
      return <Link {...props} activeClassName="active"/>
    }
## 2). Repos.js
    <NavLink to={to}>{repo.repoName}</NavLink>
    



reactnews

# 1. day01
## 1). 项目介绍
    双端自适应SPA
    react+antd+es6+webpack+babel
    模块化 / 组件化 / 工程化
## 2). 项目技术选型
    数据展现/交互/组件: react, react-router, antd
    前后台交互: axios, json, postman, API接口
    模块化: es6, babel
    工程化: webpack, create-react-app, eslint
## 3). API接口
    理解: url,请求方式, 请求参数格式, 响应数据格式
    接口文档
    对接口, 测接口, 调接口, 联调
    前后台分离, mock数据
    使用postman测试接口: 添加接口记录/导入接口记录/访问测试
## 4). 搭建项目
    使用react脚手架下载模板项目
    下载依赖的其它模块: react-router axios antd
    实现antd按需打包
    搭建SPA的整体结构
## 5). antd组件
    Row, Col: 行列布局
    Menu, MenuItem
    Icon
    Button
    Tabs, TabPane
    Form, ForItem
      export default Form.create()(Xxx)
      getFieldDector('username')(<Input>)
    Input
    message
## 6) ajax请求, 前后台交互
    使用axios提交异步请求
    在请求返回后, 根据响应数据的情况来做不同界面更新
    
# 2. day02
## 1). 自定义组件
    news_container组件: app组件的默认子路由
    news_block组件: 文本新闻列表, type/count
    news_image_block组件: 图片新闻列表, type/count/cardTitle/cardWidth/imageWidth
    news_products组件: 将静态页面转换为组件
## 2) antd组件
    Row/Col
    Card
    Tabs/TabPane
    Carousel
## 3) 双端自适应
    使用一个媒体查询的react插件(识别设备的宽度, 返回不同的界面): react-responsive
    
    
# 3. day03
## 1). 自定义组件
    news_detail组件: 显示新闻详情相关新闻列表
    news_comments组件: 新闻的评论列表/提交评论和收藏文章的功能
    user_center组件: 显示用户的收藏文章列表与评论列表和设置头像
## 2) antd组件
    Row/Col
    Form/FormItem/Input/Button
    BackTop
    Card
    Tabs/TabPane
    Modal
    Upload
## 3) rest api
### 理解rest api  / restful api
  * api接口的分类
    * restful: rest风格
    * restless: 非rest风格
  * rest接口
    * https://api.github.com/users/zxfjd3g
    * https://api.github.com/users/zxfjd3g/repos
    * 不用带行为参数, 参数是路径的一个节点
    * 请求的行为由请求方式来决定
      * get: 查询(读, 获取数据)  R read
      * post: 添加(保存), C create
      * delete: 删除, D delete
      * put: 更新, U update
  * 非rest接口
    * http://xxx.com/api/getUser
    * http://newsapi.gugujiankong.com/Handler.ashx?action=login&username=zxfjd3g&password=123123
    * 路径或参数中包含了行为数据
    * 一般只用2种请求方式:
      * get
      * post
## 模拟实现rest接口
  * 使用json-server库
  * 使用:
    * 下载 json-server
    * 创建一个数据库文件: src/mock/db.json
      {
        "users": [
          {"id": 1, "name": "Tom", age: 12},
          {"id": 2, "name": "Tom2", age: 13}
        ]
        "comment": {
          "id": 1, "username": "Tom", content: 'xxxx'
        }
      }
    * 启动服务器: json-server --watch src/mock/db.json
       http://localhost:3000/users
       http://localhost:3000/users/2
       http://localhost:3000/comment
  * postman/编码测试访问rest接口
    * axios
    * axios.get(): get请求, 查询
    * axios.post(): post请求, 保存
    * axios.put(): put请求, 更新
    * axios.delete(): delete请求, 删除
    
# 4. day04
  实现移动端的编码
  MobileApp
  MobileHeader
  MobileContainer(MobileNewsBlock)/MobileNewsDetail/MobileUserCenter
    



小飞

react

# 1. 几个重要概念理解
## 1). 模块与组件
	1. 模块:
	  	理解: 向外提供特定功能的js程序, 一般就是一个js文件
	  	为什么: js代码更多更复杂
	  	作用: 复用js, 简化js的编写, 提高js运行效率
	2. 组件: 
		理解: 用来实现特定功能效果的代码集合(html/css/js)
	  	为什么: 一个界面的功能太复杂了
	  	作用: 复用编码, 简化项目界面编码, 提高运行效率
![组件](http://i.imgur.com/YnVjluG.jpg)
## 2). 模块化与组件化
    1. 模块化:
    	当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
    2. 组件化:
    	当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用

# 2. React的基本认识
	1). Facebook开源的一个js库
	2). 一个用来动态构建用户界面的js库
	3). React的特点
		Declarative(声明式编码)
		Component-Based(组件化编码)
		Learn Once, Write Anywhere(支持客户端与服务器渲染)
		高效
		单向数据流
	4). React高效的原因
    	虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数) 
    	高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)
# 3. 使用React
	1). 导入相关js库文件(react.js, react-dom.js, babel.min.js)
	2). 编码:
		<div id="container"></div>
		<script type="text/babel">
			var aa = 123
			var bb = 'test'
			ReactDOM.render(<h1 id={bb}>{aa}</h1>, containerDOM)
		</script>

# 4. JSX
	1). 理解
		* 全称: JavaScript XML
		* react定义的一种类似于XML的JS扩展语法: XML+JS
		* 作用: 用来创建react虚拟DOM(元素)对象
	2). 编码相关
		* js中直接可以套标签, 但标签要套js需要放在{}中
		* 在解析显示js数组时, 会自动遍历显示
		* 把数据的数组转换为标签的数组: 
			var liArr = dataArr.map(function(item, index){
				return <li key={index}>{item}</li>
			})
	3). 注意:
	    * 标签必须有结束
	    * 标签的class属性必须改为className属性
	    * 标签的style属性值必须为: {{color:'red', width:12}}
    
# 5. Component : React是面向组件编程的(组件化编码开发)
## 1). 基本理解和使用
	1). 自定义的标签: 组件类(函数)/标签
	2). 创建组件类
		//方式1: 无状态函数(简单组件, 推荐使用)
		function MyComponent1(props) {
			return <h1>自定义组件标题11111</h1>
		}
		//方式2: ES6类语法(复杂组件, 推荐使用)
		class MyComponent3 extends React.Component {
			render () {
			  return <h1>自定义组件标题33333</h1>
			}
		}
		//方式3: ES5老语法(不推荐使用了)
		var MyComponent2 = React.createClass({
			render () {
			  return <h1>自定义组件标题22222</h1>
			}
		})
	3). 渲染组件标签
		ReactDOM.render(<MyComp />,  cotainerEle)
## 2). ReactDOM.render()渲染组件标签的基本流程
	React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象
	将虚拟DOM并解析为真实DOM
	插入到指定的页面元素内部
## 3). props
	所有组件标签的属性的集合对象
	给标签指定属性, 保存外部数据(可能是一个function)
	在组件内部读取属性: this.props.propertyName
	作用: 从目标组件外部向组件内部传递数据
	对props中的属性值进行类型限制和必要性限制
		Person.propTypes = {
			name: React.PropTypes.string.isRequired,
			age: React.PropTypes.number.isRequired
		}
	扩展属性: 将对象的所有属性通过props传递
	    <Person {...person}/>
## 4). 组件的组合
	组件标签中包含子组件标签
	拆分组件: 拆分界面, 抽取组件
	通过props传递数据
## 5). refs
	组件内包含ref属性的标签元素的集合对象
	给操作目标标签指定ref属性, 打一个标识
	在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)
	作用: 找到组件内部的真实dom元素对象, 进而操作它
## 6). 事件处理
	1. 给标签添加属性: onXxx={this.eventHandler}
	2. 在组件中添加事件处理方法
	    eventHandler(event) {
	                
	    }
	3. 使自定义方法中的this为组件对象
	  	在constructor()中bind(this)
	  	使用箭头函数定义方法(ES6模块化编码时才能使用)
	4. 事件监听
		绑定事件监听
			事件名
			回调函数
		触发事件
			用户对对应的界面做对应的操作
			编码
## 7). state
	1. 组件被称为"状态机", 页面的显示是根据组件的state属性的数据来显示
	2. 初始化指定:
        constructor() {
          super()
          this.state = {
            stateName1 : stateValue1,
            stateName2 : stateValue2
          }
        }
	3. 读取显示: 
	    this.state.stateName1
	4. 更新状态-->更新界面 : 
	    this.setState({stateName1 : newValue})
## 8). 实现一个双向绑定的组件
	React是单向数据流
	需要通过onChange监听手动实现
## 9). 组件生命周期
	1. 组件的三个生命周期状态:
		Mount：插入真实 DOM
		Update：被重新渲染
		Unmount：被移出真实 DOM
	2. 生命周期流程:
		* 第一次初始化显示
			constructor()
			componentWillMount() : 将要插入回调
			render() : 用于插入虚拟DOM回调
			componentDidMount() : 已经插入回调
		* 每次更新state
		    componentWillReceiveProps(): 接收父组件新的属性
		    componentWillUpdate() : 将要更新回调
		    render() : 更新(重新渲染)
		    componentDidUpdate() : 已经更新回调
		* 删除组件
			ReactDOM.unmountComponentAtNode(div): 移除组件
			componentWillUnmount() : 组件将要被移除回调
	3. 常用的方法
		render(): 必须重写, 返回一个自定义的虚拟DOM
	  	constructor(): 初始化状态, 绑定this(可以箭头函数代替)
	  	componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听
![组件生命周期](http://i.imgur.com/h5khD9F.png)

# 6. ajax
	1). React没有ajax模块
	2). 集成其它的js库(如axios/fetch/jQuery/), 发送ajax请求
		* axios
			* 封装XmlHttpRequest对象的ajax
			* promise
			* 可以用在浏览器端和服务器
	  	* fetch
	    	* 不再使用XmlHttpRequest对象提交ajax请求
	    	* fetch就是用来提交ajax请求的函数, 只是新的浏览才内置了fetch
	    	* 为了兼容低版本的浏览器, 可以引入fetch.js
	3). 在哪个方法去发送ajax请求
	  	* 只显示一次(请求一次): componentDidMount()
	  	* 显示多次(请求多次): componentWillReceiveProps()
	  
# 7. 虚拟DOM
## 1). 虚拟DOM是什么?
	一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)
	虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
	如果只是更新虚拟DOM, 页面是不会重绘的
## 2). Virtual DOM 算法的基本步骤
	用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
	当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
	把差异应用到真实DOM树上，视图就更新了
## 3). 进一步理解
    Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
    可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。
![](http://i.imgur.com/psaZdqN.png)


# 声明式与命令式
	声明式编程
		只关注做什么, 而不关注怎么做(流程),  类似于填空题
	命令式编程
		要关注做什么和怎么做(流程), 类似于问答题
	
	var arr = [1, 3, 5, 7]
	// 需求: 得到一个新的数组, 数组中每个元素都比arr中对应的元素大10: [11, 13, 15, 17]
	// 命令式编程
	var arr2 = []
	for(var i =0;i<arr.length;i++) {
		arr2.push(arr[i]+10)
	}
	console.log(arr2)
	// 声明式编程
	var arr3 = arr.map(function(item){
		return item +10
	})
	// 声明式编程是建立命令式编程的基础上
	
	// 数组中常见声明式方法
		map() / forEach() / find() / findIndex()


<!--
1. ReactJS是什么?
1). Facebook开源的一个js库
2). 一个用于动态构建用户界面的js库
3). React的特点
  * Declarative(声明式编码)
  * Component-Based(组件化编码)
  * Learn Once, Write Anywhere(支持客户端与服务器渲染)
  * 高效
  * 单向数据流
4). ReactJS官网：http://facebook.github.io/react/
5). Github地址：https://github.com/facebook/react
2. React高效的原因
1). 虚拟(virtual)DOM, 不总是直接操作DOM
2). 高效的DOM Diff算法, 最小化页面重绘
-->

react高效的原因：
1.减少次数，虚拟DOM；
2.减小重绘区域。

原始->模块化->组件化

ajax和hp请求的区别？

服务器发送的是JSON数据。

babel的作用：
1.将ES6编译成ES5;
2.将JSX编译成JS;

使用jsx时，要用这种script标签：
<script type="text/babel">
  //jsx代码
</script>

build（构建/打包）包括编译、合并、压缩等过程。

数组VS对象：
1.数组有序，
2.键值对的呈现方式不同

什么是回调函数？
1.你定义的；
2.你没有调用；
3.但是它执行了。

# 1. 几个重要概念理解
## 1). 模块与组件
	1. 模块:
	  	理解: 向外提供特定功能的js程序, 一般就是一个js文件
	  	为什么: js代码更多更复杂
	  	作用: 复用js, 简化js的编写, 提高js运行效率
	2. 组件:
		理解: 用来实现特定功能效果的代码集合(html/css/js)
	  	为什么: 一个界面的功能太复杂了
	  	作用: 复用编码, 简化项目界面编码, 提高运行效率
![组件](http://i.imgur.com/YnVjluG.jpg)
## 2). 模块化与组件化
    1. 模块化:
    	当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
    2. 组件化:
    	当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用

# 2. React的基本认识
	1). Facebook开源的一个js库
	2). 一个用来动态构建用户界面的js库
	3). React的特点
		Declarative(声明式编码)
		Component-Based(组件化编码)
		Learn Once, Write Anywhere(支持客户端与服务器渲染)
		高效
		单向数据流
	4). React高效的原因
    	虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数)
    	高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)
# 3. 使用React
	1). 导入相关js库文件(react.js, react-dom.js, babel.min.js)
	2). 编码:
		<div id="container"></div>
		<script type="text/babel">
			var aa = 123
			var bb = 'test'
			ReactDOM.render(<h1 id={bb}>{aa}</h1>, containerDOM)
		</script>

# 4. JSX
	1). 理解
		* 全称: JavaScript XML
		* react定义的一种类似于XML的JS扩展语法: XML+JS
		* 作用: 用来创建react虚拟DOM(元素)对象
	2). 编码相关
		* js中直接可以套标签, 但标签要套js需要放在{}中
		* 在解析显示js数组时, 会自动遍历显示
		* 把数据的数组转换为标签的数组:
			var liArr = dataArr.map(function(item, index){
				return <li key={index}>{item}</li>
			})
	3). 注意:
	    * 标签必须有结束
	    * 标签的class属性必须改为className属性
	    * 标签的style属性值必须为: {{color:'red', width:12}}

# 5. Component : React是面向组件编程的(组件化编码开发)
## 1). 基本理解和使用
	1). 自定义的标签: 组件类(函数)/标签
	2). 创建组件类
		//方式1: 无状态函数(简单组件, 推荐使用)
		function MyComponent1() {
			return <h1>自定义组件标题11111</h1>
		}
		//方式2: ES6类语法(复杂组件, 推荐使用)
		class MyComponent3 extends React.Component {
			render () {
			  return <h1>自定义组件标题33333</h1>
			}
		}
		//方式3: ES5老语法(不推荐使用了)
		var MyComponent2 = React.createClass({
			render () {
			  return <h1>自定义组件标题22222</h1>
			}
		})
	3). 渲染组件标签
		ReactDOM.render(<MyComp />,  cotainerEle)
## 2). ReactDOM.render()渲染组件标签的基本流程
	React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象
	将虚拟DOM并解析为真实DOM
	插入到指定的页面元素内部
## 3). props
	所有组件标签的属性的集合对象
	给标签指定属性, 保存外部数据(可能是一个function)
	在组件内部读取属性: this.props.propertyName
	作用: 从目标组件外部向组件内部传递数据
	对props中的属性值进行类型限制和必要性限制
		Person.propTypes = {
			name: React.PropTypes.string.isRequired,
			age: React.PropTypes.number.isRequired
		}
	扩展属性: 将对象的所有属性通过props传递
	    <Person {...person}/>
## 4). 组件的组合
	组件标签中包含子组件标签
	拆分组件: 拆分界面, 抽取组件
	通过props传递数据
## 5). refs
	组件内包含ref属性的标签元素的集合对象
	给操作目标标签指定ref属性, 打一个标识
	在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)
	作用: 找到组件内部的真实dom元素对象, 进而操作它
## 6). 事件处理
	1. 给标签添加属性: onXxx={this.eventHandler}
	2. 在组件中添加事件处理方法
	    eventHandler(event) {

	    }
	3. 使自定义方法中的this为组件对象
	  	在constructor()中bind(this)
	  	//就是将用bind()绑定this后的方法替换掉之前的方法，效果其实就是只有this变了，之前的被干掉了
	  	使用箭头函数定义方法(ES6模块化编码时才能使用)?
## 7). state
	1. 组件被称为"状态机", 页面的显示是根据组件的state属性的数据来显示
	2. 初始化指定:
        constructor() {
          super()
          this.state = {
            stateName1 : stateValue1,
            stateName2 : stateValue2
          }
        }
	3. 读取显示:
	    this.state.stateName1
	4. 更新状态-->更新界面 :
	    this.setState({stateName1 : newValue})
## 8). 实现一个双向绑定的组件
	React是单向数据流
	需要通过onChange监听手动实现
## 9). 组件生命周期
	1. 组件的三个生命周期状态:
		Mount：插入真实 DOM
		Update：被重新渲染
		Unmount：被移出真实 DOM
	2. 生命周期流程:
		* 第一次初始化显示
			constructor()
			componentWillMount() : 将要插入回调
			render() : 用于插入虚拟DOM回调
			componentDidMount() : 已经插入回调
		* 每次更新state
		    componentWillReceiveProps(): 接收父组件新的属性
		    componentWillUpdate() : 将要更新回调
		    render() : 更新(重新渲染)
		    componentDidUpdate() : 已经更新回调
		* 删除组件
			ReactDOM.unmountComponentAtNode(div): 移除组件
			componentWillUnmount() : 组件将要被移除回调
	3. 常用的方法
		render(): 必须重写, 返回一个自定义的虚拟DOM
	  	constructor(): 初始化状态, 绑定this(可以箭头函数代替)
	  	componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听
![组件生命周期](http://i.imgur.com/h5khD9F.png)

# 6. ajax
	1). React没有ajax模块
	2). 集成其它的js库(如axios/fetch/jQuery/), 发送ajax请求
		* axios
			* 封装XmlHttpRequest对象的ajax
			* promise
			* 可以用在浏览器端和服务器
	  	* fetch
	    	* 不再使用XmlHttpRequest对象提交ajax请求
	    	* fetch就是用来提交ajax请求的函数, 只是新的浏览才内置了fetch
	    	* 为了兼容低版本的浏览器, 可以引入fetch.js
	3). 在哪个方法去发送ajax请求
	  	* 只显示一次(请求一次): componentDidMount()
	  	* 显示多次(请求多次): componentWillReceiveProps()

# 7. 虚拟DOM
## 1). 虚拟DOM是什么?
	一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)
	虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
	如果只是更新虚拟DOM, 页面是不会重绘的
## 2). Virtual DOM 算法的基本步骤
	用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
	当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
	把差异应用到真实DOM树上，视图就更新了
## 3). 进一步理解
    Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
    可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。
![](http://i.imgur.com/psaZdqN.png)

# git管理项目的流程
## 1. 本地管理
	创建.gitignore文件, 并指定需要忽略文件/文件夹
	git init
	git add *
	git commit -m "init app"
## 2. 创建远程仓库
## 3. 推送到远程
	git remote add origin https://github.com/zxfjd3g/170507_reactTest.git
	git push origin master
## 4. 修改代码
	git add *
	git commit -m "update"
	git push origin master
## 5. 你们
	git clone https://github.com/zxfjd3g/170507_reactTest.git
	git pull origin master



<!--
1. 相关js库
  react.js: React的核心库
  react-dom.js: 提供操作DOM的扩展库
  babel.min.js: 解析JSX语法代码转为纯JS语法代码的库
2. 在页面中导入js
  <script type="text/javascript" src="../js/react.js"></script>
  <script type="text/javascript" src="../js/react-dom.js"></script>
  <script type="text/javascript" src="../js/babel.min.js"></script>
3. 编码
  <div id="example"></div>
  <script type="text/babel"> //必须用babel
    ReactDOM.render(<h1>Hello, React!</h1>, document.getElementById('example'));
  </script>
-->

demo:
let msgDom='hello bxq';
let idDom='id1';
const htmDom=<h2 id={idDom}>{msgDom}</h2>
ReactDOM.render(htmDom,document.getElementById('box'));


demo:
var stus=['a','b','c'];
const ulRct=<ul>{
  stus.map((item,index)=>
    <li key={index}>{item}</li>
  )
}</ul>;
ReactDOM.render(ulRct,document.getElementById('box'));


<!--
1. 虚拟DOM
  1). React提供了一些API来创建一种 `特别` 的一般js对象
    * var element = React.createElement('h1', {id:'myTitle'}, 'hello');
    * 上面创建的就是一个简单的虚拟DOM对象
  2). 虚拟DOM对象最终都会被React转换为真实的DOM
  3). 我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界面
2. JSX
  1). 全称: JavaScript XML
  2). react定义的一种类似于XML的JS扩展语法: XML+JS
  3). 作用: 用来创建react虚拟DOM(元素)对象
    * var ele = <h1>Hello JSX!</h1>;
    * 注意1: 它不是字符串, 也不是HTML/XML标签
    * 注意2: 它最终产生的就是一个JS对象
  4). 标签名任意: HTML标签或其它标签
  5). 标签属性任意: HTML标签属性或其它
  6). 基本语法规则
    * 遇到 <开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析
    * 遇到以 { 开头的代码，以JS的语法解析: 标签中的js代码必须用{}包含
  7). babel.js的作用
    * 浏览器的js引擎是不能直接解析JSX语法代码的, 需要babel转译为纯JS的代码才能运行
    * 只要用了JSX，都要加上type="text/babel", 声明需要babel来处理
3. 渲染虚拟DOM(元素)
  1). 语法: ReactDOM.render(virtualDOM, containerDOM) :
  2). 作用: 将虚拟DOM元素渲染到真实容器DOM中显示
  3). 参数说明
    * 参数一: 纯js或jsx创建的虚拟dom对象
    * 参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)
4. 创建虚拟DOM的2种方式:
  1). 纯JS(一般不用):
    React.createElement('h1', {id:'myTitle'}, title)
  2). JSX:
    <h1 id='myTitle'>{title}</h1>
-->

JSX最终产生的就是一个JS对象。

/*
1. 自定义组件(Component) :
  1). 定义组件
    //方式1: 工厂(无状态)函数(简单组件, 推荐使用)
    function MyComponent1() {
      return <h1>自定义组件标题11111</h1>
    }
    //方式2: ES6类语法(复杂组件, 推荐使用)
    class MyComponent3 extends React.Component {
      render () {
        return <h1>自定义组件标题33333</h1>
      }
    }
    //方式3: ES5老语法(不推荐使用了)
    var MyComponent2 = React.createClass({ // 配置对象
      render () {
        return <h1>自定义组件标题22222</h1>
      }
    })
  2). 渲染组件标签
    ReactDOM.render(<MyComponent/>, document.getElementById('example'));
2. 注意:
  1). 返回的组件类必须首字母大写
  2). 虚拟DOM元素必须只有一个根元素
  3). 虚拟DOM元素必须有结束标签
3. ReactDOM.render()渲染组件标签的基本流程
  1). React内部会创建组件实例对象
  2). 调用render()得到包含的虚拟DOM并解析为真实DOM
  3). 插入到指定的页面元素内部
*/


//1.定义组件
//方式1：工厂（无状态）函数（简单组件，推荐使用）
function MyComponentOne() {
  return <h1>工厂（无状态）函数</h1>
}
//方式2：ES6类语法（复杂组件，推荐使用）
class MyComponentTwo extends React.Component {
  render(){
    console.log(this);//MyComponentTwo的实例对象
    return <h1>ES6类语法</h1>
  }
}
//方式3：ES5老语法（不推荐使用）
const MyComponentThree=React.createClass({
  render(){
    return <h1>ES5老语法</h1>
  }
});

//2.渲染组件标签
ReactDOM.render(<MyComponentOne />,document.getElementById('box1'));
ReactDOM.render(<MyComponentTwo />,document.getElementById('box2'));
ReactDOM.render(<MyComponentThree />,document.getElementById('box3'));




/*
组件3大属性之一: props属性
1. 每个组件对象都会有props(properties的简写)属性
2. 组件标签的所有属性都保存在props中
3. 内部读取某个属性值: this.props.propertyName
4. 作用: 通过标签属性从组件外向组件内传递数据(只读)
5. 对props中的属性值进行类型限制和必要性限制
  Person.propTypes = {
    name: React.PropTypes.string.isRequired,
    age: React.PropTypes.number
  }
6. 扩展属性: 将对象的所有属性通过props传递
  <Person {...person}/>
7. 默认属性值
  Person.defaultProps = {
    name: 'Mary'
  }
8. 组件类的构造函数
  constructor (props) {
    super(props)
    console.log(props) // 查看所有属性
  }

问题: 为什么要设计对prop会进行约束的语法?
*/


//定义组件类
class Stu extends React.Component {
  render(){
    return (
        <ul>
          <li>姓名: {this.props.name}</li>
          <li>性别: {this.props.sex}</li>
          <li>年龄: {this.props.age}</li>
        </ul>
    )
  }
}
//对标签属性进行限制
Stu.propTypes={
  //注意以下的PropTypes开头的P都是大写！！！！！！！！！！！！！！
  name: React.PropTypes.string.isRequired,
  sex: React.PropTypes,
  age: React.PropTypes
};
//指定属性默认值
Stu.defaultProps={
  sex: '男',
  age: 18
};
//渲染组件标签
const stu1={
  myName: '范冰冰',
};
ReactDOM.render(<Stu name={stu1.myName}/>,document.getElementById('box1'));
const stu2={
  name:'liudehua',
  gender:'male'
}
ReactDOM.render(<Stu {...stu1}/>,document.getElementById('box2'));






component_composing------>
(两个组件结合起来)


const names = ['feifei', 'xinxin', 'yiyi']
// 定义Welcome组件
class Welcome extends React.Component {
  render () {
    return <h1>Welcome {this.props.name}!</h1>
  }
}
Welcome.propTypes = {
  name: React.PropTypes.string.isRequired
}
// 定义App组件
class App extends React.Component {
  render () {
    return (
      // 必须有根标签
      <div>
        {
          // 根据数据数组生成一个标签的数组
          this.props.names.map((name, index) => <Welcome name={name} key={index}/>)
        }
      </div>
    )
  }
}
App.propTypes = {
  names: React.PropTypes.array.isRequired
}
// 渲染App组件标签到页面div中
ReactDOM.render(<App names={names}/>, document.getElementById('example'))





/*
1. 组件的3大属性之二: refs属性
  1). 组件内的标签都可以定义ref属性来标识自己（类似id）
  2). 在组件中可以通过this.refs.refName来得到对应的真实DOM对象
  3). 作用: 用于操作指定的ref属性的dom元素对象(表单标签居多)
    * <input ref='username'>
    * this.refs.username //返回input对象
2. 事件处理
  1). 通过onXxx属性指定组件的事件处理函数(注意大小写)
    * React使用的是自定义(合成)事件, 而不是使用的DOM事件
    * React中的事件是通过委托方式处理的(委托给组件最外层的元素)
  2). 通过event.target得到发生事件的DOM元素对象
    <input onFocus={this.handleClick}/>
    handleFocus(event) {
      event.target  //返回input对象
    }
3. 强烈注意
  1). 组件内置的方法中的this为组件对象
  2). 在组件中自定义的方法中的this为null
    * 强制绑定this
    * 箭头函数(ES6模块化编码时才能使用)
4. 问题: 如何给一个函数强制指定内部的this?
  function test(){

  }
  test = test.bind(obj)
  test()
*/


//定义组件
class MyComponent extends React.Component {
  constructor(props) {
    super(props) // 调用父类(Component)的构造函数
    //console.log(this)
    // 将自定义的函数强制绑定为组件对象
    this.handleClick = this.handleClick.bind(this)
    // 将返回函数中的this强制绑定为指定的对象, 并没有改变原来的函数中的this，而是生成了一个新的handleClick
  }
  // 自定义的方法中的this默认为null
  handleClick () {
    // alert(this) //this默认是null, 而不是组件对象
    // 得到输入框对象,
    const input = this.refs.msg
    //得到它的值, 并提示
    alert(input.value)
  }
  handleBlur (event) {
    alert(event.target.value)
  }
  render () {
    return (
      <div>
        <input type="text" ref="msg"/>
        <button onClick={this.handleClick}>提示输入数据</button>
        <input type="text" placeholder="失去焦点提示数据" onBlur={this.handleBlur}/>
      </div>
    )
  }
}
// 渲染组件标签
ReactDOM.render(<MyComponent/>, document.getElementById('example'))





/*
组件3大属性之: state属性
  1). 组件被称为"状态机", 通过更新组件的状态值来更新对应的页面显示(重新渲染)
  2). 初始化状态:
    constructor (props) {
      super(props)
      this.state = {
        stateProp1 : value1,
        stateProp2 : value2
      }
    }
  3). 读取某个状态值
    this.state.statePropertyName
  4). 更新状态---->组件界面更新
    this.setState({
      stateProp1 : value1,
      stateProp2 : value2
    })
  5). 问题: 请区别一下组件的props和state属性?
*/

/*
需求: 自定义组件, 功能说明如下
  1. 显示h2标题, 初始文本为: 你喜欢我
  2. 点击标题更新为: 我喜欢你
*/
class Like extends React.Component {
  constructor (props) {
    super(props)
    // 初始化状态
    this.state = {
      isLikeMe: true
    }
    // 绑定this为组件对象
    this.change = this.change.bind(this)
  }
  change () {
    // 更新状态: this.setState()
    // this.state.isLikeMe = !this.state.isLikeMe // 不能更新更新某个状态
    this.setState({
      isLikeMe: !this.state.isLikeMe
    })
  }
  render () {
    console.log('render()')
    const text = this.state.isLikeMe ? '你喜欢我' : '我喜欢你'
    return <h2 onClick={this.change}>{text}</h2>
  }
}
ReactDOM.render(<Like/>, document.getElementById('example'))





# 1. 使用React脚手架创建一个React应用
## 1). react脚手架
	1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目
		* 包含了所有需要的配置
		* 指定好了所有的依赖
		* 可以直接安装/编译/运行一个简单效果
	2. react提供了一个专门用于创建react项目的脚手架库: create-react-app
	3. 项目的整体技术架构为: react + webpack + es6 + eslint
## 2). 创建项目并启动
	npm install -g create-react-app
	create-react-app hello-react
	cd hello-react
	npm start
## 3). 使用脚手架开发的项目的特点
	模块化
	组件化
	工程化
## 4). 组件化编写项目的流程
	编写静态页面
	拆分页面, 抽取组件
	实现静态组件--->静态页面
	实现动态组件
		动态显示初始化数据
		交互

# 2. app1: 实现一个评论管理功能
## 1). 拆分组件:
	应用组件: App
	添加评论组件: CommentAdd
	评论项组件: CommentItem
	评论列表组件: CommentList
## 2). 确定组件的state和props:
	App: 
		* state: comments/array
	CommentAdd
		* state: username/string, content/string
		* props: add/func
	commentList
	  	* props: comments/array, delete/func
	CommentItem
		* props: comment/object, delete/func, index/number
## 3). 编写静态组件
	拆分页面
	拆分css
## 4). 实现动态组件
	1. 动态展示初始化数据
	  * 初始化状态数据
	  * 传递属性数据
	2. 响应用户操作, 更新组件界面
	  * 绑定事件监听, 并处理
	  * 更新state

# 3. app2: 实现github用户搜索功能
## 1). 拆分组件
	App
	Search
	List
## 2). 确定组件的state和props
    App
		* state: searchName/string
    Search
      	* props: setSearchName/func
    List
      	* props: searchName/string
      	* state: firstView/bool, loading/bool, users/array, errMsg/string
## 3). 编写组件
	编写静态组件
	编写动态组件
		componentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax
		使用axios库发送ajax请求

# 4. 组件间通信总结
## 1). 方式一: 通过props传递
	共同的数据放在父组件上, 特有的数据放在自己组件内部(state)
	通过props可以传递一般数据和函数数据, 只能一层一层传递
	一般数据-->父组件传递数据给子组件-->子组件读取数据
	函数数据-->子组件传递数据给父组件-->子组件调用函数
## 2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制
	工具库: PubSubJS
	下载: npm install pubsub-js --save
	使用: 
	  import PubSub from 'pubsub-js' //引入
	  PubSub.subscribe('delete', function(data){ }); //订阅
	  PubSub.publish('delete', data) //发布消息


## 3). 事件监听理解
	1. DOM事件
		* 绑定事件监听
			* 事件名(类型): 只有有限的几个, 不能随便写
			* 回调函数
		* 用户操作触发事件(event)
			* 事件名(类型)
			* 数据()
	2. 自定义事件
		* 绑定事件监听
			* 事件名(类型): 任意
			* 回调函数: 通过形参接收数据, 在函数体处理事件
		* 触发事件(编码)
			* 事件名(类型): 与绑定的事件监听的事件名一致
			* 数据: 会自动传递给回调函数
      
# 5. ES6新语法总结
	定义变量/常量: const/let
	解构赋值: let {a, b} = this.props   import {aa} from 'xxx'
	对象的简洁表达: {a, b}
	箭头函数: 
		组件的自定义方法: xxx = () => {}
		map/filter的回调方法: (item, index) => {}
		优点:
			* 简洁
			* 没有自己的this,使用引用this查找的是外部this
	扩展运算符: ...
		拆解对象:  const MyProps = {}, <Xxx {...MyProps}>
	类: class/extends/constructor/super
	ES6模块化(Babel): export default | import

# 6. 项目打包运行
	npm run build  //生成打包文件
	npm install -g pushstate-server  //全局下载服务器包
	pushstate-server build  //通过服务器命令运行打包项目
	访问: http://localhost:9000  //浏览器访问





脚手架

# 1. 下载相关模块包
	1). react相关库
    	npm install react react-dom --save
	2). babel相关库
    	npm install babel-core babel-preset-es2015 babel-preset-react --save-dev
	3). webpack相关库
	    // 不使用webpack2.x的版本
	    npm install webpack@1.13.0 webpack-dev-server@1.16.4 --save-dev
		npm install css-loader style-loader babel-loader@7.0.0 --save-dev

# 2. webpack配置文件: webpack.config.js
	module.exports = {
		//入口
		entry:'./src/js/main.js',
		output:{
			path : __dirname,
			filename : './dist/bundle.js'
		},
		module : {
			loaders : [
				{
					test: /\.js$/,
					exclude: /node_modules/, //排除此文件夹
					loader: 'babel-loader'
				},
				{
					test: /\.css$/,
					loader: 'style-loader!css-loader'
				}
			]
		},
		devServer:{
			contentBase: './',//内置服务器动态加载页面所在的目录
			historyApiFallback:true,//不跳转
			inline:true //inline模式支持HMR
		}
	}

# 3. babel配置文件: .babelrc
	{
		"presets": ["es2015", "react"]
	}

# 4. 编码
## src/js/App.js: 应用组件
    import React from 'react'
    export default function App() {
      return <h1>Hello React Client Component</h1>
    }
## src/js/main.js: 入口js
	import '../css/test.css'
    import React from 'react'
    import ReactDOM from 'react-dom'
    import App from './App'

    //渲染组件标签到页面元素
    ReactDOM.render(<App />, document.getElementById('demo'))
## src/css/test.css
	body{
	    background: deeppink;
	}
## index.html
	<div id="container"></div>
	<script type='text/javascript' src='dist/bundle.js'></script>
## package.json: 添加编译/运行脚本
	"scripts": {
		"start": "webpack-dev-server",
		"build": "webpack"
	}




脚手架初次使用

npm install -g create-react-app

create-react-app my-app   //这里‘my-app’是随便起的名字。然后他就一直下载依赖
cd my-app/            //下载完之后进入所创建的文件夹中
npm start             //编译打包加运行。然后执行。

//不要乱删东西，容易出错。
（如果想要把那两个测试的文件删掉，注意吧index.js里的相关语句也删掉）

设置react jsx
//在webstorm里会出现一堆红，
在setting里设置javascript的语言为react-jsx就行了。

npm run build   //生成打包文件。因为start是在内存里面打包运行的，根本没有打包文件。

真正的运行时把build文件发给后台。

我们测试用的小型服务器包：
npm install -g pushstate-server  //全局下载服务器包
pushstate-server build        //通过服务器命令运行打包项目
访问：http://localhost:9000   //浏览器访问

项目-评论：

在react脚手架生成的文件中，
创建comment_page文件夹（即和node_modules同级的文件夹）
里面的东西是小飞提供的。

第一步：编写静态页面（就是小飞copy的静态页面）

第二步：拆分页面。App Add List Item
//每个组件都包含标签结构和js，但是就是没有css，所以需要再定义css文件

文件结构
src
   >index.js
   >components
      >App>App.js
      >Add>Add.js
      >List>List.js
      >Item>Item.js



>index.js

import React from 'react'
import {render} from 'react-dom'
import App from './components/App/App'

render(<App />,document.getElementById('root'))



>App.js

import React,{Component} from 'react'
export default class App extends Component{
  render(){
    return(
      <div></div>
    )
  }
}

然后把comment_page里index.html中id为app的div里的内容全部复制到return()里面。

报错清理：
1.把所有的class改成className, //class是jsx中的关键字，要用className代替。
注意export default class App extends Component力的class不能改。
2.把style='display:none' 改为 style={{display:'none'}}
3.结束标签都加上。



>Add.js

import React,{Component} from 'react'
export default class Add extends Component{
  render(){
    return(
      <div></div>
    )
  }
}

然后把App.js中的Add部分的代码（container下的第一个div）剪切到Add.js中的return()中。



>List.js

import React,{Component} from 'react'
export default class List extends Component{
  render(){
    return(
      <div></div>
    )
  }
}

然后把App.js中的List部分的代码（container下的第二个div）剪切到List.js中的return()中。


>App.js

//引入组件
import Add from '../Add/Add'
import List from '../List/List'

在<div className='container'></div>中加入：
<Add></Add>
<List></List>



拆分css:

将bootstrap.css复制到在public里面：
public>index.html
<link href='bootstrap.css'>

List>list.css
拷贝index.css

>List.js
import './list.css'


npm start 得到一个静态页面。



>App.js
（1）在类里面：
constructor(props){
  super(props)
  //初始化状态
  this.state={
    comments:[
      {username:'Tom',content:'good'},
      {username:'jack',content:'bad'}
    ]
  }
}
（2）在render()里面：
const {comments}=this.state    //通过对象的结构赋值得到this.state.comments
<List comments={comments}></List>   //然后将comments传给<List></List>组件



>List.js
（1）在class中传入comments：
static protoTypes={
//propTypes添加给了List，不同于之前的方法，之前用.的方法在这里是不适用的，因为这里export是和class是连写的，如果像之前那样写的话就难以暴露.protoType(这个P是大写吗？)
  comments:PropTypes.array.isRequired   //注意这里又有简写
}
（2）读取显示comments:
在render()中，
const {comments}=this.props
（3）item应该动态生成。
      将item剪切到Item.js中。

>Item.js
import React,{Component,PropTypes} from 'react'
export default class Item extends Component{
  render(){
    return(
      剪切来的<li></li>
    )
  }
}

>List.js
引入Item组件：
import Item from '../Item/Item'
使用Item组件，将comments里的comment传给Item组件。
<ul>标签里面：
{
  comments.map((comment,index)=><Item key={index} comment={comment}></Item>)
}


(1)在Item中传入comment,
(Item组件接收comment):
static propTypes={
  comment:PropTypes.object.isRequired
}
(2)读取显示comment:
const {comment}=this.props
(3)将{comment.username}和{comment.content}植入到代码结构中。
（即用它们将死的数据替换掉）。

给Item引入样式：
（因为之前的样式都放在List里面，现在List和Item分离了，样式也要分离出来）
>Item>item.css
复制过来。
>Item>item.js
import './item.css'




添加评论：


>Add.js

在提交按钮上添加事件：
onClick={this.submit}

在输入框获取输入框的值：
ref='username'

另一种获得的方法，在评论内容框上做实验：
onChange={this.handleChange}
//handleChange会自动搜索数据，也就是监控状态的变化，所以这种方法麻烦之处是需要加一个初始状态
初始化一个state。（值为content:''）
const {content}=this.state
在该标签中引入value={content}


之前的写法，在class中写入：
submit(){
  ...
}
但是这样的this会出现问题。（这些自定义的this都是null）

用箭头函数就没事：
submit = () => {

}
handleChange = (event) => {
  //先进行初始化状态，再进入这步
  const content=event.target.value  //得到最新输入的值
  this.setState({content})    //更新状态
}

初始化状态：
以前的写法：
constructor(props){
  super(props)
  this.state={
    content:''
  }
}
新的写法：
state = {//给Add的实例对象添加State属性
  content:''
}


然后进行username的处理：
submit = () => {
  //得到输入的数据
  const username=this.refs.username.value
  const {content}=this.state  //已经有初始状态了，直接获取就行
  //根据这两个数据包装成comment对象
  const comment={username,content}
  //然后添加到comments中显示,这个对象将再App.js中被addComment方法添加到comments中
}



>App.js
addComment = (comment) => {
  const {comments}=this.state
  comments.unshift(comment)
  this.setState({comments})
}
然后把这个方法交给Add用:
（也就是把它放在<Add>标签里）
addComment={this.addComment}


>Add.js
static propTypes={//给Add添加属性
  addComment:PropTypes.func.isRequired
}
submit = () => {
  ...
  this.props.addComment(comment)
}


npm start
修正： {Component,PropTypes}



点击增加输入框清空的功能：
>Add.js
submit=()=>{
  ~ const username=this.refs.username.value.trim()  //.trim()
  ~ const content=this.state.content.trim()

  //检查
  if(!username||!content){
    return
  }

  const comment={username,content}
  this.props.addComment(comment)

  //清除输入
  this.refs.username.value=''
  this.setState({content: ''})
}




删除：

>App.js
deleteComment = (index) => {
  const {comments}=this.state
  comments.splice(index,1)  //删除指定下标的元素
  this.setState({comments})
}
<List comments={comments} deleteComment={this.deleteComment}>


>List.js
static propTypes={
  ...
  deleteComment:PropTypes.func.isRequired
  //这个方法是App传给它，然后它传给Item的，虽然它自己不用，但是还是要声明一下
}
  ->render()
const {comments,deleteComment} = this.props
<Item deleteComment={deleteComment}>

<Item>太长了可以这样写：
(
  <Item>...</Item>
)
或这样写：
{
  return <Item>...</Item>
}

终于传到Item.js里：
>Item.js
static propTypes={
  deleteComment:PropTypes.func.isRequired
}
<a onClick={this.deleteItem}>删除</a>
deleteItem = () => {
  const {comment,deleteComment}=this.props
  //下面这个不写window会报错
  if(window.confirm(`确定删除${comment.username}的评论吗？`)){
    deleteComment(index)
  }
}

传index
>List.js
<Item index={index}></Item>

>Item.js
static propTypes={
  index:PropTypes.number.isRequired
}
deleteItem = () => {
  const {comment,deleteComment,index} = this.props
}


删完之后的文本提示：

>List.js
const display=comments.length===0 ? 'block' : 'none'
<h2 style={{display}}></h2>     //等同于{{display:display}}











websocket

实现浏览器与服务器的全双工通信。
服务器开始主动发送请求。
以往的http请求是追求型的，浏览器发request，服务器才发response
H5推出的websocket才是正常交往型的，服务器开始主动发送信息。
请求也变小了，不像之前用很大的header却只包含很少的数据。


原型
function People (){}
People.prototype.constructor===People

无论是Object.prototype, Function.prototype, string.prototype, 自定义构造函数的prototype都不是开发者创建的。
而是Function构造函数在创建其他构造函数时，用Object()创建的。
Function构造函数是万物之主。
创建了javascript语言世界和运行机制。
Object本质就是用于创建原型对象。

Function构造函数的内部有一个this.prototype=new Object()

Function构造函数创建了Array构造函数，
同时通过new Object()给其创建了prototype对象。

Function自己创建了自己，正是在创建自己的时候，通过this.prototype=new Object()给自己也创建了原型对象，这个原型对象由于是new Object实例化的，因此这个原型对象也就继承了Object和Object.prototype原型对象的属性。new Object就是给某某某发一个通往自己的prototype的__proto__。这样说来，Object原型对象是原型链中最顶层的一个对象。

Function.prototype虽然继承了Object.prototype中的数据，但还是扩展了自己专有的属性和方法，
分别是name，length, call(), apply(), bind()

所有的函数都是由Function创建的。

prototype指的是实例共有的区域，this.prototype=new Object指的是，
所有的共有区域，都拥有一个共有区域，就是Object提供的共有区域Object.prototype

因为设定的函数的__proto__是指向prototype，这也是继承的方式，所以为了函数（无论他是普通函数还是构造函数）能够继承Object.prototype这个最大的资源库，就必须让Function或this.prototype=new Object

__proto__存在就是为了指向prototype，prototype存在就是为了被__proto__指向。它们两个共同存在就是为了继承，继承就是为了复用，复用就是为了节省空间。




































































		
			
			
			
			
			
			
			
			
			


















































